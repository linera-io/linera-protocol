<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `LINERA_TYPES_SOL` constant in crate `linera_execution`."><title>LINERA_TYPES_SOL in linera_execution - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-6c3ea77c.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="linera_execution" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0 (05f9846f8 2025-03-31)" data-channel="1.86.0" data-search-js="search-581efc7a.js" data-settings-js="settings-6dad6058.js" ><script src="../static.files/storage-3a5871a4.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-4d63596a.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc constant"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../linera_execution/index.html">linera_<wbr>execution</a><span class="version">0.16.0</span></h2></div><div class="sidebar-elems"><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="index.html">linera_execution</a></div><h1>Constant <span class="constant">LINERA_TYPES_SOL</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/linera_execution/lib.rs.html#83">Source</a> </span></div><pre class="rust item-decl"><code>pub const LINERA_TYPES_SOL: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.86.0/std/primitive.str.html">str</a> = &quot;/// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nlibrary LineraTypes {\n\n    function bcs_serialize_len(uint256 x)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory result;\n        bytes1 entry;\n        while (true) {\n            if (x &lt; 128) {\n                entry = bytes1(uint8(x));\n                return abi.encodePacked(result, entry);\n            } else {\n                uint256 xb = x &gt;&gt; 7;\n                uint256 remainder = x - (xb &lt;&lt; 7);\n                require(remainder &lt; 128);\n                entry = bytes1(uint8(remainder) + 128);\n                result = abi.encodePacked(result, entry);\n                x = xb;\n            }\n        }\n        require(false, \&quot;This line is unreachable\&quot;);\n        return result;\n    }\n\n    function bcs_deserialize_offset_len(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, uint256)\n    {\n        uint256 idx = 0;\n        while (true) {\n            if (uint8(input[pos + idx]) &lt; 128) {\n                uint256 result = 0;\n                uint256 power = 1;\n                for (uint256 u=0; u&lt;idx; u++) {\n                    uint8 val = uint8(input[pos + u]) - 128;\n                    result += power * uint256(val);\n                    power *= 128;\n                }\n                result += power * uint8(input[pos + idx]);\n                return (pos + idx + 1, result);\n            }\n            idx += 1;\n        }\n        require(false, \&quot;This line is unreachable\&quot;);\n        return (0,0);\n    }\n\n    struct AccountOwner {\n        uint8 choice;\n        // choice=0 corresponds to Reserved\n        uint8 reserved;\n        // choice=1 corresponds to Address32\n        CryptoHash address32;\n        // choice=2 corresponds to Address20\n        bytes20 address20;\n    }\n\n    function AccountOwner_case_reserved(uint8 reserved)\n        internal\n        pure\n        returns (AccountOwner memory)\n    {\n        CryptoHash memory address32;\n        bytes20 address20;\n        return AccountOwner(uint8(0), reserved, address32, address20);\n    }\n\n    function AccountOwner_case_address32(CryptoHash memory address32)\n        internal\n        pure\n        returns (AccountOwner memory)\n    {\n        uint8 reserved;\n        bytes20 address20;\n        return AccountOwner(uint8(1), reserved, address32, address20);\n    }\n\n    function AccountOwner_case_address20(bytes20 address20)\n        internal\n        pure\n        returns (AccountOwner memory)\n    {\n        uint8 reserved;\n        CryptoHash memory address32;\n        return AccountOwner(uint8(2), reserved, address32, address20);\n    }\n\n    function bcs_serialize_AccountOwner(AccountOwner memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        if (input.choice == 0) {\n            return abi.encodePacked(input.choice, bcs_serialize_uint8(input.reserved));\n        }\n        if (input.choice == 1) {\n            return abi.encodePacked(input.choice, bcs_serialize_CryptoHash(input.address32));\n        }\n        if (input.choice == 2) {\n            return abi.encodePacked(input.choice, bcs_serialize_bytes20(input.address20));\n        }\n        return abi.encodePacked(input.choice);\n    }\n\n    function bcs_deserialize_offset_AccountOwner(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, AccountOwner memory)\n    {\n        uint256 new_pos;\n        uint8 choice;\n        (new_pos, choice) = bcs_deserialize_offset_uint8(pos, input);\n        uint8 reserved;\n        if (choice == 0) {\n            (new_pos, reserved) = bcs_deserialize_offset_uint8(new_pos, input);\n        }\n        CryptoHash memory address32;\n        if (choice == 1) {\n            (new_pos, address32) = bcs_deserialize_offset_CryptoHash(new_pos, input);\n        }\n        bytes20 address20;\n        if (choice == 2) {\n            (new_pos, address20) = bcs_deserialize_offset_bytes20(new_pos, input);\n        }\n        require(choice &lt; 3);\n        return (new_pos, AccountOwner(choice, reserved, address32, address20));\n    }\n\n    function bcs_deserialize_AccountOwner(bytes memory input)\n        internal\n        pure\n        returns (AccountOwner memory)\n    {\n        uint256 new_pos;\n        AccountOwner memory value;\n        (new_pos, value) = bcs_deserialize_offset_AccountOwner(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct AccountOwnerBalanceInner {\n        AccountOwner account_owner;\n        Amount balance_;\n    }\n\n    function bcs_serialize_AccountOwnerBalanceInner(AccountOwnerBalanceInner memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory result = bcs_serialize_AccountOwner(input.account_owner);\n        return abi.encodePacked(result, bcs_serialize_Amount(input.balance_));\n    }\n\n    function bcs_deserialize_offset_AccountOwnerBalanceInner(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, AccountOwnerBalanceInner memory)\n    {\n        uint256 new_pos;\n        AccountOwner memory account_owner;\n        (new_pos, account_owner) = bcs_deserialize_offset_AccountOwner(pos, input);\n        Amount memory balance_;\n        (new_pos, balance_) = bcs_deserialize_offset_Amount(new_pos, input);\n        return (new_pos, AccountOwnerBalanceInner(account_owner, balance_));\n    }\n\n    function bcs_deserialize_AccountOwnerBalanceInner(bytes memory input)\n        internal\n        pure\n        returns (AccountOwnerBalanceInner memory)\n    {\n        uint256 new_pos;\n        AccountOwnerBalanceInner memory value;\n        (new_pos, value) = bcs_deserialize_offset_AccountOwnerBalanceInner(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct Amount {\n        bytes32 value;\n    }\n\n    function bcs_serialize_Amount(Amount memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return bcs_serialize_bytes32(input.value);\n    }\n\n    function bcs_deserialize_offset_Amount(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, Amount memory)\n    {\n        uint256 new_pos;\n        bytes32 value;\n        (new_pos, value) = bcs_deserialize_offset_bytes32(pos, input);\n        return (new_pos, Amount(value));\n    }\n\n    function bcs_deserialize_Amount(bytes memory input)\n        internal\n        pure\n        returns (Amount memory)\n    {\n        uint256 new_pos;\n        Amount memory value;\n        (new_pos, value) = bcs_deserialize_offset_Amount(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct ApplicationId {\n        CryptoHash application_description_hash;\n    }\n\n    function bcs_serialize_ApplicationId(ApplicationId memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return bcs_serialize_CryptoHash(input.application_description_hash);\n    }\n\n    function bcs_deserialize_offset_ApplicationId(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, ApplicationId memory)\n    {\n        uint256 new_pos;\n        CryptoHash memory application_description_hash;\n        (new_pos, application_description_hash) = bcs_deserialize_offset_CryptoHash(pos, input);\n        return (new_pos, ApplicationId(application_description_hash));\n    }\n\n    function bcs_deserialize_ApplicationId(bytes memory input)\n        internal\n        pure\n        returns (ApplicationId memory)\n    {\n        uint256 new_pos;\n        ApplicationId memory value;\n        (new_pos, value) = bcs_deserialize_offset_ApplicationId(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct BaseRuntimePrecompile {\n        uint8 choice;\n        // choice=0 corresponds to ChainId\n        // choice=1 corresponds to BlockHeight\n        // choice=2 corresponds to ApplicationCreatorChainId\n        // choice=3 corresponds to ReadSystemTimestamp\n        // choice=4 corresponds to ReadChainBalance\n        // choice=5 corresponds to ReadOwnerBalance\n        AccountOwner read_owner_balance;\n        // choice=6 corresponds to ReadOwnerBalances\n        // choice=7 corresponds to ReadBalanceOwners\n        // choice=8 corresponds to ChainOwnership\n        // choice=9 corresponds to ReadDataBlob\n        DataBlobHash read_data_blob;\n        // choice=10 corresponds to AssertDataBlobExists\n        DataBlobHash assert_data_blob_exists;\n    }\n\n    function BaseRuntimePrecompile_case_chain_id()\n        internal\n        pure\n        returns (BaseRuntimePrecompile memory)\n    {\n        AccountOwner memory read_owner_balance;\n        DataBlobHash memory read_data_blob;\n        DataBlobHash memory assert_data_blob_exists;\n        return BaseRuntimePrecompile(uint8(0), read_owner_balance, read_data_blob, assert_data_blob_exists);\n    }\n\n    function BaseRuntimePrecompile_case_block_height()\n        internal\n        pure\n        returns (BaseRuntimePrecompile memory)\n    {\n        AccountOwner memory read_owner_balance;\n        DataBlobHash memory read_data_blob;\n        DataBlobHash memory assert_data_blob_exists;\n        return BaseRuntimePrecompile(uint8(1), read_owner_balance, read_data_blob, assert_data_blob_exists);\n    }\n\n    function BaseRuntimePrecompile_case_application_creator_chain_id()\n        internal\n        pure\n        returns (BaseRuntimePrecompile memory)\n    {\n        AccountOwner memory read_owner_balance;\n        DataBlobHash memory read_data_blob;\n        DataBlobHash memory assert_data_blob_exists;\n        return BaseRuntimePrecompile(uint8(2), read_owner_balance, read_data_blob, assert_data_blob_exists);\n    }\n\n    function BaseRuntimePrecompile_case_read_system_timestamp()\n        internal\n        pure\n        returns (BaseRuntimePrecompile memory)\n    {\n        AccountOwner memory read_owner_balance;\n        DataBlobHash memory read_data_blob;\n        DataBlobHash memory assert_data_blob_exists;\n        return BaseRuntimePrecompile(uint8(3), read_owner_balance, read_data_blob, assert_data_blob_exists);\n    }\n\n    function BaseRuntimePrecompile_case_read_chain_balance()\n        internal\n        pure\n        returns (BaseRuntimePrecompile memory)\n    {\n        AccountOwner memory read_owner_balance;\n        DataBlobHash memory read_data_blob;\n        DataBlobHash memory assert_data_blob_exists;\n        return BaseRuntimePrecompile(uint8(4), read_owner_balance, read_data_blob, assert_data_blob_exists);\n    }\n\n    function BaseRuntimePrecompile_case_read_owner_balance(AccountOwner memory read_owner_balance)\n        internal\n        pure\n        returns (BaseRuntimePrecompile memory)\n    {\n        DataBlobHash memory read_data_blob;\n        DataBlobHash memory assert_data_blob_exists;\n        return BaseRuntimePrecompile(uint8(5), read_owner_balance, read_data_blob, assert_data_blob_exists);\n    }\n\n    function BaseRuntimePrecompile_case_read_owner_balances()\n        internal\n        pure\n        returns (BaseRuntimePrecompile memory)\n    {\n        AccountOwner memory read_owner_balance;\n        DataBlobHash memory read_data_blob;\n        DataBlobHash memory assert_data_blob_exists;\n        return BaseRuntimePrecompile(uint8(6), read_owner_balance, read_data_blob, assert_data_blob_exists);\n    }\n\n    function BaseRuntimePrecompile_case_read_balance_owners()\n        internal\n        pure\n        returns (BaseRuntimePrecompile memory)\n    {\n        AccountOwner memory read_owner_balance;\n        DataBlobHash memory read_data_blob;\n        DataBlobHash memory assert_data_blob_exists;\n        return BaseRuntimePrecompile(uint8(7), read_owner_balance, read_data_blob, assert_data_blob_exists);\n    }\n\n    function BaseRuntimePrecompile_case_chain_ownership()\n        internal\n        pure\n        returns (BaseRuntimePrecompile memory)\n    {\n        AccountOwner memory read_owner_balance;\n        DataBlobHash memory read_data_blob;\n        DataBlobHash memory assert_data_blob_exists;\n        return BaseRuntimePrecompile(uint8(8), read_owner_balance, read_data_blob, assert_data_blob_exists);\n    }\n\n    function BaseRuntimePrecompile_case_read_data_blob(DataBlobHash memory read_data_blob)\n        internal\n        pure\n        returns (BaseRuntimePrecompile memory)\n    {\n        AccountOwner memory read_owner_balance;\n        DataBlobHash memory assert_data_blob_exists;\n        return BaseRuntimePrecompile(uint8(9), read_owner_balance, read_data_blob, assert_data_blob_exists);\n    }\n\n    function BaseRuntimePrecompile_case_assert_data_blob_exists(DataBlobHash memory assert_data_blob_exists)\n        internal\n        pure\n        returns (BaseRuntimePrecompile memory)\n    {\n        AccountOwner memory read_owner_balance;\n        DataBlobHash memory read_data_blob;\n        return BaseRuntimePrecompile(uint8(10), read_owner_balance, read_data_blob, assert_data_blob_exists);\n    }\n\n    function bcs_serialize_BaseRuntimePrecompile(BaseRuntimePrecompile memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        if (input.choice == 5) {\n            return abi.encodePacked(input.choice, bcs_serialize_AccountOwner(input.read_owner_balance));\n        }\n        if (input.choice == 9) {\n            return abi.encodePacked(input.choice, bcs_serialize_DataBlobHash(input.read_data_blob));\n        }\n        if (input.choice == 10) {\n            return abi.encodePacked(input.choice, bcs_serialize_DataBlobHash(input.assert_data_blob_exists));\n        }\n        return abi.encodePacked(input.choice);\n    }\n\n    function bcs_deserialize_offset_BaseRuntimePrecompile(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, BaseRuntimePrecompile memory)\n    {\n        uint256 new_pos;\n        uint8 choice;\n        (new_pos, choice) = bcs_deserialize_offset_uint8(pos, input);\n        AccountOwner memory read_owner_balance;\n        if (choice == 5) {\n            (new_pos, read_owner_balance) = bcs_deserialize_offset_AccountOwner(new_pos, input);\n        }\n        DataBlobHash memory read_data_blob;\n        if (choice == 9) {\n            (new_pos, read_data_blob) = bcs_deserialize_offset_DataBlobHash(new_pos, input);\n        }\n        DataBlobHash memory assert_data_blob_exists;\n        if (choice == 10) {\n            (new_pos, assert_data_blob_exists) = bcs_deserialize_offset_DataBlobHash(new_pos, input);\n        }\n        require(choice &lt; 11);\n        return (new_pos, BaseRuntimePrecompile(choice, read_owner_balance, read_data_blob, assert_data_blob_exists));\n    }\n\n    function bcs_deserialize_BaseRuntimePrecompile(bytes memory input)\n        internal\n        pure\n        returns (BaseRuntimePrecompile memory)\n    {\n        uint256 new_pos;\n        BaseRuntimePrecompile memory value;\n        (new_pos, value) = bcs_deserialize_offset_BaseRuntimePrecompile(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct BlockHeight {\n        uint64 value;\n    }\n\n    function bcs_serialize_BlockHeight(BlockHeight memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return bcs_serialize_uint64(input.value);\n    }\n\n    function bcs_deserialize_offset_BlockHeight(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, BlockHeight memory)\n    {\n        uint256 new_pos;\n        uint64 value;\n        (new_pos, value) = bcs_deserialize_offset_uint64(pos, input);\n        return (new_pos, BlockHeight(value));\n    }\n\n    function bcs_deserialize_BlockHeight(bytes memory input)\n        internal\n        pure\n        returns (BlockHeight memory)\n    {\n        uint256 new_pos;\n        BlockHeight memory value;\n        (new_pos, value) = bcs_deserialize_offset_BlockHeight(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct ChainId {\n        CryptoHash value;\n    }\n\n    function bcs_serialize_ChainId(ChainId memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return bcs_serialize_CryptoHash(input.value);\n    }\n\n    function bcs_deserialize_offset_ChainId(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, ChainId memory)\n    {\n        uint256 new_pos;\n        CryptoHash memory value;\n        (new_pos, value) = bcs_deserialize_offset_CryptoHash(pos, input);\n        return (new_pos, ChainId(value));\n    }\n\n    function bcs_deserialize_ChainId(bytes memory input)\n        internal\n        pure\n        returns (ChainId memory)\n    {\n        uint256 new_pos;\n        ChainId memory value;\n        (new_pos, value) = bcs_deserialize_offset_ChainId(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct ChainOwnership {\n        AccountOwner[] super_owners;\n        key_values_AccountOwner_uint64[] owners;\n        uint32 multi_leader_rounds;\n        bool open_multi_leader_rounds;\n        TimeoutConfig timeout_config;\n    }\n\n    function bcs_serialize_ChainOwnership(ChainOwnership memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory result = bcs_serialize_seq_AccountOwner(input.super_owners);\n        result = abi.encodePacked(result, bcs_serialize_seq_key_values_AccountOwner_uint64(input.owners));\n        result = abi.encodePacked(result, bcs_serialize_uint32(input.multi_leader_rounds));\n        result = abi.encodePacked(result, bcs_serialize_bool(input.open_multi_leader_rounds));\n        return abi.encodePacked(result, bcs_serialize_TimeoutConfig(input.timeout_config));\n    }\n\n    function bcs_deserialize_offset_ChainOwnership(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, ChainOwnership memory)\n    {\n        uint256 new_pos;\n        AccountOwner[] memory super_owners;\n        (new_pos, super_owners) = bcs_deserialize_offset_seq_AccountOwner(pos, input);\n        key_values_AccountOwner_uint64[] memory owners;\n        (new_pos, owners) = bcs_deserialize_offset_seq_key_values_AccountOwner_uint64(new_pos, input);\n        uint32 multi_leader_rounds;\n        (new_pos, multi_leader_rounds) = bcs_deserialize_offset_uint32(new_pos, input);\n        bool open_multi_leader_rounds;\n        (new_pos, open_multi_leader_rounds) = bcs_deserialize_offset_bool(new_pos, input);\n        TimeoutConfig memory timeout_config;\n        (new_pos, timeout_config) = bcs_deserialize_offset_TimeoutConfig(new_pos, input);\n        return (new_pos, ChainOwnership(super_owners, owners, multi_leader_rounds, open_multi_leader_rounds, timeout_config));\n    }\n\n    function bcs_deserialize_ChainOwnership(bytes memory input)\n        internal\n        pure\n        returns (ChainOwnership memory)\n    {\n        uint256 new_pos;\n        ChainOwnership memory value;\n        (new_pos, value) = bcs_deserialize_offset_ChainOwnership(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct ContractRuntimePrecompile {\n        uint8 choice;\n        // choice=0 corresponds to AuthenticatedOwner\n        // choice=1 corresponds to MessageOriginChainId\n        // choice=2 corresponds to MessageIsBouncing\n        // choice=3 corresponds to AuthenticatedCallerId\n        // choice=4 corresponds to SendMessage\n        ContractRuntimePrecompile_SendMessage send_message;\n        // choice=5 corresponds to TryCallApplication\n        ContractRuntimePrecompile_TryCallApplication try_call_application;\n        // choice=6 corresponds to Emit\n        ContractRuntimePrecompile_Emit emit_;\n        // choice=7 corresponds to ReadEvent\n        ContractRuntimePrecompile_ReadEvent read_event;\n        // choice=8 corresponds to SubscribeToEvents\n        ContractRuntimePrecompile_SubscribeToEvents subscribe_to_events;\n        // choice=9 corresponds to UnsubscribeFromEvents\n        ContractRuntimePrecompile_UnsubscribeFromEvents unsubscribe_from_events;\n        // choice=10 corresponds to QueryService\n        ContractRuntimePrecompile_QueryService query_service;\n        // choice=11 corresponds to ValidationRound\n    }\n\n    function ContractRuntimePrecompile_case_authenticated_owner()\n        internal\n        pure\n        returns (ContractRuntimePrecompile memory)\n    {\n        ContractRuntimePrecompile_SendMessage memory send_message;\n        ContractRuntimePrecompile_TryCallApplication memory try_call_application;\n        ContractRuntimePrecompile_Emit memory emit_;\n        ContractRuntimePrecompile_ReadEvent memory read_event;\n        ContractRuntimePrecompile_SubscribeToEvents memory subscribe_to_events;\n        ContractRuntimePrecompile_UnsubscribeFromEvents memory unsubscribe_from_events;\n        ContractRuntimePrecompile_QueryService memory query_service;\n        return ContractRuntimePrecompile(uint8(0), send_message, try_call_application, emit_, read_event, subscribe_to_events, unsubscribe_from_events, query_service);\n    }\n\n    function ContractRuntimePrecompile_case_message_origin_chain_id()\n        internal\n        pure\n        returns (ContractRuntimePrecompile memory)\n    {\n        ContractRuntimePrecompile_SendMessage memory send_message;\n        ContractRuntimePrecompile_TryCallApplication memory try_call_application;\n        ContractRuntimePrecompile_Emit memory emit_;\n        ContractRuntimePrecompile_ReadEvent memory read_event;\n        ContractRuntimePrecompile_SubscribeToEvents memory subscribe_to_events;\n        ContractRuntimePrecompile_UnsubscribeFromEvents memory unsubscribe_from_events;\n        ContractRuntimePrecompile_QueryService memory query_service;\n        return ContractRuntimePrecompile(uint8(1), send_message, try_call_application, emit_, read_event, subscribe_to_events, unsubscribe_from_events, query_service);\n    }\n\n    function ContractRuntimePrecompile_case_message_is_bouncing()\n        internal\n        pure\n        returns (ContractRuntimePrecompile memory)\n    {\n        ContractRuntimePrecompile_SendMessage memory send_message;\n        ContractRuntimePrecompile_TryCallApplication memory try_call_application;\n        ContractRuntimePrecompile_Emit memory emit_;\n        ContractRuntimePrecompile_ReadEvent memory read_event;\n        ContractRuntimePrecompile_SubscribeToEvents memory subscribe_to_events;\n        ContractRuntimePrecompile_UnsubscribeFromEvents memory unsubscribe_from_events;\n        ContractRuntimePrecompile_QueryService memory query_service;\n        return ContractRuntimePrecompile(uint8(2), send_message, try_call_application, emit_, read_event, subscribe_to_events, unsubscribe_from_events, query_service);\n    }\n\n    function ContractRuntimePrecompile_case_authenticated_caller_id()\n        internal\n        pure\n        returns (ContractRuntimePrecompile memory)\n    {\n        ContractRuntimePrecompile_SendMessage memory send_message;\n        ContractRuntimePrecompile_TryCallApplication memory try_call_application;\n        ContractRuntimePrecompile_Emit memory emit_;\n        ContractRuntimePrecompile_ReadEvent memory read_event;\n        ContractRuntimePrecompile_SubscribeToEvents memory subscribe_to_events;\n        ContractRuntimePrecompile_UnsubscribeFromEvents memory unsubscribe_from_events;\n        ContractRuntimePrecompile_QueryService memory query_service;\n        return ContractRuntimePrecompile(uint8(3), send_message, try_call_application, emit_, read_event, subscribe_to_events, unsubscribe_from_events, query_service);\n    }\n\n    function ContractRuntimePrecompile_case_send_message(ContractRuntimePrecompile_SendMessage memory send_message)\n        internal\n        pure\n        returns (ContractRuntimePrecompile memory)\n    {\n        ContractRuntimePrecompile_TryCallApplication memory try_call_application;\n        ContractRuntimePrecompile_Emit memory emit_;\n        ContractRuntimePrecompile_ReadEvent memory read_event;\n        ContractRuntimePrecompile_SubscribeToEvents memory subscribe_to_events;\n        ContractRuntimePrecompile_UnsubscribeFromEvents memory unsubscribe_from_events;\n        ContractRuntimePrecompile_QueryService memory query_service;\n        return ContractRuntimePrecompile(uint8(4), send_message, try_call_application, emit_, read_event, subscribe_to_events, unsubscribe_from_events, query_service);\n    }\n\n    function ContractRuntimePrecompile_case_try_call_application(ContractRuntimePrecompile_TryCallApplication memory try_call_application)\n        internal\n        pure\n        returns (ContractRuntimePrecompile memory)\n    {\n        ContractRuntimePrecompile_SendMessage memory send_message;\n        ContractRuntimePrecompile_Emit memory emit_;\n        ContractRuntimePrecompile_ReadEvent memory read_event;\n        ContractRuntimePrecompile_SubscribeToEvents memory subscribe_to_events;\n        ContractRuntimePrecompile_UnsubscribeFromEvents memory unsubscribe_from_events;\n        ContractRuntimePrecompile_QueryService memory query_service;\n        return ContractRuntimePrecompile(uint8(5), send_message, try_call_application, emit_, read_event, subscribe_to_events, unsubscribe_from_events, query_service);\n    }\n\n    function ContractRuntimePrecompile_case_emit(ContractRuntimePrecompile_Emit memory emit_)\n        internal\n        pure\n        returns (ContractRuntimePrecompile memory)\n    {\n        ContractRuntimePrecompile_SendMessage memory send_message;\n        ContractRuntimePrecompile_TryCallApplication memory try_call_application;\n        ContractRuntimePrecompile_ReadEvent memory read_event;\n        ContractRuntimePrecompile_SubscribeToEvents memory subscribe_to_events;\n        ContractRuntimePrecompile_UnsubscribeFromEvents memory unsubscribe_from_events;\n        ContractRuntimePrecompile_QueryService memory query_service;\n        return ContractRuntimePrecompile(uint8(6), send_message, try_call_application, emit_, read_event, subscribe_to_events, unsubscribe_from_events, query_service);\n    }\n\n    function ContractRuntimePrecompile_case_read_event(ContractRuntimePrecompile_ReadEvent memory read_event)\n        internal\n        pure\n        returns (ContractRuntimePrecompile memory)\n    {\n        ContractRuntimePrecompile_SendMessage memory send_message;\n        ContractRuntimePrecompile_TryCallApplication memory try_call_application;\n        ContractRuntimePrecompile_Emit memory emit_;\n        ContractRuntimePrecompile_SubscribeToEvents memory subscribe_to_events;\n        ContractRuntimePrecompile_UnsubscribeFromEvents memory unsubscribe_from_events;\n        ContractRuntimePrecompile_QueryService memory query_service;\n        return ContractRuntimePrecompile(uint8(7), send_message, try_call_application, emit_, read_event, subscribe_to_events, unsubscribe_from_events, query_service);\n    }\n\n    function ContractRuntimePrecompile_case_subscribe_to_events(ContractRuntimePrecompile_SubscribeToEvents memory subscribe_to_events)\n        internal\n        pure\n        returns (ContractRuntimePrecompile memory)\n    {\n        ContractRuntimePrecompile_SendMessage memory send_message;\n        ContractRuntimePrecompile_TryCallApplication memory try_call_application;\n        ContractRuntimePrecompile_Emit memory emit_;\n        ContractRuntimePrecompile_ReadEvent memory read_event;\n        ContractRuntimePrecompile_UnsubscribeFromEvents memory unsubscribe_from_events;\n        ContractRuntimePrecompile_QueryService memory query_service;\n        return ContractRuntimePrecompile(uint8(8), send_message, try_call_application, emit_, read_event, subscribe_to_events, unsubscribe_from_events, query_service);\n    }\n\n    function ContractRuntimePrecompile_case_unsubscribe_from_events(ContractRuntimePrecompile_UnsubscribeFromEvents memory unsubscribe_from_events)\n        internal\n        pure\n        returns (ContractRuntimePrecompile memory)\n    {\n        ContractRuntimePrecompile_SendMessage memory send_message;\n        ContractRuntimePrecompile_TryCallApplication memory try_call_application;\n        ContractRuntimePrecompile_Emit memory emit_;\n        ContractRuntimePrecompile_ReadEvent memory read_event;\n        ContractRuntimePrecompile_SubscribeToEvents memory subscribe_to_events;\n        ContractRuntimePrecompile_QueryService memory query_service;\n        return ContractRuntimePrecompile(uint8(9), send_message, try_call_application, emit_, read_event, subscribe_to_events, unsubscribe_from_events, query_service);\n    }\n\n    function ContractRuntimePrecompile_case_query_service(ContractRuntimePrecompile_QueryService memory query_service)\n        internal\n        pure\n        returns (ContractRuntimePrecompile memory)\n    {\n        ContractRuntimePrecompile_SendMessage memory send_message;\n        ContractRuntimePrecompile_TryCallApplication memory try_call_application;\n        ContractRuntimePrecompile_Emit memory emit_;\n        ContractRuntimePrecompile_ReadEvent memory read_event;\n        ContractRuntimePrecompile_SubscribeToEvents memory subscribe_to_events;\n        ContractRuntimePrecompile_UnsubscribeFromEvents memory unsubscribe_from_events;\n        return ContractRuntimePrecompile(uint8(10), send_message, try_call_application, emit_, read_event, subscribe_to_events, unsubscribe_from_events, query_service);\n    }\n\n    function ContractRuntimePrecompile_case_validation_round()\n        internal\n        pure\n        returns (ContractRuntimePrecompile memory)\n    {\n        ContractRuntimePrecompile_SendMessage memory send_message;\n        ContractRuntimePrecompile_TryCallApplication memory try_call_application;\n        ContractRuntimePrecompile_Emit memory emit_;\n        ContractRuntimePrecompile_ReadEvent memory read_event;\n        ContractRuntimePrecompile_SubscribeToEvents memory subscribe_to_events;\n        ContractRuntimePrecompile_UnsubscribeFromEvents memory unsubscribe_from_events;\n        ContractRuntimePrecompile_QueryService memory query_service;\n        return ContractRuntimePrecompile(uint8(11), send_message, try_call_application, emit_, read_event, subscribe_to_events, unsubscribe_from_events, query_service);\n    }\n\n    function bcs_serialize_ContractRuntimePrecompile(ContractRuntimePrecompile memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        if (input.choice == 4) {\n            return abi.encodePacked(input.choice, bcs_serialize_ContractRuntimePrecompile_SendMessage(input.send_message));\n        }\n        if (input.choice == 5) {\n            return abi.encodePacked(input.choice, bcs_serialize_ContractRuntimePrecompile_TryCallApplication(input.try_call_application));\n        }\n        if (input.choice == 6) {\n            return abi.encodePacked(input.choice, bcs_serialize_ContractRuntimePrecompile_Emit(input.emit_));\n        }\n        if (input.choice == 7) {\n            return abi.encodePacked(input.choice, bcs_serialize_ContractRuntimePrecompile_ReadEvent(input.read_event));\n        }\n        if (input.choice == 8) {\n            return abi.encodePacked(input.choice, bcs_serialize_ContractRuntimePrecompile_SubscribeToEvents(input.subscribe_to_events));\n        }\n        if (input.choice == 9) {\n            return abi.encodePacked(input.choice, bcs_serialize_ContractRuntimePrecompile_UnsubscribeFromEvents(input.unsubscribe_from_events));\n        }\n        if (input.choice == 10) {\n            return abi.encodePacked(input.choice, bcs_serialize_ContractRuntimePrecompile_QueryService(input.query_service));\n        }\n        return abi.encodePacked(input.choice);\n    }\n\n    function bcs_deserialize_offset_ContractRuntimePrecompile(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, ContractRuntimePrecompile memory)\n    {\n        uint256 new_pos;\n        uint8 choice;\n        (new_pos, choice) = bcs_deserialize_offset_uint8(pos, input);\n        ContractRuntimePrecompile_SendMessage memory send_message;\n        if (choice == 4) {\n            (new_pos, send_message) = bcs_deserialize_offset_ContractRuntimePrecompile_SendMessage(new_pos, input);\n        }\n        ContractRuntimePrecompile_TryCallApplication memory try_call_application;\n        if (choice == 5) {\n            (new_pos, try_call_application) = bcs_deserialize_offset_ContractRuntimePrecompile_TryCallApplication(new_pos, input);\n        }\n        ContractRuntimePrecompile_Emit memory emit_;\n        if (choice == 6) {\n            (new_pos, emit_) = bcs_deserialize_offset_ContractRuntimePrecompile_Emit(new_pos, input);\n        }\n        ContractRuntimePrecompile_ReadEvent memory read_event;\n        if (choice == 7) {\n            (new_pos, read_event) = bcs_deserialize_offset_ContractRuntimePrecompile_ReadEvent(new_pos, input);\n        }\n        ContractRuntimePrecompile_SubscribeToEvents memory subscribe_to_events;\n        if (choice == 8) {\n            (new_pos, subscribe_to_events) = bcs_deserialize_offset_ContractRuntimePrecompile_SubscribeToEvents(new_pos, input);\n        }\n        ContractRuntimePrecompile_UnsubscribeFromEvents memory unsubscribe_from_events;\n        if (choice == 9) {\n            (new_pos, unsubscribe_from_events) = bcs_deserialize_offset_ContractRuntimePrecompile_UnsubscribeFromEvents(new_pos, input);\n        }\n        ContractRuntimePrecompile_QueryService memory query_service;\n        if (choice == 10) {\n            (new_pos, query_service) = bcs_deserialize_offset_ContractRuntimePrecompile_QueryService(new_pos, input);\n        }\n        require(choice &lt; 12);\n        return (new_pos, ContractRuntimePrecompile(choice, send_message, try_call_application, emit_, read_event, subscribe_to_events, unsubscribe_from_events, query_service));\n    }\n\n    function bcs_deserialize_ContractRuntimePrecompile(bytes memory input)\n        internal\n        pure\n        returns (ContractRuntimePrecompile memory)\n    {\n        uint256 new_pos;\n        ContractRuntimePrecompile memory value;\n        (new_pos, value) = bcs_deserialize_offset_ContractRuntimePrecompile(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct ContractRuntimePrecompile_Emit {\n        StreamName stream_name;\n        bytes value;\n    }\n\n    function bcs_serialize_ContractRuntimePrecompile_Emit(ContractRuntimePrecompile_Emit memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory result = bcs_serialize_StreamName(input.stream_name);\n        return abi.encodePacked(result, bcs_serialize_bytes(input.value));\n    }\n\n    function bcs_deserialize_offset_ContractRuntimePrecompile_Emit(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, ContractRuntimePrecompile_Emit memory)\n    {\n        uint256 new_pos;\n        StreamName memory stream_name;\n        (new_pos, stream_name) = bcs_deserialize_offset_StreamName(pos, input);\n        bytes memory value;\n        (new_pos, value) = bcs_deserialize_offset_bytes(new_pos, input);\n        return (new_pos, ContractRuntimePrecompile_Emit(stream_name, value));\n    }\n\n    function bcs_deserialize_ContractRuntimePrecompile_Emit(bytes memory input)\n        internal\n        pure\n        returns (ContractRuntimePrecompile_Emit memory)\n    {\n        uint256 new_pos;\n        ContractRuntimePrecompile_Emit memory value;\n        (new_pos, value) = bcs_deserialize_offset_ContractRuntimePrecompile_Emit(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct ContractRuntimePrecompile_QueryService {\n        ApplicationId application_id;\n        bytes query;\n    }\n\n    function bcs_serialize_ContractRuntimePrecompile_QueryService(ContractRuntimePrecompile_QueryService memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory result = bcs_serialize_ApplicationId(input.application_id);\n        return abi.encodePacked(result, bcs_serialize_bytes(input.query));\n    }\n\n    function bcs_deserialize_offset_ContractRuntimePrecompile_QueryService(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, ContractRuntimePrecompile_QueryService memory)\n    {\n        uint256 new_pos;\n        ApplicationId memory application_id;\n        (new_pos, application_id) = bcs_deserialize_offset_ApplicationId(pos, input);\n        bytes memory query;\n        (new_pos, query) = bcs_deserialize_offset_bytes(new_pos, input);\n        return (new_pos, ContractRuntimePrecompile_QueryService(application_id, query));\n    }\n\n    function bcs_deserialize_ContractRuntimePrecompile_QueryService(bytes memory input)\n        internal\n        pure\n        returns (ContractRuntimePrecompile_QueryService memory)\n    {\n        uint256 new_pos;\n        ContractRuntimePrecompile_QueryService memory value;\n        (new_pos, value) = bcs_deserialize_offset_ContractRuntimePrecompile_QueryService(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct ContractRuntimePrecompile_ReadEvent {\n        ChainId chain_id;\n        StreamName stream_name;\n        uint32 index;\n    }\n\n    function bcs_serialize_ContractRuntimePrecompile_ReadEvent(ContractRuntimePrecompile_ReadEvent memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory result = bcs_serialize_ChainId(input.chain_id);\n        result = abi.encodePacked(result, bcs_serialize_StreamName(input.stream_name));\n        return abi.encodePacked(result, bcs_serialize_uint32(input.index));\n    }\n\n    function bcs_deserialize_offset_ContractRuntimePrecompile_ReadEvent(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, ContractRuntimePrecompile_ReadEvent memory)\n    {\n        uint256 new_pos;\n        ChainId memory chain_id;\n        (new_pos, chain_id) = bcs_deserialize_offset_ChainId(pos, input);\n        StreamName memory stream_name;\n        (new_pos, stream_name) = bcs_deserialize_offset_StreamName(new_pos, input);\n        uint32 index;\n        (new_pos, index) = bcs_deserialize_offset_uint32(new_pos, input);\n        return (new_pos, ContractRuntimePrecompile_ReadEvent(chain_id, stream_name, index));\n    }\n\n    function bcs_deserialize_ContractRuntimePrecompile_ReadEvent(bytes memory input)\n        internal\n        pure\n        returns (ContractRuntimePrecompile_ReadEvent memory)\n    {\n        uint256 new_pos;\n        ContractRuntimePrecompile_ReadEvent memory value;\n        (new_pos, value) = bcs_deserialize_offset_ContractRuntimePrecompile_ReadEvent(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct ContractRuntimePrecompile_SendMessage {\n        ChainId destination;\n        bytes message;\n    }\n\n    function bcs_serialize_ContractRuntimePrecompile_SendMessage(ContractRuntimePrecompile_SendMessage memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory result = bcs_serialize_ChainId(input.destination);\n        return abi.encodePacked(result, bcs_serialize_bytes(input.message));\n    }\n\n    function bcs_deserialize_offset_ContractRuntimePrecompile_SendMessage(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, ContractRuntimePrecompile_SendMessage memory)\n    {\n        uint256 new_pos;\n        ChainId memory destination;\n        (new_pos, destination) = bcs_deserialize_offset_ChainId(pos, input);\n        bytes memory message;\n        (new_pos, message) = bcs_deserialize_offset_bytes(new_pos, input);\n        return (new_pos, ContractRuntimePrecompile_SendMessage(destination, message));\n    }\n\n    function bcs_deserialize_ContractRuntimePrecompile_SendMessage(bytes memory input)\n        internal\n        pure\n        returns (ContractRuntimePrecompile_SendMessage memory)\n    {\n        uint256 new_pos;\n        ContractRuntimePrecompile_SendMessage memory value;\n        (new_pos, value) = bcs_deserialize_offset_ContractRuntimePrecompile_SendMessage(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct ContractRuntimePrecompile_SubscribeToEvents {\n        ChainId chain_id;\n        ApplicationId application_id;\n        StreamName stream_name;\n    }\n\n    function bcs_serialize_ContractRuntimePrecompile_SubscribeToEvents(ContractRuntimePrecompile_SubscribeToEvents memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory result = bcs_serialize_ChainId(input.chain_id);\n        result = abi.encodePacked(result, bcs_serialize_ApplicationId(input.application_id));\n        return abi.encodePacked(result, bcs_serialize_StreamName(input.stream_name));\n    }\n\n    function bcs_deserialize_offset_ContractRuntimePrecompile_SubscribeToEvents(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, ContractRuntimePrecompile_SubscribeToEvents memory)\n    {\n        uint256 new_pos;\n        ChainId memory chain_id;\n        (new_pos, chain_id) = bcs_deserialize_offset_ChainId(pos, input);\n        ApplicationId memory application_id;\n        (new_pos, application_id) = bcs_deserialize_offset_ApplicationId(new_pos, input);\n        StreamName memory stream_name;\n        (new_pos, stream_name) = bcs_deserialize_offset_StreamName(new_pos, input);\n        return (new_pos, ContractRuntimePrecompile_SubscribeToEvents(chain_id, application_id, stream_name));\n    }\n\n    function bcs_deserialize_ContractRuntimePrecompile_SubscribeToEvents(bytes memory input)\n        internal\n        pure\n        returns (ContractRuntimePrecompile_SubscribeToEvents memory)\n    {\n        uint256 new_pos;\n        ContractRuntimePrecompile_SubscribeToEvents memory value;\n        (new_pos, value) = bcs_deserialize_offset_ContractRuntimePrecompile_SubscribeToEvents(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct ContractRuntimePrecompile_TryCallApplication {\n        ApplicationId target;\n        bytes argument;\n    }\n\n    function bcs_serialize_ContractRuntimePrecompile_TryCallApplication(ContractRuntimePrecompile_TryCallApplication memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory result = bcs_serialize_ApplicationId(input.target);\n        return abi.encodePacked(result, bcs_serialize_bytes(input.argument));\n    }\n\n    function bcs_deserialize_offset_ContractRuntimePrecompile_TryCallApplication(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, ContractRuntimePrecompile_TryCallApplication memory)\n    {\n        uint256 new_pos;\n        ApplicationId memory target;\n        (new_pos, target) = bcs_deserialize_offset_ApplicationId(pos, input);\n        bytes memory argument;\n        (new_pos, argument) = bcs_deserialize_offset_bytes(new_pos, input);\n        return (new_pos, ContractRuntimePrecompile_TryCallApplication(target, argument));\n    }\n\n    function bcs_deserialize_ContractRuntimePrecompile_TryCallApplication(bytes memory input)\n        internal\n        pure\n        returns (ContractRuntimePrecompile_TryCallApplication memory)\n    {\n        uint256 new_pos;\n        ContractRuntimePrecompile_TryCallApplication memory value;\n        (new_pos, value) = bcs_deserialize_offset_ContractRuntimePrecompile_TryCallApplication(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct ContractRuntimePrecompile_UnsubscribeFromEvents {\n        ChainId chain_id;\n        ApplicationId application_id;\n        StreamName stream_name;\n    }\n\n    function bcs_serialize_ContractRuntimePrecompile_UnsubscribeFromEvents(ContractRuntimePrecompile_UnsubscribeFromEvents memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory result = bcs_serialize_ChainId(input.chain_id);\n        result = abi.encodePacked(result, bcs_serialize_ApplicationId(input.application_id));\n        return abi.encodePacked(result, bcs_serialize_StreamName(input.stream_name));\n    }\n\n    function bcs_deserialize_offset_ContractRuntimePrecompile_UnsubscribeFromEvents(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, ContractRuntimePrecompile_UnsubscribeFromEvents memory)\n    {\n        uint256 new_pos;\n        ChainId memory chain_id;\n        (new_pos, chain_id) = bcs_deserialize_offset_ChainId(pos, input);\n        ApplicationId memory application_id;\n        (new_pos, application_id) = bcs_deserialize_offset_ApplicationId(new_pos, input);\n        StreamName memory stream_name;\n        (new_pos, stream_name) = bcs_deserialize_offset_StreamName(new_pos, input);\n        return (new_pos, ContractRuntimePrecompile_UnsubscribeFromEvents(chain_id, application_id, stream_name));\n    }\n\n    function bcs_deserialize_ContractRuntimePrecompile_UnsubscribeFromEvents(bytes memory input)\n        internal\n        pure\n        returns (ContractRuntimePrecompile_UnsubscribeFromEvents memory)\n    {\n        uint256 new_pos;\n        ContractRuntimePrecompile_UnsubscribeFromEvents memory value;\n        (new_pos, value) = bcs_deserialize_offset_ContractRuntimePrecompile_UnsubscribeFromEvents(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct CryptoHash {\n        bytes32 value;\n    }\n\n    function bcs_serialize_CryptoHash(CryptoHash memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return bcs_serialize_bytes32(input.value);\n    }\n\n    function bcs_deserialize_offset_CryptoHash(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, CryptoHash memory)\n    {\n        uint256 new_pos;\n        bytes32 value;\n        (new_pos, value) = bcs_deserialize_offset_bytes32(pos, input);\n        return (new_pos, CryptoHash(value));\n    }\n\n    function bcs_deserialize_CryptoHash(bytes memory input)\n        internal\n        pure\n        returns (CryptoHash memory)\n    {\n        uint256 new_pos;\n        CryptoHash memory value;\n        (new_pos, value) = bcs_deserialize_offset_CryptoHash(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct DataBlobHash {\n        CryptoHash value;\n    }\n\n    function bcs_serialize_DataBlobHash(DataBlobHash memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return bcs_serialize_CryptoHash(input.value);\n    }\n\n    function bcs_deserialize_offset_DataBlobHash(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, DataBlobHash memory)\n    {\n        uint256 new_pos;\n        CryptoHash memory value;\n        (new_pos, value) = bcs_deserialize_offset_CryptoHash(pos, input);\n        return (new_pos, DataBlobHash(value));\n    }\n\n    function bcs_deserialize_DataBlobHash(bytes memory input)\n        internal\n        pure\n        returns (DataBlobHash memory)\n    {\n        uint256 new_pos;\n        DataBlobHash memory value;\n        (new_pos, value) = bcs_deserialize_offset_DataBlobHash(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct GenericApplicationId {\n        uint8 choice;\n        // choice=0 corresponds to System\n        // choice=1 corresponds to User\n        ApplicationId user;\n    }\n\n    function GenericApplicationId_case_system()\n        internal\n        pure\n        returns (GenericApplicationId memory)\n    {\n        ApplicationId memory user;\n        return GenericApplicationId(uint8(0), user);\n    }\n\n    function GenericApplicationId_case_user(ApplicationId memory user)\n        internal\n        pure\n        returns (GenericApplicationId memory)\n    {\n        return GenericApplicationId(uint8(1), user);\n    }\n\n    function bcs_serialize_GenericApplicationId(GenericApplicationId memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        if (input.choice == 1) {\n            return abi.encodePacked(input.choice, bcs_serialize_ApplicationId(input.user));\n        }\n        return abi.encodePacked(input.choice);\n    }\n\n    function bcs_deserialize_offset_GenericApplicationId(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, GenericApplicationId memory)\n    {\n        uint256 new_pos;\n        uint8 choice;\n        (new_pos, choice) = bcs_deserialize_offset_uint8(pos, input);\n        ApplicationId memory user;\n        if (choice == 1) {\n            (new_pos, user) = bcs_deserialize_offset_ApplicationId(new_pos, input);\n        }\n        require(choice &lt; 2);\n        return (new_pos, GenericApplicationId(choice, user));\n    }\n\n    function bcs_deserialize_GenericApplicationId(bytes memory input)\n        internal\n        pure\n        returns (GenericApplicationId memory)\n    {\n        uint256 new_pos;\n        GenericApplicationId memory value;\n        (new_pos, value) = bcs_deserialize_offset_GenericApplicationId(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct MessageIsBouncing {\n        OptionBool value;\n    }\n\n    function bcs_serialize_MessageIsBouncing(MessageIsBouncing memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return bcs_serialize_OptionBool(input.value);\n    }\n\n    function bcs_deserialize_offset_MessageIsBouncing(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, MessageIsBouncing memory)\n    {\n        uint256 new_pos;\n        OptionBool value;\n        (new_pos, value) = bcs_deserialize_offset_OptionBool(pos, input);\n        return (new_pos, MessageIsBouncing(value));\n    }\n\n    function bcs_deserialize_MessageIsBouncing(bytes memory input)\n        internal\n        pure\n        returns (MessageIsBouncing memory)\n    {\n        uint256 new_pos;\n        MessageIsBouncing memory value;\n        (new_pos, value) = bcs_deserialize_offset_MessageIsBouncing(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct OptionAccountOwner {\n        opt_AccountOwner value;\n    }\n\n    function bcs_serialize_OptionAccountOwner(OptionAccountOwner memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return bcs_serialize_opt_AccountOwner(input.value);\n    }\n\n    function bcs_deserialize_offset_OptionAccountOwner(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, OptionAccountOwner memory)\n    {\n        uint256 new_pos;\n        opt_AccountOwner memory value;\n        (new_pos, value) = bcs_deserialize_offset_opt_AccountOwner(pos, input);\n        return (new_pos, OptionAccountOwner(value));\n    }\n\n    function bcs_deserialize_OptionAccountOwner(bytes memory input)\n        internal\n        pure\n        returns (OptionAccountOwner memory)\n    {\n        uint256 new_pos;\n        OptionAccountOwner memory value;\n        (new_pos, value) = bcs_deserialize_offset_OptionAccountOwner(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct OptionApplicationId {\n        opt_ApplicationId value;\n    }\n\n    function bcs_serialize_OptionApplicationId(OptionApplicationId memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return bcs_serialize_opt_ApplicationId(input.value);\n    }\n\n    function bcs_deserialize_offset_OptionApplicationId(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, OptionApplicationId memory)\n    {\n        uint256 new_pos;\n        opt_ApplicationId memory value;\n        (new_pos, value) = bcs_deserialize_offset_opt_ApplicationId(pos, input);\n        return (new_pos, OptionApplicationId(value));\n    }\n\n    function bcs_deserialize_OptionApplicationId(bytes memory input)\n        internal\n        pure\n        returns (OptionApplicationId memory)\n    {\n        uint256 new_pos;\n        OptionApplicationId memory value;\n        (new_pos, value) = bcs_deserialize_offset_OptionApplicationId(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    enum OptionBool { None, True, False }\n\n    function bcs_serialize_OptionBool(OptionBool input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        if (input == OptionBool.None) {\n            return abi.encodePacked(uint8(0));\n        }\n        if (input == OptionBool.False) {\n            return abi.encodePacked(uint8(1), uint8(0));\n        }\n        return abi.encodePacked(uint8(1), uint8(1));\n    }\n\n    function bcs_deserialize_offset_OptionBool(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, OptionBool)\n    {\n        uint8 choice = uint8(input[pos]);\n        if (choice == 0) {\n           return (pos + 1, OptionBool.None);\n        } else {\n            require(choice == 1);\n            uint8 value = uint8(input[pos + 1]);\n            if (value == 0) {\n                return (pos + 2, OptionBool.False);\n            } else {\n                require(value == 1);\n                return (pos + 2, OptionBool.True);\n            }\n        }\n    }\n\n    function bcs_deserialize_OptionBool(bytes memory input)\n        internal\n        pure\n        returns (OptionBool)\n    {\n        uint256 new_pos;\n        OptionBool value;\n        (new_pos, value) = bcs_deserialize_offset_OptionBool(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct OptionChainId {\n        opt_ChainId value;\n    }\n\n    function bcs_serialize_OptionChainId(OptionChainId memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return bcs_serialize_opt_ChainId(input.value);\n    }\n\n    function bcs_deserialize_offset_OptionChainId(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, OptionChainId memory)\n    {\n        uint256 new_pos;\n        opt_ChainId memory value;\n        (new_pos, value) = bcs_deserialize_offset_opt_ChainId(pos, input);\n        return (new_pos, OptionChainId(value));\n    }\n\n    function bcs_deserialize_OptionChainId(bytes memory input)\n        internal\n        pure\n        returns (OptionChainId memory)\n    {\n        uint256 new_pos;\n        OptionChainId memory value;\n        (new_pos, value) = bcs_deserialize_offset_OptionChainId(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct OptionU32 {\n        opt_uint32 value;\n    }\n\n    function bcs_serialize_OptionU32(OptionU32 memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return bcs_serialize_opt_uint32(input.value);\n    }\n\n    function bcs_deserialize_offset_OptionU32(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, OptionU32 memory)\n    {\n        uint256 new_pos;\n        opt_uint32 memory value;\n        (new_pos, value) = bcs_deserialize_offset_opt_uint32(pos, input);\n        return (new_pos, OptionU32(value));\n    }\n\n    function bcs_deserialize_OptionU32(bytes memory input)\n        internal\n        pure\n        returns (OptionU32 memory)\n    {\n        uint256 new_pos;\n        OptionU32 memory value;\n        (new_pos, value) = bcs_deserialize_offset_OptionU32(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct ResponseReadBalanceOwners {\n        AccountOwner[] value;\n    }\n\n    function bcs_serialize_ResponseReadBalanceOwners(ResponseReadBalanceOwners memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return bcs_serialize_seq_AccountOwner(input.value);\n    }\n\n    function bcs_deserialize_offset_ResponseReadBalanceOwners(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, ResponseReadBalanceOwners memory)\n    {\n        uint256 new_pos;\n        AccountOwner[] memory value;\n        (new_pos, value) = bcs_deserialize_offset_seq_AccountOwner(pos, input);\n        return (new_pos, ResponseReadBalanceOwners(value));\n    }\n\n    function bcs_deserialize_ResponseReadBalanceOwners(bytes memory input)\n        internal\n        pure\n        returns (ResponseReadBalanceOwners memory)\n    {\n        uint256 new_pos;\n        ResponseReadBalanceOwners memory value;\n        (new_pos, value) = bcs_deserialize_offset_ResponseReadBalanceOwners(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct ResponseReadOwnerBalances {\n        AccountOwnerBalanceInner[] value;\n    }\n\n    function bcs_serialize_ResponseReadOwnerBalances(ResponseReadOwnerBalances memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return bcs_serialize_seq_AccountOwnerBalanceInner(input.value);\n    }\n\n    function bcs_deserialize_offset_ResponseReadOwnerBalances(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, ResponseReadOwnerBalances memory)\n    {\n        uint256 new_pos;\n        AccountOwnerBalanceInner[] memory value;\n        (new_pos, value) = bcs_deserialize_offset_seq_AccountOwnerBalanceInner(pos, input);\n        return (new_pos, ResponseReadOwnerBalances(value));\n    }\n\n    function bcs_deserialize_ResponseReadOwnerBalances(bytes memory input)\n        internal\n        pure\n        returns (ResponseReadOwnerBalances memory)\n    {\n        uint256 new_pos;\n        ResponseReadOwnerBalances memory value;\n        (new_pos, value) = bcs_deserialize_offset_ResponseReadOwnerBalances(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct RuntimePrecompile {\n        uint8 choice;\n        // choice=0 corresponds to Base\n        BaseRuntimePrecompile base;\n        // choice=1 corresponds to Contract\n        ContractRuntimePrecompile contract_;\n        // choice=2 corresponds to Service\n        ServiceRuntimePrecompile service;\n    }\n\n    function RuntimePrecompile_case_base(BaseRuntimePrecompile memory base)\n        internal\n        pure\n        returns (RuntimePrecompile memory)\n    {\n        ContractRuntimePrecompile memory contract_;\n        ServiceRuntimePrecompile memory service;\n        return RuntimePrecompile(uint8(0), base, contract_, service);\n    }\n\n    function RuntimePrecompile_case_contract(ContractRuntimePrecompile memory contract_)\n        internal\n        pure\n        returns (RuntimePrecompile memory)\n    {\n        BaseRuntimePrecompile memory base;\n        ServiceRuntimePrecompile memory service;\n        return RuntimePrecompile(uint8(1), base, contract_, service);\n    }\n\n    function RuntimePrecompile_case_service(ServiceRuntimePrecompile memory service)\n        internal\n        pure\n        returns (RuntimePrecompile memory)\n    {\n        BaseRuntimePrecompile memory base;\n        ContractRuntimePrecompile memory contract_;\n        return RuntimePrecompile(uint8(2), base, contract_, service);\n    }\n\n    function bcs_serialize_RuntimePrecompile(RuntimePrecompile memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        if (input.choice == 0) {\n            return abi.encodePacked(input.choice, bcs_serialize_BaseRuntimePrecompile(input.base));\n        }\n        if (input.choice == 1) {\n            return abi.encodePacked(input.choice, bcs_serialize_ContractRuntimePrecompile(input.contract_));\n        }\n        if (input.choice == 2) {\n            return abi.encodePacked(input.choice, bcs_serialize_ServiceRuntimePrecompile(input.service));\n        }\n        return abi.encodePacked(input.choice);\n    }\n\n    function bcs_deserialize_offset_RuntimePrecompile(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, RuntimePrecompile memory)\n    {\n        uint256 new_pos;\n        uint8 choice;\n        (new_pos, choice) = bcs_deserialize_offset_uint8(pos, input);\n        BaseRuntimePrecompile memory base;\n        if (choice == 0) {\n            (new_pos, base) = bcs_deserialize_offset_BaseRuntimePrecompile(new_pos, input);\n        }\n        ContractRuntimePrecompile memory contract_;\n        if (choice == 1) {\n            (new_pos, contract_) = bcs_deserialize_offset_ContractRuntimePrecompile(new_pos, input);\n        }\n        ServiceRuntimePrecompile memory service;\n        if (choice == 2) {\n            (new_pos, service) = bcs_deserialize_offset_ServiceRuntimePrecompile(new_pos, input);\n        }\n        require(choice &lt; 3);\n        return (new_pos, RuntimePrecompile(choice, base, contract_, service));\n    }\n\n    function bcs_deserialize_RuntimePrecompile(bytes memory input)\n        internal\n        pure\n        returns (RuntimePrecompile memory)\n    {\n        uint256 new_pos;\n        RuntimePrecompile memory value;\n        (new_pos, value) = bcs_deserialize_offset_RuntimePrecompile(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct ServiceRuntimePrecompile {\n        uint8 choice;\n        // choice=0 corresponds to TryQueryApplication\n        ServiceRuntimePrecompile_TryQueryApplication try_query_application;\n    }\n\n    function ServiceRuntimePrecompile_case_try_query_application(ServiceRuntimePrecompile_TryQueryApplication memory try_query_application)\n        internal\n        pure\n        returns (ServiceRuntimePrecompile memory)\n    {\n        return ServiceRuntimePrecompile(uint8(0), try_query_application);\n    }\n\n    function bcs_serialize_ServiceRuntimePrecompile(ServiceRuntimePrecompile memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        if (input.choice == 0) {\n            return abi.encodePacked(input.choice, bcs_serialize_ServiceRuntimePrecompile_TryQueryApplication(input.try_query_application));\n        }\n        return abi.encodePacked(input.choice);\n    }\n\n    function bcs_deserialize_offset_ServiceRuntimePrecompile(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, ServiceRuntimePrecompile memory)\n    {\n        uint256 new_pos;\n        uint8 choice;\n        (new_pos, choice) = bcs_deserialize_offset_uint8(pos, input);\n        ServiceRuntimePrecompile_TryQueryApplication memory try_query_application;\n        if (choice == 0) {\n            (new_pos, try_query_application) = bcs_deserialize_offset_ServiceRuntimePrecompile_TryQueryApplication(new_pos, input);\n        }\n        require(choice &lt; 1);\n        return (new_pos, ServiceRuntimePrecompile(choice, try_query_application));\n    }\n\n    function bcs_deserialize_ServiceRuntimePrecompile(bytes memory input)\n        internal\n        pure\n        returns (ServiceRuntimePrecompile memory)\n    {\n        uint256 new_pos;\n        ServiceRuntimePrecompile memory value;\n        (new_pos, value) = bcs_deserialize_offset_ServiceRuntimePrecompile(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct ServiceRuntimePrecompile_TryQueryApplication {\n        ApplicationId target;\n        bytes argument;\n    }\n\n    function bcs_serialize_ServiceRuntimePrecompile_TryQueryApplication(ServiceRuntimePrecompile_TryQueryApplication memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory result = bcs_serialize_ApplicationId(input.target);\n        return abi.encodePacked(result, bcs_serialize_bytes(input.argument));\n    }\n\n    function bcs_deserialize_offset_ServiceRuntimePrecompile_TryQueryApplication(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, ServiceRuntimePrecompile_TryQueryApplication memory)\n    {\n        uint256 new_pos;\n        ApplicationId memory target;\n        (new_pos, target) = bcs_deserialize_offset_ApplicationId(pos, input);\n        bytes memory argument;\n        (new_pos, argument) = bcs_deserialize_offset_bytes(new_pos, input);\n        return (new_pos, ServiceRuntimePrecompile_TryQueryApplication(target, argument));\n    }\n\n    function bcs_deserialize_ServiceRuntimePrecompile_TryQueryApplication(bytes memory input)\n        internal\n        pure\n        returns (ServiceRuntimePrecompile_TryQueryApplication memory)\n    {\n        uint256 new_pos;\n        ServiceRuntimePrecompile_TryQueryApplication memory value;\n        (new_pos, value) = bcs_deserialize_offset_ServiceRuntimePrecompile_TryQueryApplication(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct StreamId {\n        GenericApplicationId application_id;\n        StreamName stream_name;\n    }\n\n    function bcs_serialize_StreamId(StreamId memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory result = bcs_serialize_GenericApplicationId(input.application_id);\n        return abi.encodePacked(result, bcs_serialize_StreamName(input.stream_name));\n    }\n\n    function bcs_deserialize_offset_StreamId(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, StreamId memory)\n    {\n        uint256 new_pos;\n        GenericApplicationId memory application_id;\n        (new_pos, application_id) = bcs_deserialize_offset_GenericApplicationId(pos, input);\n        StreamName memory stream_name;\n        (new_pos, stream_name) = bcs_deserialize_offset_StreamName(new_pos, input);\n        return (new_pos, StreamId(application_id, stream_name));\n    }\n\n    function bcs_deserialize_StreamId(bytes memory input)\n        internal\n        pure\n        returns (StreamId memory)\n    {\n        uint256 new_pos;\n        StreamId memory value;\n        (new_pos, value) = bcs_deserialize_offset_StreamId(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct StreamName {\n        bytes value;\n    }\n\n    function bcs_serialize_StreamName(StreamName memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return bcs_serialize_bytes(input.value);\n    }\n\n    function bcs_deserialize_offset_StreamName(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, StreamName memory)\n    {\n        uint256 new_pos;\n        bytes memory value;\n        (new_pos, value) = bcs_deserialize_offset_bytes(pos, input);\n        return (new_pos, StreamName(value));\n    }\n\n    function bcs_deserialize_StreamName(bytes memory input)\n        internal\n        pure\n        returns (StreamName memory)\n    {\n        uint256 new_pos;\n        StreamName memory value;\n        (new_pos, value) = bcs_deserialize_offset_StreamName(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct StreamUpdate {\n        ChainId chain_id;\n        StreamId stream_id;\n        uint32 previous_index;\n        uint32 next_index;\n    }\n\n    function bcs_serialize_StreamUpdate(StreamUpdate memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory result = bcs_serialize_ChainId(input.chain_id);\n        result = abi.encodePacked(result, bcs_serialize_StreamId(input.stream_id));\n        result = abi.encodePacked(result, bcs_serialize_uint32(input.previous_index));\n        return abi.encodePacked(result, bcs_serialize_uint32(input.next_index));\n    }\n\n    function bcs_deserialize_offset_StreamUpdate(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, StreamUpdate memory)\n    {\n        uint256 new_pos;\n        ChainId memory chain_id;\n        (new_pos, chain_id) = bcs_deserialize_offset_ChainId(pos, input);\n        StreamId memory stream_id;\n        (new_pos, stream_id) = bcs_deserialize_offset_StreamId(new_pos, input);\n        uint32 previous_index;\n        (new_pos, previous_index) = bcs_deserialize_offset_uint32(new_pos, input);\n        uint32 next_index;\n        (new_pos, next_index) = bcs_deserialize_offset_uint32(new_pos, input);\n        return (new_pos, StreamUpdate(chain_id, stream_id, previous_index, next_index));\n    }\n\n    function bcs_deserialize_StreamUpdate(bytes memory input)\n        internal\n        pure\n        returns (StreamUpdate memory)\n    {\n        uint256 new_pos;\n        StreamUpdate memory value;\n        (new_pos, value) = bcs_deserialize_offset_StreamUpdate(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct StreamUpdates {\n        StreamUpdate[] entries;\n    }\n\n    function bcs_serialize_StreamUpdates(StreamUpdates memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return bcs_serialize_seq_StreamUpdate(input.entries);\n    }\n\n    function bcs_deserialize_offset_StreamUpdates(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, StreamUpdates memory)\n    {\n        uint256 new_pos;\n        StreamUpdate[] memory entries;\n        (new_pos, entries) = bcs_deserialize_offset_seq_StreamUpdate(pos, input);\n        return (new_pos, StreamUpdates(entries));\n    }\n\n    function bcs_deserialize_StreamUpdates(bytes memory input)\n        internal\n        pure\n        returns (StreamUpdates memory)\n    {\n        uint256 new_pos;\n        StreamUpdates memory value;\n        (new_pos, value) = bcs_deserialize_offset_StreamUpdates(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct TimeDelta {\n        uint64 value;\n    }\n\n    function bcs_serialize_TimeDelta(TimeDelta memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return bcs_serialize_uint64(input.value);\n    }\n\n    function bcs_deserialize_offset_TimeDelta(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, TimeDelta memory)\n    {\n        uint256 new_pos;\n        uint64 value;\n        (new_pos, value) = bcs_deserialize_offset_uint64(pos, input);\n        return (new_pos, TimeDelta(value));\n    }\n\n    function bcs_deserialize_TimeDelta(bytes memory input)\n        internal\n        pure\n        returns (TimeDelta memory)\n    {\n        uint256 new_pos;\n        TimeDelta memory value;\n        (new_pos, value) = bcs_deserialize_offset_TimeDelta(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct TimeoutConfig {\n        opt_TimeDelta fast_round_duration;\n        TimeDelta base_timeout;\n        TimeDelta timeout_increment;\n        TimeDelta fallback_duration;\n    }\n\n    function bcs_serialize_TimeoutConfig(TimeoutConfig memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory result = bcs_serialize_opt_TimeDelta(input.fast_round_duration);\n        result = abi.encodePacked(result, bcs_serialize_TimeDelta(input.base_timeout));\n        result = abi.encodePacked(result, bcs_serialize_TimeDelta(input.timeout_increment));\n        return abi.encodePacked(result, bcs_serialize_TimeDelta(input.fallback_duration));\n    }\n\n    function bcs_deserialize_offset_TimeoutConfig(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, TimeoutConfig memory)\n    {\n        uint256 new_pos;\n        opt_TimeDelta memory fast_round_duration;\n        (new_pos, fast_round_duration) = bcs_deserialize_offset_opt_TimeDelta(pos, input);\n        TimeDelta memory base_timeout;\n        (new_pos, base_timeout) = bcs_deserialize_offset_TimeDelta(new_pos, input);\n        TimeDelta memory timeout_increment;\n        (new_pos, timeout_increment) = bcs_deserialize_offset_TimeDelta(new_pos, input);\n        TimeDelta memory fallback_duration;\n        (new_pos, fallback_duration) = bcs_deserialize_offset_TimeDelta(new_pos, input);\n        return (new_pos, TimeoutConfig(fast_round_duration, base_timeout, timeout_increment, fallback_duration));\n    }\n\n    function bcs_deserialize_TimeoutConfig(bytes memory input)\n        internal\n        pure\n        returns (TimeoutConfig memory)\n    {\n        uint256 new_pos;\n        TimeoutConfig memory value;\n        (new_pos, value) = bcs_deserialize_offset_TimeoutConfig(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct Timestamp {\n        uint64 value;\n    }\n\n    function bcs_serialize_Timestamp(Timestamp memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return bcs_serialize_uint64(input.value);\n    }\n\n    function bcs_deserialize_offset_Timestamp(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, Timestamp memory)\n    {\n        uint256 new_pos;\n        uint64 value;\n        (new_pos, value) = bcs_deserialize_offset_uint64(pos, input);\n        return (new_pos, Timestamp(value));\n    }\n\n    function bcs_deserialize_Timestamp(bytes memory input)\n        internal\n        pure\n        returns (Timestamp memory)\n    {\n        uint256 new_pos;\n        Timestamp memory value;\n        (new_pos, value) = bcs_deserialize_offset_Timestamp(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    function bcs_serialize_bool(bool input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(input);\n    }\n\n    function bcs_deserialize_offset_bool(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, bool)\n    {\n        uint8 val = uint8(input[pos]);\n        bool result = false;\n        if (val == 1) {\n            result = true;\n        } else {\n            require(val == 0);\n        }\n        return (pos + 1, result);\n    }\n\n    function bcs_deserialize_bool(bytes memory input)\n        internal\n        pure\n        returns (bool)\n    {\n        uint256 new_pos;\n        bool value;\n        (new_pos, value) = bcs_deserialize_offset_bool(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    function bcs_serialize_bytes(bytes memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        uint256 len = input.length;\n        bytes memory result = bcs_serialize_len(len);\n        return abi.encodePacked(result, input);\n    }\n\n    function bcs_deserialize_offset_bytes(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, bytes memory)\n    {\n        uint256 len;\n        uint256 new_pos;\n        (new_pos, len) = bcs_deserialize_offset_len(pos, input);\n        bytes memory result = new bytes(len);\n        for (uint256 u=0; u&lt;len; u++) {\n            result[u] = input[new_pos + u];\n        }\n        return (new_pos + len, result);\n    }\n\n    function bcs_deserialize_bytes(bytes memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        uint256 new_pos;\n        bytes memory value;\n        (new_pos, value) = bcs_deserialize_offset_bytes(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    function bcs_serialize_bytes20(bytes20 input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(input);\n    }\n\n    function bcs_deserialize_offset_bytes20(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, bytes20)\n    {\n        bytes20 dest;\n        assembly {\n            dest := mload(add(add(input, 0x20), pos))\n        }\n        return (pos + 20, dest);\n    }\n\n    function bcs_serialize_bytes32(bytes32 input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(input);\n    }\n\n    function bcs_deserialize_offset_bytes32(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, bytes32)\n    {\n        bytes32 dest;\n        assembly {\n            dest := mload(add(add(input, 0x20), pos))\n        }\n        return (pos + 32, dest);\n    }\n\n    struct key_values_AccountOwner_uint64 {\n        AccountOwner key;\n        uint64 value;\n    }\n\n    function bcs_serialize_key_values_AccountOwner_uint64(key_values_AccountOwner_uint64 memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory result = bcs_serialize_AccountOwner(input.key);\n        return abi.encodePacked(result, bcs_serialize_uint64(input.value));\n    }\n\n    function bcs_deserialize_offset_key_values_AccountOwner_uint64(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, key_values_AccountOwner_uint64 memory)\n    {\n        uint256 new_pos;\n        AccountOwner memory key;\n        (new_pos, key) = bcs_deserialize_offset_AccountOwner(pos, input);\n        uint64 value;\n        (new_pos, value) = bcs_deserialize_offset_uint64(new_pos, input);\n        return (new_pos, key_values_AccountOwner_uint64(key, value));\n    }\n\n    function bcs_deserialize_key_values_AccountOwner_uint64(bytes memory input)\n        internal\n        pure\n        returns (key_values_AccountOwner_uint64 memory)\n    {\n        uint256 new_pos;\n        key_values_AccountOwner_uint64 memory value;\n        (new_pos, value) = bcs_deserialize_offset_key_values_AccountOwner_uint64(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct opt_AccountOwner {\n        bool has_value;\n        AccountOwner value;\n    }\n\n    function bcs_serialize_opt_AccountOwner(opt_AccountOwner memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        if (input.has_value) {\n            return abi.encodePacked(uint8(1), bcs_serialize_AccountOwner(input.value));\n        } else {\n            return abi.encodePacked(uint8(0));\n        }\n    }\n\n    function bcs_deserialize_offset_opt_AccountOwner(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, opt_AccountOwner memory)\n    {\n        uint256 new_pos;\n        bool has_value;\n        (new_pos, has_value) = bcs_deserialize_offset_bool(pos, input);\n        AccountOwner memory value;\n        if (has_value) {\n            (new_pos, value) = bcs_deserialize_offset_AccountOwner(new_pos, input);\n        }\n        return (new_pos, opt_AccountOwner(has_value, value));\n    }\n\n    function bcs_deserialize_opt_AccountOwner(bytes memory input)\n        internal\n        pure\n        returns (opt_AccountOwner memory)\n    {\n        uint256 new_pos;\n        opt_AccountOwner memory value;\n        (new_pos, value) = bcs_deserialize_offset_opt_AccountOwner(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct opt_ApplicationId {\n        bool has_value;\n        ApplicationId value;\n    }\n\n    function bcs_serialize_opt_ApplicationId(opt_ApplicationId memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        if (input.has_value) {\n            return abi.encodePacked(uint8(1), bcs_serialize_ApplicationId(input.value));\n        } else {\n            return abi.encodePacked(uint8(0));\n        }\n    }\n\n    function bcs_deserialize_offset_opt_ApplicationId(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, opt_ApplicationId memory)\n    {\n        uint256 new_pos;\n        bool has_value;\n        (new_pos, has_value) = bcs_deserialize_offset_bool(pos, input);\n        ApplicationId memory value;\n        if (has_value) {\n            (new_pos, value) = bcs_deserialize_offset_ApplicationId(new_pos, input);\n        }\n        return (new_pos, opt_ApplicationId(has_value, value));\n    }\n\n    function bcs_deserialize_opt_ApplicationId(bytes memory input)\n        internal\n        pure\n        returns (opt_ApplicationId memory)\n    {\n        uint256 new_pos;\n        opt_ApplicationId memory value;\n        (new_pos, value) = bcs_deserialize_offset_opt_ApplicationId(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct opt_ChainId {\n        bool has_value;\n        ChainId value;\n    }\n\n    function bcs_serialize_opt_ChainId(opt_ChainId memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        if (input.has_value) {\n            return abi.encodePacked(uint8(1), bcs_serialize_ChainId(input.value));\n        } else {\n            return abi.encodePacked(uint8(0));\n        }\n    }\n\n    function bcs_deserialize_offset_opt_ChainId(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, opt_ChainId memory)\n    {\n        uint256 new_pos;\n        bool has_value;\n        (new_pos, has_value) = bcs_deserialize_offset_bool(pos, input);\n        ChainId memory value;\n        if (has_value) {\n            (new_pos, value) = bcs_deserialize_offset_ChainId(new_pos, input);\n        }\n        return (new_pos, opt_ChainId(has_value, value));\n    }\n\n    function bcs_deserialize_opt_ChainId(bytes memory input)\n        internal\n        pure\n        returns (opt_ChainId memory)\n    {\n        uint256 new_pos;\n        opt_ChainId memory value;\n        (new_pos, value) = bcs_deserialize_offset_opt_ChainId(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct opt_TimeDelta {\n        bool has_value;\n        TimeDelta value;\n    }\n\n    function bcs_serialize_opt_TimeDelta(opt_TimeDelta memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        if (input.has_value) {\n            return abi.encodePacked(uint8(1), bcs_serialize_TimeDelta(input.value));\n        } else {\n            return abi.encodePacked(uint8(0));\n        }\n    }\n\n    function bcs_deserialize_offset_opt_TimeDelta(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, opt_TimeDelta memory)\n    {\n        uint256 new_pos;\n        bool has_value;\n        (new_pos, has_value) = bcs_deserialize_offset_bool(pos, input);\n        TimeDelta memory value;\n        if (has_value) {\n            (new_pos, value) = bcs_deserialize_offset_TimeDelta(new_pos, input);\n        }\n        return (new_pos, opt_TimeDelta(has_value, value));\n    }\n\n    function bcs_deserialize_opt_TimeDelta(bytes memory input)\n        internal\n        pure\n        returns (opt_TimeDelta memory)\n    {\n        uint256 new_pos;\n        opt_TimeDelta memory value;\n        (new_pos, value) = bcs_deserialize_offset_opt_TimeDelta(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    struct opt_uint32 {\n        bool has_value;\n        uint32 value;\n    }\n\n    function bcs_serialize_opt_uint32(opt_uint32 memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        if (input.has_value) {\n            return abi.encodePacked(uint8(1), bcs_serialize_uint32(input.value));\n        } else {\n            return abi.encodePacked(uint8(0));\n        }\n    }\n\n    function bcs_deserialize_offset_opt_uint32(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, opt_uint32 memory)\n    {\n        uint256 new_pos;\n        bool has_value;\n        (new_pos, has_value) = bcs_deserialize_offset_bool(pos, input);\n        uint32 value;\n        if (has_value) {\n            (new_pos, value) = bcs_deserialize_offset_uint32(new_pos, input);\n        }\n        return (new_pos, opt_uint32(has_value, value));\n    }\n\n    function bcs_deserialize_opt_uint32(bytes memory input)\n        internal\n        pure\n        returns (opt_uint32 memory)\n    {\n        uint256 new_pos;\n        opt_uint32 memory value;\n        (new_pos, value) = bcs_deserialize_offset_opt_uint32(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    function bcs_serialize_seq_AccountOwner(AccountOwner[] memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        uint256 len = input.length;\n        bytes memory result = bcs_serialize_len(len);\n        for (uint256 i=0; i&lt;len; i++) {\n            result = abi.encodePacked(result, bcs_serialize_AccountOwner(input[i]));\n        }\n        return result;\n    }\n\n    function bcs_deserialize_offset_seq_AccountOwner(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, AccountOwner[] memory)\n    {\n        uint256 len;\n        uint256 new_pos;\n        (new_pos, len) = bcs_deserialize_offset_len(pos, input);\n        AccountOwner[] memory result;\n        result = new AccountOwner[](len);\n        AccountOwner memory value;\n        for (uint256 i=0; i&lt;len; i++) {\n            (new_pos, value) = bcs_deserialize_offset_AccountOwner(new_pos, input);\n            result[i] = value;\n        }\n        return (new_pos, result);\n    }\n\n    function bcs_deserialize_seq_AccountOwner(bytes memory input)\n        internal\n        pure\n        returns (AccountOwner[] memory)\n    {\n        uint256 new_pos;\n        AccountOwner[] memory value;\n        (new_pos, value) = bcs_deserialize_offset_seq_AccountOwner(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    function bcs_serialize_seq_AccountOwnerBalanceInner(AccountOwnerBalanceInner[] memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        uint256 len = input.length;\n        bytes memory result = bcs_serialize_len(len);\n        for (uint256 i=0; i&lt;len; i++) {\n            result = abi.encodePacked(result, bcs_serialize_AccountOwnerBalanceInner(input[i]));\n        }\n        return result;\n    }\n\n    function bcs_deserialize_offset_seq_AccountOwnerBalanceInner(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, AccountOwnerBalanceInner[] memory)\n    {\n        uint256 len;\n        uint256 new_pos;\n        (new_pos, len) = bcs_deserialize_offset_len(pos, input);\n        AccountOwnerBalanceInner[] memory result;\n        result = new AccountOwnerBalanceInner[](len);\n        AccountOwnerBalanceInner memory value;\n        for (uint256 i=0; i&lt;len; i++) {\n            (new_pos, value) = bcs_deserialize_offset_AccountOwnerBalanceInner(new_pos, input);\n            result[i] = value;\n        }\n        return (new_pos, result);\n    }\n\n    function bcs_deserialize_seq_AccountOwnerBalanceInner(bytes memory input)\n        internal\n        pure\n        returns (AccountOwnerBalanceInner[] memory)\n    {\n        uint256 new_pos;\n        AccountOwnerBalanceInner[] memory value;\n        (new_pos, value) = bcs_deserialize_offset_seq_AccountOwnerBalanceInner(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    function bcs_serialize_seq_StreamUpdate(StreamUpdate[] memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        uint256 len = input.length;\n        bytes memory result = bcs_serialize_len(len);\n        for (uint256 i=0; i&lt;len; i++) {\n            result = abi.encodePacked(result, bcs_serialize_StreamUpdate(input[i]));\n        }\n        return result;\n    }\n\n    function bcs_deserialize_offset_seq_StreamUpdate(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, StreamUpdate[] memory)\n    {\n        uint256 len;\n        uint256 new_pos;\n        (new_pos, len) = bcs_deserialize_offset_len(pos, input);\n        StreamUpdate[] memory result;\n        result = new StreamUpdate[](len);\n        StreamUpdate memory value;\n        for (uint256 i=0; i&lt;len; i++) {\n            (new_pos, value) = bcs_deserialize_offset_StreamUpdate(new_pos, input);\n            result[i] = value;\n        }\n        return (new_pos, result);\n    }\n\n    function bcs_deserialize_seq_StreamUpdate(bytes memory input)\n        internal\n        pure\n        returns (StreamUpdate[] memory)\n    {\n        uint256 new_pos;\n        StreamUpdate[] memory value;\n        (new_pos, value) = bcs_deserialize_offset_seq_StreamUpdate(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    function bcs_serialize_seq_key_values_AccountOwner_uint64(key_values_AccountOwner_uint64[] memory input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        uint256 len = input.length;\n        bytes memory result = bcs_serialize_len(len);\n        for (uint256 i=0; i&lt;len; i++) {\n            result = abi.encodePacked(result, bcs_serialize_key_values_AccountOwner_uint64(input[i]));\n        }\n        return result;\n    }\n\n    function bcs_deserialize_offset_seq_key_values_AccountOwner_uint64(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, key_values_AccountOwner_uint64[] memory)\n    {\n        uint256 len;\n        uint256 new_pos;\n        (new_pos, len) = bcs_deserialize_offset_len(pos, input);\n        key_values_AccountOwner_uint64[] memory result;\n        result = new key_values_AccountOwner_uint64[](len);\n        key_values_AccountOwner_uint64 memory value;\n        for (uint256 i=0; i&lt;len; i++) {\n            (new_pos, value) = bcs_deserialize_offset_key_values_AccountOwner_uint64(new_pos, input);\n            result[i] = value;\n        }\n        return (new_pos, result);\n    }\n\n    function bcs_deserialize_seq_key_values_AccountOwner_uint64(bytes memory input)\n        internal\n        pure\n        returns (key_values_AccountOwner_uint64[] memory)\n    {\n        uint256 new_pos;\n        key_values_AccountOwner_uint64[] memory value;\n        (new_pos, value) = bcs_deserialize_offset_seq_key_values_AccountOwner_uint64(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    function bcs_serialize_uint32(uint32 input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory result = new bytes(4);\n        uint32 value = input;\n        result[0] = bytes1(uint8(value));\n        for (uint i=1; i&lt;4; i++) {\n            value = value &gt;&gt; 8;\n            result[i] = bytes1(uint8(value));\n        }\n        return result;\n    }\n\n    function bcs_deserialize_offset_uint32(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, uint32)\n    {\n        uint32 value = uint8(input[pos + 3]);\n        for (uint256 i=0; i&lt;3; i++) {\n            value = value &lt;&lt; 8;\n            value += uint8(input[pos + 2 - i]);\n        }\n        return (pos + 4, value);\n    }\n\n    function bcs_deserialize_uint32(bytes memory input)\n        internal\n        pure\n        returns (uint32)\n    {\n        uint256 new_pos;\n        uint32 value;\n        (new_pos, value) = bcs_deserialize_offset_uint32(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    function bcs_serialize_uint64(uint64 input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory result = new bytes(8);\n        uint64 value = input;\n        result[0] = bytes1(uint8(value));\n        for (uint i=1; i&lt;8; i++) {\n            value = value &gt;&gt; 8;\n            result[i] = bytes1(uint8(value));\n        }\n        return result;\n    }\n\n    function bcs_deserialize_offset_uint64(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, uint64)\n    {\n        uint64 value = uint8(input[pos + 7]);\n        for (uint256 i=0; i&lt;7; i++) {\n            value = value &lt;&lt; 8;\n            value += uint8(input[pos + 6 - i]);\n        }\n        return (pos + 8, value);\n    }\n\n    function bcs_deserialize_uint64(bytes memory input)\n        internal\n        pure\n        returns (uint64)\n    {\n        uint256 new_pos;\n        uint64 value;\n        (new_pos, value) = bcs_deserialize_offset_uint64(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n    function bcs_serialize_uint8(uint8 input)\n        internal\n        pure\n        returns (bytes memory)\n    {\n      return abi.encodePacked(input);\n    }\n\n    function bcs_deserialize_offset_uint8(uint256 pos, bytes memory input)\n        internal\n        pure\n        returns (uint256, uint8)\n    {\n        uint8 value = uint8(input[pos]);\n        return (pos + 1, value);\n    }\n\n    function bcs_deserialize_uint8(bytes memory input)\n        internal\n        pure\n        returns (uint8)\n    {\n        uint256 new_pos;\n        uint8 value;\n        (new_pos, value) = bcs_deserialize_offset_uint8(0, input);\n        require(new_pos == input.length, \&quot;incomplete deserialization\&quot;);\n        return value;\n    }\n\n} // end of library LineraTypes\n&quot;;</code></pre></section></div></main></body></html>
<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The `Linera.sol` library code to be included in solidity smart contracts using Linera features."><title>LINERA_SOL in linera_execution - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-6c3ea77c.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="linera_execution" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0 (05f9846f8 2025-03-31)" data-channel="1.86.0" data-search-js="search-581efc7a.js" data-settings-js="settings-6dad6058.js" ><script src="../static.files/storage-3a5871a4.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-4d63596a.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc constant"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../linera_execution/index.html">linera_<wbr>execution</a><span class="version">0.16.0</span></h2></div><div class="sidebar-elems"><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="index.html">linera_execution</a></div><h1>Constant <span class="constant">LINERA_SOL</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/linera_execution/lib.rs.html#82">Source</a> </span></div><pre class="rust item-decl"><code>pub const LINERA_SOL: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.86.0/std/primitive.str.html">str</a> = &quot;// Copyright (c) Zefchain Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \&quot;./LineraTypes.sol\&quot;;\n\n// The \&quot;LineraTypes.sol\&quot; is created via the command\n// cargo run -p serde-generate-bin -- --language solidity LineraTypes.yaml &gt; LineraTypes.sol\n// from the package \&quot;serde-reflection\&quot; commit 95e57c4c2df2fc7215e627da353071a2cb91fdcb\n\n// This library provides Linera functionalities to EVM contracts\n// It should not be modified.\n\nlibrary Linera {\n\n    // Exported types\n\n    struct ChainId {\n        bytes32 value;\n    }\n\n    function chainid_from(LineraTypes.ChainId memory entry)\n        internal\n        pure\n        returns (ChainId memory)\n    {\n        return ChainId(entry.value.value);\n    }\n\n    struct AccountOwner {\n        uint8 choice;\n        // choice=0 corresponds to Reserved\n        uint8 reserved;\n        // choice=1 corresponds to Address32\n        bytes32 address32;\n        // choice=2 corresponds to Address20\n        bytes20 address20;\n    }\n\n    function accountowner_from(LineraTypes.AccountOwner memory owner)\n        internal\n        pure\n        returns (AccountOwner memory)\n    {\n        return AccountOwner(owner.choice, owner.reserved, owner.address32.value, owner.address20);\n    }\n\n    function accountowner_to(Linera.AccountOwner memory owner)\n        internal\n        pure\n        returns (LineraTypes.AccountOwner memory)\n    {\n        LineraTypes.CryptoHash memory hash = LineraTypes.CryptoHash(owner.address32);\n        return LineraTypes.AccountOwner(owner.choice, owner.reserved, hash, owner.address20);\n    }\n\n    struct AccountOwnerBalance {\n        AccountOwner account_owner;\n        uint256 balance;\n    }\n\n    function accountownerbalance_from(LineraTypes.AccountOwnerBalanceInner memory entry)\n        internal\n        pure\n        returns (AccountOwnerBalance memory)\n    {\n        uint256 balance = uint256(entry.balance_.value);\n        AccountOwner memory account_owner = accountowner_from(entry.account_owner);\n        return AccountOwnerBalance(account_owner, balance);\n    }\n\n    struct TimeDelta {\n        uint64 value;\n    }\n\n    function timedelta_from(LineraTypes.TimeDelta memory entry)\n        internal\n        pure\n        returns (TimeDelta memory)\n    {\n        return TimeDelta(entry.value);\n    }\n\n    struct opt_TimeDelta {\n        bool has_value;\n        uint64 value;\n    }\n\n    function opt_timedelta_from(LineraTypes.opt_TimeDelta memory entry)\n        internal\n        pure\n        returns (opt_TimeDelta memory)\n    {\n        return opt_TimeDelta(entry.has_value, entry.value.value);\n    }\n\n    struct TimeoutConfig {\n        opt_TimeDelta fast_round_duration;\n        TimeDelta base_timeout;\n        TimeDelta timeout_increment;\n        TimeDelta fallback_duration;\n    }\n\n    function timeoutconfig_from(LineraTypes.TimeoutConfig memory entry)\n        internal\n        pure\n        returns (TimeoutConfig memory)\n    {\n        return TimeoutConfig(opt_timedelta_from(entry.fast_round_duration),\n                             timedelta_from(entry.base_timeout),\n                             timedelta_from(entry.timeout_increment),\n                             timedelta_from(entry.fallback_duration));\n    }\n\n    struct AccountOwnerWeight {\n        Linera.AccountOwner account_owner;\n        uint64 weight;\n    }\n\n    function accountownerweight_from(LineraTypes.key_values_AccountOwner_uint64 memory entry)\n        internal\n        pure\n        returns (AccountOwnerWeight memory)\n    {\n        return AccountOwnerWeight(accountowner_from(entry.key), entry.value);\n    }\n\n    struct ChainOwnership {\n        AccountOwner[] super_owners;\n        AccountOwnerWeight[] owners;\n        uint32 multi_leader_rounds;\n        bool open_multi_leader_rounds;\n        TimeoutConfig timeout_config;\n    }\n\n    function chainownership_from(LineraTypes.ChainOwnership memory entry)\n        internal\n        pure\n        returns (ChainOwnership memory)\n    {\n        uint256 len1 = entry.super_owners.length;\n        AccountOwner[] memory super_owners;\n        super_owners = new AccountOwner[](len1);\n        for (uint256 i=0; i&lt;len1; i++) {\n            super_owners[i] = accountowner_from(entry.super_owners[i]);\n        }\n        uint256 len2 = entry.owners.length;\n        AccountOwnerWeight[] memory owners;\n        owners = new AccountOwnerWeight[](len2);\n        for (uint256 i=0; i&lt;len2; i++) {\n            owners[i] = accountownerweight_from(entry.owners[i]);\n        }\n        return ChainOwnership(super_owners, owners, entry.multi_leader_rounds, entry.open_multi_leader_rounds, timeoutconfig_from(entry.timeout_config));\n    }\n\n    struct opt_uint32 {\n        bool has_value;\n        uint32 value;\n    }\n\n    function opt_uint32_from(LineraTypes.opt_uint32 memory entry)\n        internal\n        pure\n        returns (opt_uint32 memory)\n    {\n        return opt_uint32(entry.has_value, entry.value);\n    }\n\n    struct ApplicationId {\n        bytes32 application_description_hash;\n    }\n\n    function applicationid_from(LineraTypes.ApplicationId memory entry)\n        internal\n        pure\n        returns (ApplicationId memory)\n    {\n        return ApplicationId(entry.application_description_hash.value);\n    }\n\n    struct opt_ApplicationId {\n        bool has_value;\n        ApplicationId value;\n    }\n\n    function opt_applicationid_from(LineraTypes.opt_ApplicationId memory entry)\n        internal\n        pure\n        returns (opt_ApplicationId memory)\n    {\n        return opt_ApplicationId(entry.has_value, applicationid_from(entry.value));\n    }\n\n    struct opt_AccountOwner {\n        bool has_value;\n        AccountOwner value;\n    }\n\n    struct opt_ChainId {\n        bool has_value;\n        ChainId value;\n    }\n\n    function opt_accountowner_from(LineraTypes.opt_AccountOwner memory entry)\n        internal\n        pure\n        returns (opt_AccountOwner memory)\n    {\n        return opt_AccountOwner(entry.has_value, accountowner_from(entry.value));\n    }\n\n    function opt_chainid_from(LineraTypes.opt_ChainId memory entry)\n        internal\n        pure\n        returns (opt_ChainId memory)\n    {\n        return opt_ChainId(entry.has_value, chainid_from(entry.value));\n    }\n\n    function opt_chainid_none()\n        internal\n        pure\n        returns (opt_ChainId memory)\n    {\n        return opt_ChainId(false, ChainId(bytes32(0)));\n    }\n\n    enum OptionBool { None, True, False }\n\n    function optionbool_from(LineraTypes.MessageIsBouncing memory entry)\n        internal\n        pure\n        returns (OptionBool)\n    {\n        if (entry.value == LineraTypes.OptionBool.True) {\n            return OptionBool.True;\n        }\n        if (entry.value == LineraTypes.OptionBool.False) {\n            return OptionBool.False;\n        }\n        return OptionBool.None;\n    }\n\n\n\n    struct StreamUpdate {\n        ChainId chain_id;\n        StreamId stream_id;\n        uint32 previous_index;\n        uint32 next_index;\n    }\n\n    struct StreamId {\n        GenericApplicationId application_id;\n        StreamName stream_name;\n    }\n\n    struct StreamName {\n        bytes value;\n    }\n\n    struct GenericApplicationId {\n        uint8 choice;\n        // choice=0 corresponds to System\n        // choice=1 corresponds to User\n        ApplicationId user;\n    }\n\n    // BaseRuntime functions\n\n    function chain_id() internal returns (Linera.ChainId memory) {\n        address precompile = address(0x0b);\n        LineraTypes.BaseRuntimePrecompile memory base = LineraTypes.BaseRuntimePrecompile_case_chain_id();\n        LineraTypes.RuntimePrecompile memory input1 = LineraTypes.RuntimePrecompile_case_base(base);\n        bytes memory input2 = LineraTypes.bcs_serialize_RuntimePrecompile(input1);\n        (bool success, bytes memory output1) = precompile.call(input2);\n        require(success);\n        LineraTypes.ChainId memory output2 = LineraTypes.bcs_deserialize_ChainId(output1);\n        return chainid_from(output2);\n    }\n\n    function block_height() internal returns (uint64) {\n        address precompile = address(0x0b);\n        LineraTypes.BaseRuntimePrecompile memory base = LineraTypes.BaseRuntimePrecompile_case_block_height();\n        LineraTypes.RuntimePrecompile memory input1 = LineraTypes.RuntimePrecompile_case_base(base);\n        bytes memory input2 = LineraTypes.bcs_serialize_RuntimePrecompile(input1);\n        (bool success, bytes memory output) = precompile.call(input2);\n        require(success);\n        LineraTypes.BlockHeight memory output2 = LineraTypes.bcs_deserialize_BlockHeight(output);\n        return output2.value;\n    }\n\n    function application_creator_chain_id() internal returns (ChainId memory) {\n        address precompile = address(0x0b);\n        LineraTypes.BaseRuntimePrecompile memory base = LineraTypes.BaseRuntimePrecompile_case_application_creator_chain_id();\n        LineraTypes.RuntimePrecompile memory input1 = LineraTypes.RuntimePrecompile_case_base(base);\n        bytes memory input2 = LineraTypes.bcs_serialize_RuntimePrecompile(input1);\n        (bool success, bytes memory output1) = precompile.call(input2);\n        require(success);\n        LineraTypes.ChainId memory output2 = LineraTypes.bcs_deserialize_ChainId(output1);\n        return ChainId(output2.value.value);\n    }\n\n    function read_system_timestamp() internal returns (uint64) {\n        address precompile = address(0x0b);\n        LineraTypes.BaseRuntimePrecompile memory base = LineraTypes.BaseRuntimePrecompile_case_read_system_timestamp();\n        LineraTypes.RuntimePrecompile memory input1 = LineraTypes.RuntimePrecompile_case_base(base);\n        bytes memory input2 = LineraTypes.bcs_serialize_RuntimePrecompile(input1);\n        (bool success, bytes memory output) = precompile.call(input2);\n        require(success);\n        LineraTypes.Timestamp memory output2 = LineraTypes.bcs_deserialize_Timestamp(output);\n        return output2.value;\n    }\n\n    function read_chain_balance() internal returns (uint256) {\n        address precompile = address(0x0b);\n        LineraTypes.BaseRuntimePrecompile memory base = LineraTypes.BaseRuntimePrecompile_case_read_chain_balance();\n        LineraTypes.RuntimePrecompile memory input1 = LineraTypes.RuntimePrecompile_case_base(base);\n        bytes memory input2 = LineraTypes.bcs_serialize_RuntimePrecompile(input1);\n        (bool success, bytes memory output) = precompile.call(input2);\n        require(success);\n        LineraTypes.Amount memory output2 = LineraTypes.bcs_deserialize_Amount(output);\n        return uint256(output2.value);\n    }\n\n    function read_owner_balance(Linera.AccountOwner memory owner) internal returns (uint256) {\n        address precompile = address(0x0b);\n        LineraTypes.AccountOwner memory owner2 = accountowner_to(owner);\n        LineraTypes.BaseRuntimePrecompile memory base = LineraTypes.BaseRuntimePrecompile_case_read_owner_balance(owner2);\n        LineraTypes.RuntimePrecompile memory input1 = LineraTypes.RuntimePrecompile_case_base(base);\n        bytes memory input2 = LineraTypes.bcs_serialize_RuntimePrecompile(input1);\n        (bool success, bytes memory output) = precompile.call(input2);\n        require(success);\n        LineraTypes.Amount memory output2 = LineraTypes.bcs_deserialize_Amount(output);\n        return uint256(output2.value);\n    }\n\n    function read_owner_balances() internal returns (Linera.AccountOwnerBalance[] memory) {\n        address precompile = address(0x0b);\n        LineraTypes.BaseRuntimePrecompile memory base = LineraTypes.BaseRuntimePrecompile_case_read_owner_balances();\n        LineraTypes.RuntimePrecompile memory input1 = LineraTypes.RuntimePrecompile_case_base(base);\n        bytes memory input2 = LineraTypes.bcs_serialize_RuntimePrecompile(input1);\n        (bool success, bytes memory output) = precompile.call(input2);\n        require(success);\n        LineraTypes.ResponseReadOwnerBalances memory output2 = LineraTypes.bcs_deserialize_ResponseReadOwnerBalances(output);\n        uint256 len = output2.value.length;\n        Linera.AccountOwnerBalance[] memory elist;\n        elist = new Linera.AccountOwnerBalance[](len);\n        for (uint256 i=0; i&lt;len; i++) {\n            elist[i] = accountownerbalance_from(output2.value[i]);\n        }\n        return elist;\n    }\n\n    function read_balance_owners() internal returns (Linera.AccountOwner[] memory result) {\n        address precompile = address(0x0b);\n        LineraTypes.BaseRuntimePrecompile memory base = LineraTypes.BaseRuntimePrecompile_case_read_balance_owners();\n        LineraTypes.RuntimePrecompile memory input1 = LineraTypes.RuntimePrecompile_case_base(base);\n        bytes memory input2 = LineraTypes.bcs_serialize_RuntimePrecompile(input1);\n        (bool success, bytes memory output1) = precompile.call(input2);\n        require(success);\n        LineraTypes.ResponseReadBalanceOwners memory output2 = LineraTypes.bcs_deserialize_ResponseReadBalanceOwners(output1);\n        uint256 len = output2.value.length;\n        Linera.AccountOwner[] memory elist;\n        elist = new Linera.AccountOwner[](len);\n        for (uint256 i=0; i&lt;len; i++) {\n            elist[i] = accountowner_from(output2.value[i]);\n        }\n        return elist;\n    }\n\n    function chain_ownership() internal returns (Linera.ChainOwnership memory) {\n        address precompile = address(0x0b);\n        LineraTypes.BaseRuntimePrecompile memory base = LineraTypes.BaseRuntimePrecompile_case_chain_ownership();\n        LineraTypes.RuntimePrecompile memory input1 = LineraTypes.RuntimePrecompile_case_base(base);\n        bytes memory input2 = LineraTypes.bcs_serialize_RuntimePrecompile(input1);\n        (bool success, bytes memory output1) = precompile.call(input2);\n        require(success);\n        LineraTypes.ChainOwnership memory output2 = LineraTypes.bcs_deserialize_ChainOwnership(output1);\n        return chainownership_from(output2);\n    }\n\n    function read_data_blob(bytes32 hash) internal returns (bytes memory) {\n        address precompile = address(0x0b);\n        LineraTypes.CryptoHash memory hash2 = LineraTypes.CryptoHash(hash);\n        LineraTypes.DataBlobHash memory hash3 = LineraTypes.DataBlobHash(hash2);\n        LineraTypes.BaseRuntimePrecompile memory base = LineraTypes.BaseRuntimePrecompile_case_read_data_blob(hash3);\n        LineraTypes.RuntimePrecompile memory input1 = LineraTypes.RuntimePrecompile_case_base(base);\n        bytes memory input2 = LineraTypes.bcs_serialize_RuntimePrecompile(input1);\n        (bool success, bytes memory output) = precompile.call(input2);\n        require(success);\n        return output;\n    }\n\n    function assert_data_blob_exists(bytes32 hash) internal {\n        address precompile = address(0x0b);\n        LineraTypes.CryptoHash memory hash2 = LineraTypes.CryptoHash(hash);\n        LineraTypes.DataBlobHash memory hash3 = LineraTypes.DataBlobHash(hash2);\n        LineraTypes.BaseRuntimePrecompile memory base = LineraTypes.BaseRuntimePrecompile_case_assert_data_blob_exists(hash3);\n        LineraTypes.RuntimePrecompile memory input1 = LineraTypes.RuntimePrecompile_case_base(base);\n        bytes memory input2 = LineraTypes.bcs_serialize_RuntimePrecompile(input1);\n        (bool success, bytes memory output) = precompile.call(input2);\n        require(success);\n        assert(output.length == 0);\n    }\n\n    // ContractRuntime functions\n\n    function authenticated_owner() internal returns (Linera.opt_AccountOwner memory) {\n        address precompile = address(0x0b);\n        LineraTypes.ContractRuntimePrecompile memory contract_ = LineraTypes.ContractRuntimePrecompile_case_authenticated_owner();\n        LineraTypes.RuntimePrecompile memory input1 = LineraTypes.RuntimePrecompile_case_contract(contract_);\n        bytes memory input2 = LineraTypes.bcs_serialize_RuntimePrecompile(input1);\n        (bool success, bytes memory output1) = precompile.call(input2);\n        require(success);\n        LineraTypes.opt_AccountOwner memory output2 = LineraTypes.bcs_deserialize_opt_AccountOwner(output1);\n        return opt_accountowner_from(output2);\n    }\n\n    function message_origin_chain_id() internal returns (opt_ChainId memory) {\n        address precompile = address(0x0b);\n        LineraTypes.ContractRuntimePrecompile memory contract_ = LineraTypes.ContractRuntimePrecompile_case_message_origin_chain_id();\n        LineraTypes.RuntimePrecompile memory input1 = LineraTypes.RuntimePrecompile_case_contract(contract_);\n        bytes memory input2 = LineraTypes.bcs_serialize_RuntimePrecompile(input1);\n        (bool success, bytes memory output1) = precompile.call(input2);\n        require(success);\n        LineraTypes.opt_ChainId memory output2 = LineraTypes.bcs_deserialize_opt_ChainId(output1);\n        return opt_chainid_from(output2);\n    }\n\n    function message_is_bouncing() internal returns (OptionBool) {\n        address precompile = address(0x0b);\n        LineraTypes.ContractRuntimePrecompile memory contract_ = LineraTypes.ContractRuntimePrecompile_case_message_is_bouncing();\n        LineraTypes.RuntimePrecompile memory input1 = LineraTypes.RuntimePrecompile_case_contract(contract_);\n        bytes memory input2 = LineraTypes.bcs_serialize_RuntimePrecompile(input1);\n        (bool success, bytes memory output1) = precompile.call(input2);\n        require(success);\n        LineraTypes.MessageIsBouncing memory output2 = LineraTypes.bcs_deserialize_MessageIsBouncing(output1);\n        return optionbool_from(output2);\n    }\n\n    function authenticated_caller_id() internal returns (Linera.opt_ApplicationId memory) {\n        address precompile = address(0x0b);\n        LineraTypes.ContractRuntimePrecompile memory contract_ = LineraTypes.ContractRuntimePrecompile_case_authenticated_caller_id();\n        LineraTypes.RuntimePrecompile memory input1 = LineraTypes.RuntimePrecompile_case_contract(contract_);\n        bytes memory input2 = LineraTypes.bcs_serialize_RuntimePrecompile(input1);\n        (bool success, bytes memory output1) = precompile.call(input2);\n        require(success);\n        LineraTypes.opt_ApplicationId memory output2 = LineraTypes.bcs_deserialize_opt_ApplicationId(output1);\n        return opt_applicationid_from(output2);\n    }\n\n    function send_message(bytes32 chain_id1, bytes memory message) internal {\n        address precompile = address(0x0b);\n        LineraTypes.ChainId memory chain_id2 = LineraTypes.ChainId(LineraTypes.CryptoHash(chain_id1));\n        LineraTypes.ContractRuntimePrecompile_TryCallApplication memory try_call_application_;\n        LineraTypes.ContractRuntimePrecompile_SendMessage memory send_message_ = LineraTypes.ContractRuntimePrecompile_SendMessage(chain_id2, message);\n        LineraTypes.ContractRuntimePrecompile memory contract_ = LineraTypes.ContractRuntimePrecompile_case_send_message(send_message_);\n        LineraTypes.RuntimePrecompile memory input1 = LineraTypes.RuntimePrecompile_case_contract(contract_);\n        bytes memory input2 = LineraTypes.bcs_serialize_RuntimePrecompile(input1);\n        (bool success, bytes memory output) = precompile.call(input2);\n        require(success);\n        require(output.length == 0);\n    }\n\n    function try_call_application(bytes32 universal_address, bytes memory operation) internal returns (bytes memory) {\n        address precompile = address(0x0b);\n        LineraTypes.ApplicationId memory target = LineraTypes.ApplicationId(LineraTypes.CryptoHash(universal_address));\n        LineraTypes.ContractRuntimePrecompile_TryCallApplication memory try_call_application_ = LineraTypes.ContractRuntimePrecompile_TryCallApplication(target, operation);\n        LineraTypes.ContractRuntimePrecompile memory contract_ = LineraTypes.ContractRuntimePrecompile_case_try_call_application(try_call_application_);\n        LineraTypes.RuntimePrecompile memory input1 = LineraTypes.RuntimePrecompile_case_contract(contract_);\n        bytes memory input2 = LineraTypes.bcs_serialize_RuntimePrecompile(input1);\n        (bool success, bytes memory output) = precompile.call(input2);\n        require(success);\n        return output;\n    }\n\n    function linera_emit(bytes memory stream_name, bytes memory value) internal returns (uint32) {\n        address precompile = address(0x0b);\n        LineraTypes.StreamName memory stream_name2 = LineraTypes.StreamName(stream_name);\n        LineraTypes.ContractRuntimePrecompile_Emit memory emit_ = LineraTypes.ContractRuntimePrecompile_Emit(stream_name2, value);\n        LineraTypes.ContractRuntimePrecompile memory contract_ = LineraTypes.ContractRuntimePrecompile_case_emit(emit_);\n        LineraTypes.RuntimePrecompile memory input1 = LineraTypes.RuntimePrecompile_case_contract(contract_);\n        bytes memory input2 = LineraTypes.bcs_serialize_RuntimePrecompile(input1);\n        (bool success, bytes memory output) = precompile.call(input2);\n        require(success);\n        return LineraTypes.bcs_deserialize_uint32(output);\n    }\n\n    function read_event(bytes32 chain_id1, bytes memory stream_name, uint32 index) internal returns (bytes memory) {\n        address precompile = address(0x0b);\n        LineraTypes.ChainId memory chain_id2 = LineraTypes.ChainId(LineraTypes.CryptoHash(chain_id1));\n        LineraTypes.StreamName memory stream_name2 = LineraTypes.StreamName(stream_name);\n        LineraTypes.ContractRuntimePrecompile_ReadEvent memory read_event_ = LineraTypes.ContractRuntimePrecompile_ReadEvent(chain_id2, stream_name2, index);\n        LineraTypes.ContractRuntimePrecompile memory contract_ = LineraTypes.ContractRuntimePrecompile_case_read_event(read_event_);\n        LineraTypes.RuntimePrecompile memory input1 = LineraTypes.RuntimePrecompile_case_contract(contract_);\n        bytes memory input2 = LineraTypes.bcs_serialize_RuntimePrecompile(input1);\n        (bool success, bytes memory output) = precompile.call(input2);\n        require(success);\n        return output;\n    }\n\n    function subscribe_to_events(bytes32 chain_id1, bytes32 subscribed_application_id, bytes memory stream_name) internal {\n        address precompile = address(0x0b);\n        LineraTypes.ChainId memory chain_id2 = LineraTypes.ChainId(LineraTypes.CryptoHash(chain_id1));\n        LineraTypes.ApplicationId memory application_id2 = LineraTypes.ApplicationId(LineraTypes.CryptoHash(subscribed_application_id));\n        LineraTypes.StreamName memory stream_name2 = LineraTypes.StreamName(stream_name);\n        LineraTypes.ContractRuntimePrecompile_SubscribeToEvents memory subscribe_to_events_ = LineraTypes.ContractRuntimePrecompile_SubscribeToEvents(chain_id2, application_id2, stream_name2);\n        LineraTypes.ContractRuntimePrecompile memory contract_ = LineraTypes.ContractRuntimePrecompile_case_subscribe_to_events(subscribe_to_events_);\n        LineraTypes.RuntimePrecompile memory input1 = LineraTypes.RuntimePrecompile_case_contract(contract_);\n        bytes memory input2 = LineraTypes.bcs_serialize_RuntimePrecompile(input1);\n        (bool success, bytes memory output) = precompile.call(input2);\n        require(success);\n        require(output.length == 0);\n    }\n\n    function unsubscribe_from_events(bytes32 chain_id1, bytes32 unsubscribe_application_id, bytes memory stream_name) internal {\n        address precompile = address(0x0b);\n        LineraTypes.ChainId memory chain_id2 = LineraTypes.ChainId(LineraTypes.CryptoHash(chain_id1));\n        LineraTypes.ApplicationId memory application_id2 = LineraTypes.ApplicationId(LineraTypes.CryptoHash(unsubscribe_application_id));\n        LineraTypes.StreamName memory stream_name2 = LineraTypes.StreamName(stream_name);\n        LineraTypes.ContractRuntimePrecompile_UnsubscribeFromEvents memory unsubscribe_from_events_ = LineraTypes.ContractRuntimePrecompile_UnsubscribeFromEvents(chain_id2, application_id2, stream_name2);\n        LineraTypes.ContractRuntimePrecompile memory contract_ = LineraTypes.ContractRuntimePrecompile_case_unsubscribe_from_events(unsubscribe_from_events_);\n        LineraTypes.RuntimePrecompile memory input1 = LineraTypes.RuntimePrecompile_case_contract(contract_);\n        bytes memory input2 = LineraTypes.bcs_serialize_RuntimePrecompile(input1);\n        (bool success, bytes memory output) = precompile.call(input2);\n        require(success);\n        require(output.length == 0);\n    }\n\n    function query_service(bytes32 universal_address, bytes memory query) internal returns (bytes memory) {\n        address precompile = address(0x0b);\n        LineraTypes.ApplicationId memory target = LineraTypes.ApplicationId(LineraTypes.CryptoHash(universal_address));\n        LineraTypes.ContractRuntimePrecompile_QueryService memory query_service_ = LineraTypes.ContractRuntimePrecompile_QueryService(target, query);\n        LineraTypes.ContractRuntimePrecompile memory contract_ = LineraTypes.ContractRuntimePrecompile_case_query_service(query_service_);\n        LineraTypes.RuntimePrecompile memory input1 = LineraTypes.RuntimePrecompile_case_contract(contract_);\n        bytes memory input2 = LineraTypes.bcs_serialize_RuntimePrecompile(input1);\n        (bool success, bytes memory output) = precompile.call(input2);\n        require(success);\n        return output;\n    }\n\n    function validation_round() internal returns (Linera.opt_uint32 memory) {\n        address precompile = address(0x0b);\n        LineraTypes.ContractRuntimePrecompile memory contract_ = LineraTypes.ContractRuntimePrecompile_case_validation_round();\n        LineraTypes.RuntimePrecompile memory input1 = LineraTypes.RuntimePrecompile_case_contract(contract_);\n        bytes memory input2 = LineraTypes.bcs_serialize_RuntimePrecompile(input1);\n        (bool success, bytes memory output) = precompile.call(input2);\n        require(success);\n        LineraTypes.opt_uint32 memory output2 = LineraTypes.bcs_deserialize_opt_uint32(output);\n        return opt_uint32_from(output2);\n    }\n\n    // ServiceRuntime functions.\n\n    function try_query_application(bytes32 universal_address, bytes memory argument) internal returns (bytes memory) {\n        address precompile = address(0x0b);\n        LineraTypes.ApplicationId memory target = LineraTypes.ApplicationId(LineraTypes.CryptoHash(universal_address));\n        LineraTypes.ServiceRuntimePrecompile_TryQueryApplication memory try_query_application_ = LineraTypes.ServiceRuntimePrecompile_TryQueryApplication(target, argument);\n        LineraTypes.ServiceRuntimePrecompile memory service = LineraTypes.ServiceRuntimePrecompile_case_try_query_application(try_query_application_);\n        LineraTypes.RuntimePrecompile memory input1 = LineraTypes.RuntimePrecompile_case_service(service);\n        bytes memory input2 = LineraTypes.bcs_serialize_RuntimePrecompile(input1);\n        (bool success, bytes memory output) = precompile.call(input2);\n        require(success);\n        return output;\n    }\n}\n&quot;;</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>The <code>Linera.sol</code> library code to be included in solidity smart
contracts using Linera features.</p>
</div></details></section></div></main></body></html>
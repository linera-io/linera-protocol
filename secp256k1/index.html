<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Rust bindings for Pieter Wuille’s secp256k1 library, which is used for fast and accurate manipulation of ECDSA and Schnorr signatures on the secp256k1 curve. Such signatures are used extensively by the Bitcoin network and its derivatives."><title>secp256k1 - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-6c3ea77c.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="secp256k1" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0 (05f9846f8 2025-03-31)" data-channel="1.86.0" data-search-js="search-581efc7a.js" data-settings-js="settings-6dad6058.js" ><script src="../static.files/storage-3a5871a4.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-4d63596a.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../secp256k1/index.html">secp256k1</a><span class="version">0.30.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#crate-featuresoptional-dependencies" title="Crate features/optional dependencies">Crate features/optional dependencies</a></li></ul><h3><a href="#reexports">Crate Items</a></h3><ul class="block"><li><a href="#reexports" title="Re-exports">Re-exports</a></li><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#macros" title="Macros">Macros</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#statics" title="Statics">Statics</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>secp256k1</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/secp256k1/lib.rs.html#3-1052">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Rust bindings for Pieter Wuille’s secp256k1 library, which is used for
fast and accurate manipulation of ECDSA and Schnorr signatures on the secp256k1
curve. Such signatures are used extensively by the Bitcoin network
and its derivatives.</p>
<p>To minimize dependencies, some functions are feature-gated. To generate
random keys or to re-randomize a context object, compile with the
<code>rand</code> and <code>std</code> features. If you are willing to use these features, we
have enabled an additional defense-in-depth sidechannel protection for
our context objects, which re-blinds certain operations on secret key
data. To de/serialize objects with serde, compile with “serde”.
<strong>Important</strong>: <code>serde</code> encoding is <strong>not</strong> the same as consensus
encoding!</p>
<p>Where possible, the bindings use the Rust type system to ensure that
API usage errors are impossible. For example, the library uses context
objects that contain precomputation tables which are created on object
construction. Since this is a slow operation (10+ milliseconds, vs ~50
microseconds for typical crypto operations, on a 2.70 Ghz i7-6820HQ)
the tables are optional, giving a performance boost for users who only
care about signing, only care about verification, or only care about
parsing. In the upstream library, if you attempt to sign a message using
a context that does not support this, it will trigger an assertion
failure and terminate the program. In <code>rust-secp256k1</code>, this is caught
at compile-time; in fact, it is impossible to compile code that will
trigger any assertion failures in the upstream library.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>secp256k1::rand::rngs::OsRng;
<span class="kw">use </span>secp256k1::{Secp256k1, Message};
<span class="kw">use </span>secp256k1::hashes::{sha256, Hash};

<span class="kw">let </span>secp = Secp256k1::new();
<span class="kw">let </span>(secret_key, public_key) = secp.generate_keypair(<span class="kw-2">&amp;mut </span>OsRng);
<span class="kw">let </span>digest = sha256::Hash::hash(<span class="string">"Hello World!"</span>.as_bytes());
<span class="kw">let </span>message = Message::from_digest(digest.to_byte_array());

<span class="kw">let </span>sig = secp.sign_ecdsa(<span class="kw-2">&amp;</span>message, <span class="kw-2">&amp;</span>secret_key);
<span class="macro">assert!</span>(secp.verify_ecdsa(<span class="kw-2">&amp;</span>message, <span class="kw-2">&amp;</span>sig, <span class="kw-2">&amp;</span>public_key).is_ok());</code></pre></div>
<p>If the “global-context” feature is enabled you have access to an alternate API.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>secp256k1::{generate_keypair, Message};
<span class="kw">use </span>secp256k1::hashes::{sha256, Hash};

<span class="kw">let </span>(secret_key, public_key) = generate_keypair(<span class="kw-2">&amp;mut </span>rand::thread_rng());
<span class="kw">let </span>digest = sha256::Hash::hash(<span class="string">"Hello World!"</span>.as_bytes());
<span class="kw">let </span>message = Message::from_digest(digest.to_byte_array());

<span class="kw">let </span>sig = secret_key.sign_ecdsa(message);
<span class="macro">assert!</span>(sig.verify(<span class="kw-2">&amp;</span>message, <span class="kw-2">&amp;</span>public_key).is_ok());</code></pre></div>
<p>The above code requires <code>rust-secp256k1</code> to be compiled with the <code>rand</code>, <code>hashes</code>, and <code>std</code>
feature enabled, to get access to <a href="struct.Secp256k1.html#method.generate_keypair"><code>generate_keypair</code></a>
Alternately, keys and messages can be parsed from slices, like</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>secp256k1::{Secp256k1, Message, SecretKey, PublicKey};

<span class="kw">let </span>secp = Secp256k1::new();
<span class="kw">let </span>secret_key = SecretKey::from_slice(<span class="kw-2">&amp;</span>[<span class="number">0xcd</span>; <span class="number">32</span>]).expect(<span class="string">"32 bytes, within curve order"</span>);
<span class="kw">let </span>public_key = PublicKey::from_secret_key(<span class="kw-2">&amp;</span>secp, <span class="kw-2">&amp;</span>secret_key);
<span class="comment">// If the supplied byte slice was *not* the output of a cryptographic hash function this would
// be cryptographically broken. It has been trivially used in the past to execute attacks.
</span><span class="kw">let </span>message = Message::from_digest(compute_hash(<span class="string">b"CSW is not Satoshi"</span>));

<span class="kw">let </span>sig = secp.sign_ecdsa(<span class="kw-2">&amp;</span>message, <span class="kw-2">&amp;</span>secret_key);
<span class="macro">assert!</span>(secp.verify_ecdsa(<span class="kw-2">&amp;</span>message, <span class="kw-2">&amp;</span>sig, <span class="kw-2">&amp;</span>public_key).is_ok());</code></pre></div>
<p>Users who only want to verify signatures can use a cheaper context, like so:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>secp256k1::{Secp256k1, Message, ecdsa, PublicKey};

<span class="kw">let </span>secp = Secp256k1::verification_only();

<span class="kw">let </span>public_key = PublicKey::from_slice(<span class="kw-2">&amp;</span>[
    <span class="number">0x02</span>,
    <span class="number">0xc6</span>, <span class="number">0x6e</span>, <span class="number">0x7d</span>, <span class="number">0x89</span>, <span class="number">0x66</span>, <span class="number">0xb5</span>, <span class="number">0xc5</span>, <span class="number">0x55</span>,
    <span class="number">0xaf</span>, <span class="number">0x58</span>, <span class="number">0x05</span>, <span class="number">0x98</span>, <span class="number">0x9d</span>, <span class="number">0xa9</span>, <span class="number">0xfb</span>, <span class="number">0xf8</span>,
    <span class="number">0xdb</span>, <span class="number">0x95</span>, <span class="number">0xe1</span>, <span class="number">0x56</span>, <span class="number">0x31</span>, <span class="number">0xce</span>, <span class="number">0x35</span>, <span class="number">0x8c</span>,
    <span class="number">0x3a</span>, <span class="number">0x17</span>, <span class="number">0x10</span>, <span class="number">0xc9</span>, <span class="number">0x62</span>, <span class="number">0x67</span>, <span class="number">0x90</span>, <span class="number">0x63</span>,
]).expect(<span class="string">"public keys must be 33 or 65 bytes, serialized according to SEC 2"</span>);

<span class="kw">let </span>message = Message::from_digest([
    <span class="number">0xaa</span>, <span class="number">0xdf</span>, <span class="number">0x7d</span>, <span class="number">0xe7</span>, <span class="number">0x82</span>, <span class="number">0x03</span>, <span class="number">0x4f</span>, <span class="number">0xbe</span>,
    <span class="number">0x3d</span>, <span class="number">0x3d</span>, <span class="number">0xb2</span>, <span class="number">0xcb</span>, <span class="number">0x13</span>, <span class="number">0xc0</span>, <span class="number">0xcd</span>, <span class="number">0x91</span>,
    <span class="number">0xbf</span>, <span class="number">0x41</span>, <span class="number">0xcb</span>, <span class="number">0x08</span>, <span class="number">0xfa</span>, <span class="number">0xc7</span>, <span class="number">0xbd</span>, <span class="number">0x61</span>,
    <span class="number">0xd5</span>, <span class="number">0x44</span>, <span class="number">0x53</span>, <span class="number">0xcf</span>, <span class="number">0x6e</span>, <span class="number">0x82</span>, <span class="number">0xb4</span>, <span class="number">0x50</span>,
]);

<span class="kw">let </span>sig = ecdsa::Signature::from_compact(<span class="kw-2">&amp;</span>[
    <span class="number">0xdc</span>, <span class="number">0x4d</span>, <span class="number">0xc2</span>, <span class="number">0x64</span>, <span class="number">0xa9</span>, <span class="number">0xfe</span>, <span class="number">0xf1</span>, <span class="number">0x7a</span>,
    <span class="number">0x3f</span>, <span class="number">0x25</span>, <span class="number">0x34</span>, <span class="number">0x49</span>, <span class="number">0xcf</span>, <span class="number">0x8c</span>, <span class="number">0x39</span>, <span class="number">0x7a</span>,
    <span class="number">0xb6</span>, <span class="number">0xf1</span>, <span class="number">0x6f</span>, <span class="number">0xb3</span>, <span class="number">0xd6</span>, <span class="number">0x3d</span>, <span class="number">0x86</span>, <span class="number">0x94</span>,
    <span class="number">0x0b</span>, <span class="number">0x55</span>, <span class="number">0x86</span>, <span class="number">0x82</span>, <span class="number">0x3d</span>, <span class="number">0xfd</span>, <span class="number">0x02</span>, <span class="number">0xae</span>,
    <span class="number">0x3b</span>, <span class="number">0x46</span>, <span class="number">0x1b</span>, <span class="number">0xb4</span>, <span class="number">0x33</span>, <span class="number">0x6b</span>, <span class="number">0x5e</span>, <span class="number">0xcb</span>,
    <span class="number">0xae</span>, <span class="number">0xfd</span>, <span class="number">0x66</span>, <span class="number">0x27</span>, <span class="number">0xaa</span>, <span class="number">0x92</span>, <span class="number">0x2e</span>, <span class="number">0xfc</span>,
    <span class="number">0x04</span>, <span class="number">0x8f</span>, <span class="number">0xec</span>, <span class="number">0x0c</span>, <span class="number">0x88</span>, <span class="number">0x1c</span>, <span class="number">0x10</span>, <span class="number">0xc4</span>,
    <span class="number">0xc9</span>, <span class="number">0x42</span>, <span class="number">0x8f</span>, <span class="number">0xca</span>, <span class="number">0x69</span>, <span class="number">0xc1</span>, <span class="number">0x32</span>, <span class="number">0xa2</span>,
]).expect(<span class="string">"compact signatures are 64 bytes; DER signatures are 68-72 bytes"</span>);

<span class="macro">assert!</span>(secp.verify_ecdsa(<span class="kw-2">&amp;</span>message, <span class="kw-2">&amp;</span>sig, <span class="kw-2">&amp;</span>public_key).is_ok());</code></pre></div>
<p>Observe that the same code using, say <a href="struct.Secp256k1.html#method.signing_only"><code>signing_only</code></a>
to generate a context would simply not compile.</p>
<h3 id="crate-featuresoptional-dependencies"><a class="doc-anchor" href="#crate-featuresoptional-dependencies">§</a>Crate features/optional dependencies</h3>
<p>This crate provides the following opt-in Cargo features:</p>
<ul>
<li><code>std</code> - use standard Rust library, enabled by default.</li>
<li><code>alloc</code> - use the <code>alloc</code> standard Rust library to provide heap allocations.</li>
<li><code>rand</code> - use <code>rand</code> library to provide random generator (e.g. to generate keys).</li>
<li><code>hashes</code> - use the <code>hashes</code> library.</li>
<li><code>recovery</code> - enable functions that can compute the public key from signature.</li>
<li><code>lowmemory</code> - optimize the library for low-memory environments.</li>
<li><code>global-context</code> - enable use of global secp256k1 context (implies <code>std</code>).</li>
<li><code>serde</code> - implements serialization and deserialization for types in this crate using <code>serde</code>.
<strong>Important</strong>: <code>serde</code> encoding is <strong>not</strong> the same as consensus encoding!</li>
</ul>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><dl class="item-table reexports"><dt id="reexport.Scalar"><code>pub use crate::scalar::<a class="struct" href="scalar/struct.Scalar.html" title="struct secp256k1::scalar::Scalar">Scalar</a>;</code></dt><dt id="reexport.rand"><code>pub use <a class="mod" href="../rand/index.html" title="mod rand">rand</a>;</code></dt><dt id="reexport.ffi"><code>pub use <a class="mod" href="../secp256k1_sys/index.html" title="mod secp256k1_sys">secp256k1_sys</a> as ffi;</code></dt></dl><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="constants/index.html" title="mod secp256k1::constants">constants</a></dt><dd>Constants related to the API and the underlying curve.</dd><dt><a class="mod" href="ecdh/index.html" title="mod secp256k1::ecdh">ecdh</a></dt><dd>Support for shared secret computations.</dd><dt><a class="mod" href="ecdsa/index.html" title="mod secp256k1::ecdsa">ecdsa</a></dt><dd>Structs and functionality related to the ECDSA signature algorithm.</dd><dt><a class="mod" href="ellswift/index.html" title="mod secp256k1::ellswift">ellswift</a></dt><dd>This module provides an implementation of ElligatorSwift as well as a
version of x-only ECDH using it (including compatibility with BIP324).</dd><dt><a class="mod" href="global/index.html" title="mod secp256k1::global">global</a></dt><dd>Module implementing a singleton pattern for a global <code>Secp256k1</code> context.</dd><dt><a class="mod" href="scalar/index.html" title="mod secp256k1::scalar">scalar</a></dt><dd>Provides <a href="scalar/struct.Scalar.html" title="struct secp256k1::scalar::Scalar"><code>Scalar</code></a> and related types.</dd><dt><a class="mod" href="schnorr/index.html" title="mod secp256k1::schnorr">schnorr</a></dt><dd>Support for schnorr signatures.</dd></dl><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">§</a></h2><dl class="item-table"><dt><a class="macro" href="macro.impl_array_newtype.html" title="macro secp256k1::impl_array_newtype">impl_<wbr>array_<wbr>newtype</a></dt><dd>Implement methods and traits for types that contain an inner array.</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.AllPreallocated.html" title="struct secp256k1::AllPreallocated">AllPreallocated</a></dt><dd>Represents the set of all capabilities (preallocated memory).</dd><dt><a class="struct" href="struct.InvalidParityValue.html" title="struct secp256k1::InvalidParityValue">Invalid<wbr>Parity<wbr>Value</a></dt><dd>Error returned when conversion from an integer to <code>Parity</code> fails.</dd><dt><a class="struct" href="struct.Keypair.html" title="struct secp256k1::Keypair">Keypair</a></dt><dd>Opaque data structure that holds a keypair consisting of a secret and a public key.</dd><dt><a class="struct" href="struct.Message.html" title="struct secp256k1::Message">Message</a></dt><dd>A (hashed) message input to an ECDSA signature.</dd><dt><a class="struct" href="struct.PublicKey.html" title="struct secp256k1::PublicKey">Public<wbr>Key</a></dt><dd>Public key - used to verify ECDSA signatures and to do Taproot tweaks.</dd><dt><a class="struct" href="struct.Secp256k1.html" title="struct secp256k1::Secp256k1">Secp256k1</a></dt><dd>The secp256k1 engine, used to execute all signature operations.</dd><dt><a class="struct" href="struct.SecretKey.html" title="struct secp256k1::SecretKey">Secret<wbr>Key</a></dt><dd>Secret key - a 256-bit key used to create ECDSA and Taproot signatures.</dd><dt><a class="struct" href="struct.SignOnlyPreallocated.html" title="struct secp256k1::SignOnlyPreallocated">Sign<wbr>Only<wbr>Preallocated</a></dt><dd>Represents the set of capabilities needed for signing (preallocated memory).</dd><dt><a class="struct" href="struct.VerifyOnlyPreallocated.html" title="struct secp256k1::VerifyOnlyPreallocated">Verify<wbr>Only<wbr>Preallocated</a></dt><dd>Represents the set of capabilities needed for verification (preallocated memory).</dd><dt><a class="struct" href="struct.XOnlyPublicKey.html" title="struct secp256k1::XOnlyPublicKey">XOnly<wbr>Public<wbr>Key</a></dt><dd>An x-only public key, used for verification of Taproot signatures and serialized according to BIP-340.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.All.html" title="enum secp256k1::All">All</a></dt><dd>Represents the set of all capabilities.</dd><dt><a class="enum" href="enum.Error.html" title="enum secp256k1::Error">Error</a></dt><dd>The main error type for this library.</dd><dt><a class="enum" href="enum.Parity.html" title="enum secp256k1::Parity">Parity</a></dt><dd>Represents the parity passed between FFI function calls.</dd><dt><a class="enum" href="enum.SignOnly.html" title="enum secp256k1::SignOnly">Sign<wbr>Only</a></dt><dd>Represents the set of capabilities needed for signing.</dd><dt><a class="enum" href="enum.VerifyOnly.html" title="enum secp256k1::VerifyOnly">Verify<wbr>Only</a></dt><dd>Represents the set of capabilities needed for verification.</dd></dl><h2 id="statics" class="section-header">Statics<a href="#statics" class="anchor">§</a></h2><dl class="item-table"><dt><a class="static" href="static.SECP256K1.html" title="static secp256k1::SECP256K1">SECP256<wbr>K1</a></dt><dd>A global static context to avoid repeatedly creating contexts.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.Context.html" title="trait secp256k1::Context">Context</a></dt><dd>A trait for all kinds of contexts that lets you define the exact flags and a function to
deallocate memory. It isn’t possible to implement this for types outside this crate.</dd><dt><a class="trait" href="trait.PreallocatedContext.html" title="trait secp256k1::PreallocatedContext">Preallocated<wbr>Context</a></dt><dd>Trait marking that a particular context object internally points to
memory that must outlive <code>'a</code></dd><dt><a class="trait" href="trait.Signing.html" title="trait secp256k1::Signing">Signing</a></dt><dd>Marker trait for indicating that an instance of <a href="struct.Secp256k1.html" title="struct secp256k1::Secp256k1"><code>Secp256k1</code></a> can be used for signing.</dd><dt><a class="trait" href="trait.ThirtyTwoByteHash.html" title="trait secp256k1::ThirtyTwoByteHash">Thirty<wbr>TwoByte<wbr>Hash</a><wbr><span class="stab deprecated" title="">Deprecated</span></dt><dd>Trait describing something that promises to be a 32-byte uniformly random number.</dd><dt><a class="trait" href="trait.Verification.html" title="trait secp256k1::Verification">Verification</a></dt><dd>Marker trait for indicating that an instance of <a href="struct.Secp256k1.html" title="struct secp256k1::Secp256k1"><code>Secp256k1</code></a> can be used for verification.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.generate_keypair.html" title="fn secp256k1::generate_keypair">generate_<wbr>keypair</a></dt><dd>Generates a random keypair using the global <a href="static.SECP256K1.html" title="static secp256k1::SECP256K1"><code>SECP256K1</code></a> context.</dd></dl></section></div></main></body></html>
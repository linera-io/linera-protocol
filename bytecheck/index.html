<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="bytecheck"><title>bytecheck - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-6c3ea77c.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="bytecheck" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0 (05f9846f8 2025-03-31)" data-channel="1.86.0" data-search-js="search-581efc7a.js" data-settings-js="settings-6dad6058.js" ><script src="../static.files/storage-3a5871a4.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-4d63596a.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../bytecheck/index.html">bytecheck</a><span class="version">0.6.12</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#bytecheck" title="bytecheck">bytecheck</a><ul><li><a href="#design" title="Design">Design</a></li><li><a href="#examples" title="Examples">Examples</a></li><li><a href="#features" title="Features">Features</a></li><li><a href="#crate-support" title="Crate support">Crate support</a></li></ul></li></ul><h3><a href="#structs">Crate Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li><li><a href="#derives" title="Derive Macros">Derive Macros</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>bytecheck</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/bytecheck/lib.rs.html#1-875">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="bytecheck"><a class="doc-anchor" href="#bytecheck">§</a>bytecheck</h2>
<p>bytecheck is a type validation framework for Rust.</p>
<p>For some types, creating an invalid value immediately results in undefined
behavior. This can cause some issues when trying to validate potentially
invalid bytes, as just casting the bytes to your type can technically cause
errors. This makes it difficult to write validation routines, because until
you’re certain that the bytes represent valid values you cannot cast them.</p>
<p>bytecheck provides a framework for performing these byte-level validations
and implements checks for basic types along with a derive macro to implement
validation for custom structs and enums.</p>
<h3 id="design"><a class="doc-anchor" href="#design">§</a>Design</h3>
<p><a href="trait.CheckBytes.html" title="trait bytecheck::CheckBytes"><code>CheckBytes</code></a> is at the heart of bytecheck, and does the heavy lifting of
verifying that some bytes represent a valid type. Implementing it can be
done manually or automatically with the <a href="derive.CheckBytes.html" title="derive bytecheck::CheckBytes">derive macro</a>.</p>
<h3 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bytecheck::CheckBytes;

<span class="attr">#[derive(CheckBytes, Debug)]
#[repr(C)]
</span><span class="kw">struct </span>Test {
    a: u32,
    b: char,
    c: bool,
}
<span class="attr">#[repr(C, align(<span class="number">16</span>))]
</span><span class="kw">struct </span>Aligned&lt;<span class="kw">const </span>N: usize&gt;([u8; N]);

<span class="macro">macro_rules!</span> bytes {
    ($(<span class="macro-nonterminal">$byte</span>:literal,)<span class="kw-2">*</span>) =&gt; {
        (<span class="kw-2">&amp;</span>Aligned([$(<span class="macro-nonterminal">$byte</span>,)<span class="kw-2">*</span>]).<span class="number">0 </span><span class="kw">as </span><span class="kw-2">&amp;</span>[u8]).as_ptr()
    };
    ($(<span class="macro-nonterminal">$byte</span>:literal),<span class="kw-2">*</span>) =&gt; {
        <span class="macro">bytes!</span>($(<span class="macro-nonterminal">$byte</span>,)<span class="kw-2">*</span>)
    };
}

<span class="comment">// This type is laid out as (u32, char, bool)
// In this example, the architecture is assumed to be little-endian
</span><span class="kw">unsafe </span>{
    <span class="comment">// These are valid bytes for (0, 'x', true)
    </span>Test::check_bytes(
        <span class="macro">bytes!</span>[
            <span class="number">0u8</span>, <span class="number">0u8</span>, <span class="number">0u8</span>, <span class="number">0u8</span>, <span class="number">0x78u8</span>, <span class="number">0u8</span>, <span class="number">0u8</span>, <span class="number">0u8</span>,
            <span class="number">1u8</span>, <span class="number">255u8</span>, <span class="number">255u8</span>, <span class="number">255u8</span>, <span class="number">255u8</span>, <span class="number">255u8</span>, <span class="number">255u8</span>, <span class="number">255u8
        </span>].cast(),
        <span class="kw-2">&amp;mut </span>()
    ).unwrap();

    <span class="comment">// Changing the bytes for the u32 is OK, any bytes are a valid u32
    </span>Test::check_bytes(
        <span class="macro">bytes!</span>[
            <span class="number">42u8</span>, <span class="number">16u8</span>, <span class="number">20u8</span>, <span class="number">3u8</span>, <span class="number">0x78u8</span>, <span class="number">0u8</span>, <span class="number">0u8</span>, <span class="number">0u8</span>,
            <span class="number">1u8</span>, <span class="number">255u8</span>, <span class="number">255u8</span>, <span class="number">255u8</span>, <span class="number">255u8</span>, <span class="number">255u8</span>, <span class="number">255u8</span>, <span class="number">255u8
        </span>].cast(),
        <span class="kw-2">&amp;mut </span>()
    ).unwrap();

    <span class="comment">// Characters outside the valid ranges are invalid
    </span>Test::check_bytes(
        <span class="macro">bytes!</span>[
            <span class="number">0u8</span>, <span class="number">0u8</span>, <span class="number">0u8</span>, <span class="number">0u8</span>, <span class="number">0x00u8</span>, <span class="number">0xd8u8</span>, <span class="number">0u8</span>, <span class="number">0u8</span>,
            <span class="number">1u8</span>, <span class="number">255u8</span>, <span class="number">255u8</span>, <span class="number">255u8</span>, <span class="number">255u8</span>, <span class="number">255u8</span>, <span class="number">255u8</span>, <span class="number">255u8
        </span>].cast(),
        <span class="kw-2">&amp;mut </span>()
    ).unwrap_err();
    Test::check_bytes(
        <span class="macro">bytes!</span>[
            <span class="number">0u8</span>, <span class="number">0u8</span>, <span class="number">0u8</span>, <span class="number">0u8</span>, <span class="number">0x00u8</span>, <span class="number">0x00u8</span>, <span class="number">0x11u8</span>, <span class="number">0u8</span>,
            <span class="number">1u8</span>, <span class="number">255u8</span>, <span class="number">255u8</span>, <span class="number">255u8</span>, <span class="number">255u8</span>, <span class="number">255u8</span>, <span class="number">255u8</span>, <span class="number">255u8
        </span>].cast(),
        <span class="kw-2">&amp;mut </span>()
    ).unwrap_err();

    <span class="comment">// 0 is a valid boolean value (false) but 2 is not
    </span>Test::check_bytes(
        <span class="macro">bytes!</span>[
            <span class="number">0u8</span>, <span class="number">0u8</span>, <span class="number">0u8</span>, <span class="number">0u8</span>, <span class="number">0x78u8</span>, <span class="number">0u8</span>, <span class="number">0u8</span>, <span class="number">0u8</span>,
            <span class="number">0u8</span>, <span class="number">255u8</span>, <span class="number">255u8</span>, <span class="number">255u8</span>, <span class="number">255u8</span>, <span class="number">255u8</span>, <span class="number">255u8</span>, <span class="number">255u8
        </span>].cast(),
        <span class="kw-2">&amp;mut </span>()
    ).unwrap();
    Test::check_bytes(
        <span class="macro">bytes!</span>[
            <span class="number">0u8</span>, <span class="number">0u8</span>, <span class="number">0u8</span>, <span class="number">0u8</span>, <span class="number">0x78u8</span>, <span class="number">0u8</span>, <span class="number">0u8</span>, <span class="number">0u8</span>,
            <span class="number">2u8</span>, <span class="number">255u8</span>, <span class="number">255u8</span>, <span class="number">255u8</span>, <span class="number">255u8</span>, <span class="number">255u8</span>, <span class="number">255u8</span>, <span class="number">255u8
        </span>].cast(),
        <span class="kw-2">&amp;mut </span>()
    ).unwrap_err();
}</code></pre></div>
<h3 id="features"><a class="doc-anchor" href="#features">§</a>Features</h3>
<ul>
<li><code>verbose</code>: Some validation algorithms are optimized for speed and do not report full error
details by default. This feature provides full error information.</li>
<li><code>std</code>: Enables standard library support (enabled by default). If the <code>std</code> feature is not
enabled, the <code>alloc</code> crate is required.</li>
</ul>
<h3 id="crate-support"><a class="doc-anchor" href="#crate-support">§</a>Crate support</h3>
<p>Some common crates need to be supported by bytecheck before an official integration has been
made. Support is provided by bytecheck for these crates, but in the future crates should depend
on bytecheck and provide their own implementations. The crates that already have support
provided by bytecheck should work toward integrating the implementations into themselves.</p>
<p>Crates supported by bytecheck:</p>
<ul>
<li><a href="https://docs.rs/uuid"><code>uuid</code></a></li>
</ul>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.ArrayCheckError.html" title="struct bytecheck::ArrayCheckError">Array<wbr>Check<wbr>Error</a></dt><dd>An error resulting from an invalid array.</dd><dt><a class="struct" href="struct.BoolCheckError.html" title="struct bytecheck::BoolCheckError">Bool<wbr>Check<wbr>Error</a></dt><dd>An error resulting from an invalid boolean.</dd><dt><a class="struct" href="struct.CharCheckError.html" title="struct bytecheck::CharCheckError">Char<wbr>Check<wbr>Error</a></dt><dd>An error resulting from an invalid character.</dd><dt><a class="struct" href="struct.StructCheckError.html" title="struct bytecheck::StructCheckError">Struct<wbr>Check<wbr>Error</a></dt><dd>An error resulting from an invalid struct.</dd><dt><a class="struct" href="struct.TupleStructCheckError.html" title="struct bytecheck::TupleStructCheckError">Tuple<wbr>Struct<wbr>Check<wbr>Error</a></dt><dd>An error resulting from an invalid tuple struct.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.CStrCheckError.html" title="enum bytecheck::CStrCheckError">CStr<wbr>Check<wbr>Error</a></dt><dd>An error resulting from an invalid <code>CStr</code>.</dd><dt><a class="enum" href="enum.EnumCheckError.html" title="enum bytecheck::EnumCheckError">Enum<wbr>Check<wbr>Error</a></dt><dd>An error resulting from an invalid enum.</dd><dt><a class="enum" href="enum.NonZeroCheckError.html" title="enum bytecheck::NonZeroCheckError">NonZero<wbr>Check<wbr>Error</a></dt><dd>An error resulting from an invalid <code>NonZero</code> integer.</dd><dt><a class="enum" href="enum.SliceCheckError.html" title="enum bytecheck::SliceCheckError">Slice<wbr>Check<wbr>Error</a></dt><dd>An error resulting from an invalid slice.</dd><dt><a class="enum" href="enum.StrCheckError.html" title="enum bytecheck::StrCheckError">StrCheck<wbr>Error</a></dt><dd>An error resulting from an invalid str.</dd><dt><a class="enum" href="enum.Tuple1CheckError.html" title="enum bytecheck::Tuple1CheckError">Tuple1<wbr>Check<wbr>Error</a></dt><dd>An error resulting from an invalid tuple.</dd><dt><a class="enum" href="enum.Tuple2CheckError.html" title="enum bytecheck::Tuple2CheckError">Tuple2<wbr>Check<wbr>Error</a></dt><dd>An error resulting from an invalid tuple.</dd><dt><a class="enum" href="enum.Tuple3CheckError.html" title="enum bytecheck::Tuple3CheckError">Tuple3<wbr>Check<wbr>Error</a></dt><dd>An error resulting from an invalid tuple.</dd><dt><a class="enum" href="enum.Tuple4CheckError.html" title="enum bytecheck::Tuple4CheckError">Tuple4<wbr>Check<wbr>Error</a></dt><dd>An error resulting from an invalid tuple.</dd><dt><a class="enum" href="enum.Tuple5CheckError.html" title="enum bytecheck::Tuple5CheckError">Tuple5<wbr>Check<wbr>Error</a></dt><dd>An error resulting from an invalid tuple.</dd><dt><a class="enum" href="enum.Tuple6CheckError.html" title="enum bytecheck::Tuple6CheckError">Tuple6<wbr>Check<wbr>Error</a></dt><dd>An error resulting from an invalid tuple.</dd><dt><a class="enum" href="enum.Tuple7CheckError.html" title="enum bytecheck::Tuple7CheckError">Tuple7<wbr>Check<wbr>Error</a></dt><dd>An error resulting from an invalid tuple.</dd><dt><a class="enum" href="enum.Tuple8CheckError.html" title="enum bytecheck::Tuple8CheckError">Tuple8<wbr>Check<wbr>Error</a></dt><dd>An error resulting from an invalid tuple.</dd><dt><a class="enum" href="enum.Tuple9CheckError.html" title="enum bytecheck::Tuple9CheckError">Tuple9<wbr>Check<wbr>Error</a></dt><dd>An error resulting from an invalid tuple.</dd><dt><a class="enum" href="enum.Tuple10CheckError.html" title="enum bytecheck::Tuple10CheckError">Tuple10<wbr>Check<wbr>Error</a></dt><dd>An error resulting from an invalid tuple.</dd><dt><a class="enum" href="enum.Tuple11CheckError.html" title="enum bytecheck::Tuple11CheckError">Tuple11<wbr>Check<wbr>Error</a></dt><dd>An error resulting from an invalid tuple.</dd><dt><a class="enum" href="enum.Tuple12CheckError.html" title="enum bytecheck::Tuple12CheckError">Tuple12<wbr>Check<wbr>Error</a></dt><dd>An error resulting from an invalid tuple.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.CheckBytes.html" title="trait bytecheck::CheckBytes">Check<wbr>Bytes</a></dt><dd>A type that can check whether a pointer points to a valid value.</dd><dt><a class="trait" href="trait.Error.html" title="trait bytecheck::Error">Error</a></dt><dd>An error that can be debugged and displayed.</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><dl class="item-table"><dt><a class="type" href="type.ErrorBox.html" title="type bytecheck::ErrorBox">Error<wbr>Box</a></dt><dd>The type used for boxing errors.</dd></dl><h2 id="derives" class="section-header">Derive Macros<a href="#derives" class="anchor">§</a></h2><dl class="item-table"><dt><a class="derive" href="derive.CheckBytes.html" title="derive bytecheck::CheckBytes">Check<wbr>Bytes</a></dt><dd>Derives <code>CheckBytes</code> for the labeled type.</dd></dl></section></div></main></body></html>
<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="ByteStream Abstractions"><title>aws_smithy_types::byte_stream - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-6c3ea77c.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="aws_smithy_types" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0 (05f9846f8 2025-03-31)" data-channel="1.86.0" data-search-js="search-581efc7a.js" data-settings-js="settings-6dad6058.js" ><script src="../../static.files/storage-3a5871a4.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-4d63596a.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../aws_smithy_types/index.html">aws_<wbr>smithy_<wbr>types</a><span class="version">1.3.2</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module byte_<wbr>stream</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#examples" title="Examples">Examples</a><ul><li><a href="#writing-a-bytestream-into-a-file" title="Writing a ByteStream into a file:">Writing a ByteStream into a file:</a></li><li><a href="#converting-a-bytestream-into-bytes" title="Converting a ByteStream into Bytes">Converting a ByteStream into Bytes</a></li><li><a href="#stream-a-bytestream-into-a-file" title="Stream a ByteStream into a file">Stream a ByteStream into a file</a></li><li><a href="#create-a-bytestream-from-a-file" title="Create a ByteStream from a file">Create a ByteStream from a file</a></li></ul></li></ul><h3><a href="#modules">Module Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate aws_<wbr>smithy_<wbr>types</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">aws_smithy_types</a></div><h1>Module <span>byte_stream</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/aws_smithy_types/byte_stream.rs.html#6-664">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>ByteStream Abstractions</p>
<p>When the SDK returns streaming binary data, the inner Http Body is
wrapped in <a href="struct.ByteStream.html" title="struct aws_smithy_types::byte_stream::ByteStream"><code>ByteStream</code></a>. ByteStream provides misuse-resistant primitives
to make it easier to handle common patterns with streaming data.</p>
<h2 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h2><h4 id="writing-a-bytestream-into-a-file"><a class="doc-anchor" href="#writing-a-bytestream-into-a-file">§</a>Writing a ByteStream into a file:</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>aws_smithy_types::byte_stream::ByteStream;
<span class="kw">use </span>std::error::Error;
<span class="kw">use </span>tokio::fs::File;
<span class="kw">use </span>tokio::io::AsyncWriteExt;
<span class="kw">struct </span>SynthesizeSpeechOutput {
    audio_stream: ByteStream,
}

<span class="kw">async fn </span>audio_to_file(
    output: SynthesizeSpeechOutput,
) -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>Error + Send + Sync&gt;&gt; {
    <span class="kw">let </span><span class="kw-2">mut </span>buf = output.audio_stream.collect().<span class="kw">await</span><span class="question-mark">?</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>file = File::open(<span class="string">"audio.mp3"</span>).<span class="kw">await</span><span class="question-mark">?</span>;
    file.write_all_buf(<span class="kw-2">&amp;mut </span>buf).<span class="kw">await</span><span class="question-mark">?</span>;
    file.flush().<span class="kw">await</span><span class="question-mark">?</span>;
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<h4 id="converting-a-bytestream-into-bytes"><a class="doc-anchor" href="#converting-a-bytestream-into-bytes">§</a>Converting a ByteStream into Bytes</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bytes::Bytes;
<span class="kw">use </span>aws_smithy_types::byte_stream::ByteStream;
<span class="kw">use </span>std::error::Error;
<span class="kw">struct </span>SynthesizeSpeechOutput {
    audio_stream: ByteStream,
}
<span class="kw">async fn </span>load_audio(
    output: SynthesizeSpeechOutput,
) -&gt; <span class="prelude-ty">Result</span>&lt;Bytes, Box&lt;<span class="kw">dyn </span>Error + Send + Sync&gt;&gt; {
    <span class="prelude-val">Ok</span>(output.audio_stream.collect().<span class="kw">await</span><span class="question-mark">?</span>.into_bytes())
}</code></pre></div>
<h4 id="stream-a-bytestream-into-a-file"><a class="doc-anchor" href="#stream-a-bytestream-into-a-file">§</a>Stream a ByteStream into a file</h4>
<p>The previous example is recommended in cases where loading the entire file into memory first is desirable. For extremely large
files, you may wish to stream the data directly to the file system, chunk by chunk.
This is possible using the <a href="struct.ByteStream.html#method.next" title="method aws_smithy_types::byte_stream::ByteStream::next"><code>.next()</code></a> method.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bytes::{Buf, Bytes};
<span class="kw">use </span>aws_smithy_types::byte_stream::ByteStream;
<span class="kw">use </span>std::error::Error;
<span class="kw">use </span>tokio::fs::File;
<span class="kw">use </span>tokio::io::AsyncWriteExt;
<span class="kw">use </span>tokio_stream::StreamExt;
<span class="kw">struct </span>SynthesizeSpeechOutput {
    audio_stream: ByteStream,
}

<span class="kw">async fn </span>audio_to_file(
    output: SynthesizeSpeechOutput,
) -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>Error + Send + Sync&gt;&gt; {
    <span class="kw">let </span><span class="kw-2">mut </span>file = File::open(<span class="string">"audio.mp3"</span>).<span class="kw">await</span><span class="question-mark">?</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>stream = output.audio_stream;
    <span class="kw">while let </span><span class="prelude-val">Some</span>(bytes) = stream.next().<span class="kw">await </span>{
        <span class="kw">let </span>bytes: Bytes = bytes<span class="question-mark">?</span>;
        file.write_all(<span class="kw-2">&amp;</span>bytes).<span class="kw">await</span><span class="question-mark">?</span>;
    }
    file.flush().<span class="kw">await</span><span class="question-mark">?</span>;
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<h4 id="create-a-bytestream-from-a-file"><a class="doc-anchor" href="#create-a-bytestream-from-a-file">§</a>Create a ByteStream from a file</h4>
<p><em>Note: This is only available with <code>rt-tokio</code> enabled.</em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>aws_smithy_types::byte_stream::ByteStream;
<span class="kw">use </span>std::path::Path;
<span class="kw">struct </span>GetObjectInput {
  body: ByteStream
}

<span class="kw">async fn </span>bytestream_from_file() -&gt; GetObjectInput {
    <span class="kw">let </span>bytestream = ByteStream::from_path(<span class="string">"docs/some-large-file.csv"</span>)
        .<span class="kw">await
        </span>.expect(<span class="string">"valid path"</span>);
    GetObjectInput { body: bytestream }
}</code></pre></div>
<p>If you want more control over how the file is read, such as specifying the size of the buffer used to read the file
or the length of the file, use an <code>FsBuilder</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>aws_smithy_types::byte_stream::{ByteStream, Length};
<span class="kw">use </span>std::path::Path;
<span class="kw">struct </span>GetObjectInput {
    body: ByteStream
}

<span class="kw">async fn </span>bytestream_from_file() -&gt; GetObjectInput {
    <span class="kw">let </span>bytestream = ByteStream::read_from().path(<span class="string">"docs/some-large-file.csv"</span>)
        .buffer_size(<span class="number">32_784</span>)
        .length(Length::Exact(<span class="number">123_456</span>))
        .build()
        .<span class="kw">await
        </span>.expect(<span class="string">"valid path"</span>);
    GetObjectInput { body: bytestream }
}</code></pre></div>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="error/index.html" title="mod aws_smithy_types::byte_stream::error">error</a></dt><dd>Errors related to bytestreams.</dd><dt><a class="mod" href="http_body_0_4_x/index.html" title="mod aws_smithy_types::byte_stream::http_body_0_4_x">http_<wbr>body_<wbr>0_<wbr>4_<wbr>x</a></dt><dd>This module is named after the <code>http-body</code> version number since we anticipate
needing to provide equivalent functionality for 1.x of that crate in the future.
The name has a suffix <code>_x</code> to avoid name collision with a third-party <code>http-body-0-4</code>.</dd><dt><a class="mod" href="http_body_1_x/index.html" title="mod aws_smithy_types::byte_stream::http_body_1_x">http_<wbr>body_<wbr>1_<wbr>x</a></dt><dd>Adapters to use http-body 1.0 bodies with SdkBody &amp; ByteStream</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.AggregatedBytes.html" title="struct aws_smithy_types::byte_stream::AggregatedBytes">Aggregated<wbr>Bytes</a></dt><dd>Non-contiguous Binary Data Storage</dd><dt><a class="struct" href="struct.ByteStream.html" title="struct aws_smithy_types::byte_stream::ByteStream">Byte<wbr>Stream</a></dt><dd>Stream of binary data</dd><dt><a class="struct" href="struct.FsBuilder.html" title="struct aws_smithy_types::byte_stream::FsBuilder">FsBuilder</a></dt><dd>Builder for creating <a href="struct.ByteStream.html" title="struct aws_smithy_types::byte_stream::ByteStream"><code>ByteStreams</code></a> from a file/path, with full control over advanced options.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.Length.html" title="enum aws_smithy_types::byte_stream::Length">Length</a></dt><dd>The length (in bytes) to read. Determines whether or not a short read counts as an error.</dd></dl></section></div></main></body></html>
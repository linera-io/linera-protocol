<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Strategies for combining delegate strategies into `std::Result`s."><title>proptest::result - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-6c3ea77c.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="proptest" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0 (05f9846f8 2025-03-31)" data-channel="1.86.0" data-search-js="search-581efc7a.js" data-settings-js="settings-6dad6058.js" ><script src="../../static.files/storage-3a5871a4.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-4d63596a.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../proptest/index.html">proptest</a><span class="version">1.7.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module result</a></h2><h3><a href="#reexports">Module Items</a></h3><ul class="block"><li><a href="#reexports" title="Re-exports">Re-exports</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate proptest</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">proptest</a></div><h1>Module <span>result</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/proptest/result.rs.html#10-326">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Strategies for combining delegate strategies into <code>std::Result</code>s.</p>
<p>That is, the strategies here are for producing <code>Ok</code> <em>and</em> <code>Err</code> cases. To
simply adapt a strategy producing <code>T</code> into <code>Result&lt;T, something&gt;</code> which is
always <code>Ok</code>, you can do something like <code>base_strategy.prop_map(Ok)</code> to
simply wrap the generated values.</p>
<p>Note that there are two nearly identical APIs for doing this, termed “maybe
ok” and “maybe err”. The difference between the two is in how they shrink;
“maybe ok” treats <code>Ok</code> as the special case and shrinks to <code>Err</code>;
conversely, “maybe err” treats <code>Err</code> as the special case and shrinks to
<code>Ok</code>. Which to use largely depends on the code being tested; if the code
typically handles errors by immediately bailing out and doing nothing else,
“maybe ok” is likely more suitable, as shrinking will cause the code to
take simpler paths. On the other hand, functions that need to make a
complicated or fragile “back out” process on error are better tested with
“maybe err” since the success case results in an easier to understand code
path.</p>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><dl class="item-table reexports"><dt id="reexport.prob"><code>pub use crate::option::<a class="fn" href="../option/fn.prob.html" title="fn proptest::option::prob">prob</a>;</code></dt><dt id="reexport.Probability"><code>pub use crate::option::<a class="struct" href="../option/struct.Probability.html" title="struct proptest::option::Probability">Probability</a>;</code></dt></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.MaybeErr.html" title="struct proptest::result::MaybeErr">Maybe<wbr>Err</a></dt><dd>Strategy which generates <code>Result</code>s using <code>Ok</code> and <code>Err</code> values from two
delegate strategies.</dd><dt><a class="struct" href="struct.MaybeErrValueTree.html" title="struct proptest::result::MaybeErrValueTree">Maybe<wbr>ErrValue<wbr>Tree</a></dt><dd><code>ValueTree</code> type corresponding to <code>MaybeErr</code>.</dd><dt><a class="struct" href="struct.MaybeOk.html" title="struct proptest::result::MaybeOk">MaybeOk</a></dt><dd>Strategy which generates <code>Result</code>s using <code>Ok</code> and <code>Err</code> values from two
delegate strategies.</dd><dt><a class="struct" href="struct.MaybeOkValueTree.html" title="struct proptest::result::MaybeOkValueTree">Maybe<wbr>OkValue<wbr>Tree</a></dt><dd><code>ValueTree</code> type corresponding to <code>MaybeOk</code>.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.maybe_err.html" title="fn proptest::result::maybe_err">maybe_<wbr>err</a></dt><dd>Create a strategy for <code>Result</code>s where <code>Ok</code> values are taken from <code>t</code> and
<code>Err</code> values are taken from <code>e</code>.</dd><dt><a class="fn" href="fn.maybe_err_weighted.html" title="fn proptest::result::maybe_err_weighted">maybe_<wbr>err_<wbr>weighted</a></dt><dd>Create a strategy for <code>Result</code>s where <code>Ok</code> values are taken from <code>t</code> and
<code>Err</code> values are taken from <code>e</code>.</dd><dt><a class="fn" href="fn.maybe_ok.html" title="fn proptest::result::maybe_ok">maybe_<wbr>ok</a></dt><dd>Create a strategy for <code>Result</code>s where <code>Ok</code> values are taken from <code>t</code> and
<code>Err</code> values are taken from <code>e</code>.</dd><dt><a class="fn" href="fn.maybe_ok_weighted.html" title="fn proptest::result::maybe_ok_weighted">maybe_<wbr>ok_<wbr>weighted</a></dt><dd>Create a strategy for <code>Result</code>s where <code>Ok</code> values are taken from <code>t</code> and
<code>Err</code> values are taken from <code>e</code>.</dd></dl></section></div></main></body></html>
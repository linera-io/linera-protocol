(function() {
    var type_impls = Object.fromEntries([["linera_exporter",[["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Clone-for-Sender%3CT%3E\" class=\"impl\"><a class=\"src rightside\" href=\"src/tokio/sync/mpsc/bounded.rs.html#1591\">Source</a><a href=\"#impl-Clone-for-Sender%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.86.0/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a> for <a class=\"struct\" href=\"tokio/sync/mpsc/bounded/struct.Sender.html\" title=\"struct tokio::sync::mpsc::bounded::Sender\">Sender</a>&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.clone\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"src/tokio/sync/mpsc/bounded.rs.html#1592\">Source</a><a href=\"#method.clone\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.86.0/core/clone/trait.Clone.html#tymethod.clone\" class=\"fn\">clone</a>(&amp;self) -&gt; <a class=\"struct\" href=\"tokio/sync/mpsc/bounded/struct.Sender.html\" title=\"struct tokio::sync::mpsc::bounded::Sender\">Sender</a>&lt;T&gt;</h4></section></summary><div class='docblock'>Returns a copy of the value. <a href=\"https://doc.rust-lang.org/1.86.0/core/clone/trait.Clone.html#tymethod.clone\">Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.clone_from\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.86.0/src/core/clone.rs.html#174\">Source</a></span><a href=\"#method.clone_from\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.86.0/core/clone/trait.Clone.html#method.clone_from\" class=\"fn\">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href=\"https://doc.rust-lang.org/1.86.0/core/clone/trait.Clone.html#method.clone_from\">Read more</a></div></details></div></details>","Clone","linera_exporter::runloops::indexer::indexer_exporter::CanonicalBlockStream"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Debug-for-Sender%3CT%3E\" class=\"impl\"><a class=\"src rightside\" href=\"src/tokio/sync/mpsc/bounded.rs.html#1599\">Source</a><a href=\"#impl-Debug-for-Sender%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.86.0/core/fmt/trait.Debug.html\" title=\"trait core::fmt::Debug\">Debug</a> for <a class=\"struct\" href=\"tokio/sync/mpsc/bounded/struct.Sender.html\" title=\"struct tokio::sync::mpsc::bounded::Sender\">Sender</a>&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.fmt\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"src/tokio/sync/mpsc/bounded.rs.html#1600\">Source</a><a href=\"#method.fmt\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.86.0/core/fmt/trait.Debug.html#tymethod.fmt\" class=\"fn\">fmt</a>(&amp;self, fmt: &amp;mut <a class=\"struct\" href=\"https://doc.rust-lang.org/1.86.0/core/fmt/struct.Formatter.html\" title=\"struct core::fmt::Formatter\">Formatter</a>&lt;'_&gt;) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.86.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.86.0/std/primitive.unit.html\">()</a>, <a class=\"struct\" href=\"https://doc.rust-lang.org/1.86.0/core/fmt/struct.Error.html\" title=\"struct core::fmt::Error\">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href=\"https://doc.rust-lang.org/1.86.0/core/fmt/trait.Debug.html#tymethod.fmt\">Read more</a></div></details></div></details>","Debug","linera_exporter::runloops::indexer::indexer_exporter::CanonicalBlockStream"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Sender%3CT%3E\" class=\"impl\"><a class=\"src rightside\" href=\"src/tokio/sync/mpsc/bounded.rs.html#746\">Source</a><a href=\"#impl-Sender%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"struct\" href=\"tokio/sync/mpsc/bounded/struct.Sender.html\" title=\"struct tokio::sync::mpsc::bounded::Sender\">Sender</a>&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.send\" class=\"method\"><a class=\"src rightside\" href=\"src/tokio/sync/mpsc/bounded.rs.html#810\">Source</a><h4 class=\"code-header\">pub async fn <a href=\"tokio/sync/mpsc/bounded/struct.Sender.html#tymethod.send\" class=\"fn\">send</a>(&amp;self, value: T) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.86.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.86.0/std/primitive.unit.html\">()</a>, <a class=\"struct\" href=\"tokio/sync/mpsc/error/struct.SendError.html\" title=\"struct tokio::sync::mpsc::error::SendError\">SendError</a>&lt;T&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Sends a value, waiting until there is capacity.</p>\n<p>A successful send occurs when it is determined that the other end of the\nchannel has not hung up already. An unsuccessful send would be one where\nthe corresponding receiver has already been closed. Note that a return\nvalue of <code>Err</code> means that the data will never be received, but a return\nvalue of <code>Ok</code> does not mean that the data will be received. It is\npossible for the corresponding receiver to hang up immediately after\nthis function returns <code>Ok</code>.</p>\n<h5 id=\"errors\"><a class=\"doc-anchor\" href=\"#errors\">§</a>Errors</h5>\n<p>If the receive half of the channel is closed, either due to <a href=\"tokio/sync/mpsc/bounded/struct.Receiver.html#method.close\" title=\"method tokio::sync::mpsc::bounded::Receiver::close\"><code>close</code></a>\nbeing called or the <a href=\"tokio/sync/mpsc/bounded/struct.Receiver.html\" title=\"struct tokio::sync::mpsc::bounded::Receiver\"><code>Receiver</code></a> handle dropping, the function returns\nan error. The error includes the value passed to <code>send</code>.</p>\n<h5 id=\"cancel-safety\"><a class=\"doc-anchor\" href=\"#cancel-safety\">§</a>Cancel safety</h5>\n<p>If <code>send</code> is used as the event in a <a href=\"tokio/macro.select.html\" title=\"macro tokio::select\"><code>tokio::select!</code></a>\nstatement and some other branch completes first, then it is guaranteed\nthat the message was not sent. <strong>However, in that case, the message\nis dropped and will be lost.</strong></p>\n<p>To avoid losing messages, use <a href=\"tokio/sync/mpsc/bounded/struct.Sender.html#method.reserve\" title=\"method tokio::sync::mpsc::bounded::Sender::reserve\"><code>reserve</code></a> to reserve\ncapacity, then use the returned <a href=\"tokio/sync/mpsc/bounded/struct.Permit.html\" title=\"struct tokio::sync::mpsc::bounded::Permit\"><code>Permit</code></a> to send the message.</p>\n<p>This channel uses a queue to ensure that calls to <code>send</code> and <code>reserve</code>\ncomplete in the order they were requested.  Cancelling a call to\n<code>send</code> makes you lose your place in the queue.</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h5>\n<p>In the following example, each call to <code>send</code> will block until the\npreviously sent value was received.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::mpsc;\n\n<span class=\"attr\">#[tokio::main]\n</span><span class=\"kw\">async fn </span>main() {\n    <span class=\"kw\">let </span>(tx, <span class=\"kw-2\">mut </span>rx) = mpsc::channel(<span class=\"number\">1</span>);\n\n    tokio::spawn(<span class=\"kw\">async move </span>{\n        <span class=\"kw\">for </span>i <span class=\"kw\">in </span><span class=\"number\">0</span>..<span class=\"number\">10 </span>{\n            <span class=\"kw\">if let </span><span class=\"prelude-val\">Err</span>(<span class=\"kw\">_</span>) = tx.send(i).<span class=\"kw\">await </span>{\n                <span class=\"macro\">println!</span>(<span class=\"string\">\"receiver dropped\"</span>);\n                <span class=\"kw\">return</span>;\n            }\n        }\n    });\n\n    <span class=\"kw\">while let </span><span class=\"prelude-val\">Some</span>(i) = rx.recv().<span class=\"kw\">await </span>{\n        <span class=\"macro\">println!</span>(<span class=\"string\">\"got = {}\"</span>, i);\n    }\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.closed\" class=\"method\"><a class=\"src rightside\" href=\"src/tokio/sync/mpsc/bounded.rs.html#856\">Source</a><h4 class=\"code-header\">pub async fn <a href=\"tokio/sync/mpsc/bounded/struct.Sender.html#tymethod.closed\" class=\"fn\">closed</a>(&amp;self)</h4></section></summary><div class=\"docblock\"><p>Completes when the receiver has dropped.</p>\n<p>This allows the producers to get notified when interest in the produced\nvalues is canceled and immediately stop doing work.</p>\n<h5 id=\"cancel-safety-1\"><a class=\"doc-anchor\" href=\"#cancel-safety-1\">§</a>Cancel safety</h5>\n<p>This method is cancel safe. Once the channel is closed, it stays closed\nforever and all future calls to <code>closed</code> will return immediately.</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::mpsc;\n\n<span class=\"attr\">#[tokio::main]\n</span><span class=\"kw\">async fn </span>main() {\n    <span class=\"kw\">let </span>(tx1, rx) = mpsc::channel::&lt;()&gt;(<span class=\"number\">1</span>);\n    <span class=\"kw\">let </span>tx2 = tx1.clone();\n    <span class=\"kw\">let </span>tx3 = tx1.clone();\n    <span class=\"kw\">let </span>tx4 = tx1.clone();\n    <span class=\"kw\">let </span>tx5 = tx1.clone();\n    tokio::spawn(<span class=\"kw\">async move </span>{\n        drop(rx);\n    });\n\n    <span class=\"macro\">futures::join!</span>(\n        tx1.closed(),\n        tx2.closed(),\n        tx3.closed(),\n        tx4.closed(),\n        tx5.closed()\n    );\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"Receiver dropped\"</span>);\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_send\" class=\"method\"><a class=\"src rightside\" href=\"src/tokio/sync/mpsc/bounded.rs.html#918\">Source</a><h4 class=\"code-header\">pub fn <a href=\"tokio/sync/mpsc/bounded/struct.Sender.html#tymethod.try_send\" class=\"fn\">try_send</a>(&amp;self, message: T) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.86.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.86.0/std/primitive.unit.html\">()</a>, <a class=\"enum\" href=\"tokio/sync/mpsc/error/enum.TrySendError.html\" title=\"enum tokio::sync::mpsc::error::TrySendError\">TrySendError</a>&lt;T&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Attempts to immediately send a message on this <code>Sender</code></p>\n<p>This method differs from <a href=\"tokio/sync/mpsc/bounded/struct.Sender.html#method.send\" title=\"method tokio::sync::mpsc::bounded::Sender::send\"><code>send</code></a> by returning immediately if the channel’s\nbuffer is full or no receiver is waiting to acquire some data. Compared\nwith <a href=\"tokio/sync/mpsc/bounded/struct.Sender.html#method.send\" title=\"method tokio::sync::mpsc::bounded::Sender::send\"><code>send</code></a>, this function has two failure cases instead of one (one for\ndisconnection, one for a full buffer).</p>\n<h5 id=\"errors-1\"><a class=\"doc-anchor\" href=\"#errors-1\">§</a>Errors</h5>\n<p>If the channel capacity has been reached, i.e., the channel has <code>n</code>\nbuffered values where <code>n</code> is the argument passed to <a href=\"tokio/sync/mpsc/bounded/fn.channel.html\" title=\"fn tokio::sync::mpsc::bounded::channel\"><code>channel</code></a>, then an\nerror is returned.</p>\n<p>If the receive half of the channel is closed, either due to <a href=\"tokio/sync/mpsc/bounded/struct.Receiver.html#method.close\" title=\"method tokio::sync::mpsc::bounded::Receiver::close\"><code>close</code></a>\nbeing called or the <a href=\"tokio/sync/mpsc/bounded/struct.Receiver.html\" title=\"struct tokio::sync::mpsc::bounded::Receiver\"><code>Receiver</code></a> handle dropping, the function returns\nan error. The error includes the value passed to <code>send</code>.</p>\n<h5 id=\"examples-2\"><a class=\"doc-anchor\" href=\"#examples-2\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::mpsc;\n\n<span class=\"attr\">#[tokio::main]\n</span><span class=\"kw\">async fn </span>main() {\n    <span class=\"comment\">// Create a channel with buffer size 1\n    </span><span class=\"kw\">let </span>(tx1, <span class=\"kw-2\">mut </span>rx) = mpsc::channel(<span class=\"number\">1</span>);\n    <span class=\"kw\">let </span>tx2 = tx1.clone();\n\n    tokio::spawn(<span class=\"kw\">async move </span>{\n        tx1.send(<span class=\"number\">1</span>).<span class=\"kw\">await</span>.unwrap();\n        tx1.send(<span class=\"number\">2</span>).<span class=\"kw\">await</span>.unwrap();\n        <span class=\"comment\">// task waits until the receiver receives a value.\n    </span>});\n\n    tokio::spawn(<span class=\"kw\">async move </span>{\n        <span class=\"comment\">// This will return an error and send\n        // no message if the buffer is full\n        </span><span class=\"kw\">let _ </span>= tx2.try_send(<span class=\"number\">3</span>);\n    });\n\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>msg;\n    msg = rx.recv().<span class=\"kw\">await</span>.unwrap();\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"message {} received\"</span>, msg);\n\n    msg = rx.recv().<span class=\"kw\">await</span>.unwrap();\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"message {} received\"</span>, msg);\n\n    <span class=\"comment\">// Third message may have never been sent\n    </span><span class=\"kw\">match </span>rx.recv().<span class=\"kw\">await </span>{\n        <span class=\"prelude-val\">Some</span>(msg) =&gt; <span class=\"macro\">println!</span>(<span class=\"string\">\"message {} received\"</span>, msg),\n        <span class=\"prelude-val\">None </span>=&gt; <span class=\"macro\">println!</span>(<span class=\"string\">\"the third message was never sent\"</span>),\n    }\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.send_timeout\" class=\"method\"><a class=\"src rightside\" href=\"src/tokio/sync/mpsc/bounded.rs.html#982-986\">Source</a><h4 class=\"code-header\">pub async fn <a href=\"tokio/sync/mpsc/bounded/struct.Sender.html#tymethod.send_timeout\" class=\"fn\">send_timeout</a>(\n    &amp;self,\n    value: T,\n    timeout: <a class=\"struct\" href=\"https://doc.rust-lang.org/1.86.0/core/time/struct.Duration.html\" title=\"struct core::time::Duration\">Duration</a>,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.86.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.86.0/std/primitive.unit.html\">()</a>, <a class=\"enum\" href=\"tokio/sync/mpsc/error/enum.SendTimeoutError.html\" title=\"enum tokio::sync::mpsc::error::SendTimeoutError\">SendTimeoutError</a>&lt;T&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Sends a value, waiting until there is capacity, but only for a limited time.</p>\n<p>Shares the same success and error conditions as <a href=\"tokio/sync/mpsc/bounded/struct.Sender.html#method.send\" title=\"method tokio::sync::mpsc::bounded::Sender::send\"><code>send</code></a>, adding one more\ncondition for an unsuccessful send, which is when the provided timeout has\nelapsed, and there is no capacity available.</p>\n<h5 id=\"errors-2\"><a class=\"doc-anchor\" href=\"#errors-2\">§</a>Errors</h5>\n<p>If the receive half of the channel is closed, either due to <a href=\"tokio/sync/mpsc/bounded/struct.Receiver.html#method.close\" title=\"method tokio::sync::mpsc::bounded::Receiver::close\"><code>close</code></a>\nbeing called or the <a href=\"tokio/sync/mpsc/bounded/struct.Receiver.html\" title=\"struct tokio::sync::mpsc::bounded::Receiver\"><code>Receiver</code></a> having been dropped,\nthe function returns an error. The error includes the value passed to <code>send</code>.</p>\n<h5 id=\"panics\"><a class=\"doc-anchor\" href=\"#panics\">§</a>Panics</h5>\n<p>This function panics if it is called outside the context of a Tokio\nruntime <a href=\"tokio/runtime/builder/struct.Builder.html#method.enable_time\" title=\"method tokio::runtime::builder::Builder::enable_time\">with time enabled</a>.</p>\n<h5 id=\"examples-3\"><a class=\"doc-anchor\" href=\"#examples-3\">§</a>Examples</h5>\n<p>In the following example, each call to <code>send_timeout</code> will block until the\npreviously sent value was received, unless the timeout has elapsed.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::mpsc;\n<span class=\"kw\">use </span>tokio::time::{sleep, Duration};\n\n<span class=\"attr\">#[tokio::main]\n</span><span class=\"kw\">async fn </span>main() {\n    <span class=\"kw\">let </span>(tx, <span class=\"kw-2\">mut </span>rx) = mpsc::channel(<span class=\"number\">1</span>);\n\n    tokio::spawn(<span class=\"kw\">async move </span>{\n        <span class=\"kw\">for </span>i <span class=\"kw\">in </span><span class=\"number\">0</span>..<span class=\"number\">10 </span>{\n            <span class=\"kw\">if let </span><span class=\"prelude-val\">Err</span>(e) = tx.send_timeout(i, Duration::from_millis(<span class=\"number\">100</span>)).<span class=\"kw\">await </span>{\n                <span class=\"macro\">println!</span>(<span class=\"string\">\"send error: #{:?}\"</span>, e);\n                <span class=\"kw\">return</span>;\n            }\n        }\n    });\n\n    <span class=\"kw\">while let </span><span class=\"prelude-val\">Some</span>(i) = rx.recv().<span class=\"kw\">await </span>{\n        <span class=\"macro\">println!</span>(<span class=\"string\">\"got = {}\"</span>, i);\n        sleep(Duration::from_millis(<span class=\"number\">200</span>)).<span class=\"kw\">await</span>;\n    }\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.blocking_send\" class=\"method\"><a class=\"src rightside\" href=\"src/tokio/sync/mpsc/bounded.rs.html#1037\">Source</a><h4 class=\"code-header\">pub fn <a href=\"tokio/sync/mpsc/bounded/struct.Sender.html#tymethod.blocking_send\" class=\"fn\">blocking_send</a>(&amp;self, value: T) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.86.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.86.0/std/primitive.unit.html\">()</a>, <a class=\"struct\" href=\"tokio/sync/mpsc/error/struct.SendError.html\" title=\"struct tokio::sync::mpsc::error::SendError\">SendError</a>&lt;T&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Blocking send to call outside of asynchronous contexts.</p>\n<p>This method is intended for use cases where you are sending from\nsynchronous code to asynchronous code, and will work even if the\nreceiver is not using <a href=\"tokio/sync/mpsc/bounded/struct.Receiver.html#method.blocking_recv\" title=\"method tokio::sync::mpsc::bounded::Receiver::blocking_recv\"><code>blocking_recv</code></a> to receive the message.</p>\n<h5 id=\"panics-1\"><a class=\"doc-anchor\" href=\"#panics-1\">§</a>Panics</h5>\n<p>This function panics if called within an asynchronous execution\ncontext.</p>\n<h5 id=\"examples-4\"><a class=\"doc-anchor\" href=\"#examples-4\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::thread;\n<span class=\"kw\">use </span>tokio::runtime::Runtime;\n<span class=\"kw\">use </span>tokio::sync::mpsc;\n\n<span class=\"kw\">fn </span>main() {\n    <span class=\"kw\">let </span>(tx, <span class=\"kw-2\">mut </span>rx) = mpsc::channel::&lt;u8&gt;(<span class=\"number\">1</span>);\n\n    <span class=\"kw\">let </span>sync_code = thread::spawn(<span class=\"kw\">move </span>|| {\n        tx.blocking_send(<span class=\"number\">10</span>).unwrap();\n    });\n\n    Runtime::new().unwrap().block_on(<span class=\"kw\">async move </span>{\n        <span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"number\">10</span>), rx.recv().<span class=\"kw\">await</span>);\n    });\n    sync_code.join().unwrap()\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.is_closed\" class=\"method\"><a class=\"src rightside\" href=\"src/tokio/sync/mpsc/bounded.rs.html#1059\">Source</a><h4 class=\"code-header\">pub fn <a href=\"tokio/sync/mpsc/bounded/struct.Sender.html#tymethod.is_closed\" class=\"fn\">is_closed</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.86.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Checks if the channel has been closed. This happens when the\n<a href=\"tokio/sync/mpsc/bounded/struct.Receiver.html\" title=\"struct tokio::sync::mpsc::bounded::Receiver\"><code>Receiver</code></a> is dropped, or when the <a href=\"tokio/sync/mpsc/bounded/struct.Receiver.html#method.close\" title=\"method tokio::sync::mpsc::bounded::Receiver::close\"><code>Receiver::close</code></a> method is\ncalled.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>(tx, rx) = tokio::sync::mpsc::channel::&lt;()&gt;(<span class=\"number\">42</span>);\n<span class=\"macro\">assert!</span>(!tx.is_closed());\n\n<span class=\"kw\">let </span>tx2 = tx.clone();\n<span class=\"macro\">assert!</span>(!tx2.is_closed());\n\ndrop(rx);\n<span class=\"macro\">assert!</span>(tx.is_closed());\n<span class=\"macro\">assert!</span>(tx2.is_closed());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.reserve\" class=\"method\"><a class=\"src rightside\" href=\"src/tokio/sync/mpsc/bounded.rs.html#1107\">Source</a><h4 class=\"code-header\">pub async fn <a href=\"tokio/sync/mpsc/bounded/struct.Sender.html#tymethod.reserve\" class=\"fn\">reserve</a>(&amp;self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.86.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"tokio/sync/mpsc/bounded/struct.Permit.html\" title=\"struct tokio::sync::mpsc::bounded::Permit\">Permit</a>&lt;'_, T&gt;, <a class=\"struct\" href=\"tokio/sync/mpsc/error/struct.SendError.html\" title=\"struct tokio::sync::mpsc::error::SendError\">SendError</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.86.0/std/primitive.unit.html\">()</a>&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Waits for channel capacity. Once capacity to send one message is\navailable, it is reserved for the caller.</p>\n<p>If the channel is full, the function waits for the number of unreceived\nmessages to become less than the channel capacity. Capacity to send one\nmessage is reserved for the caller. A <a href=\"tokio/sync/mpsc/bounded/struct.Permit.html\" title=\"struct tokio::sync::mpsc::bounded::Permit\"><code>Permit</code></a> is returned to track\nthe reserved capacity. The <a href=\"tokio/sync/mpsc/bounded/struct.Permit.html#method.send\" title=\"method tokio::sync::mpsc::bounded::Permit::send\"><code>send</code></a> function on <a href=\"tokio/sync/mpsc/bounded/struct.Permit.html\" title=\"struct tokio::sync::mpsc::bounded::Permit\"><code>Permit</code></a> consumes the\nreserved capacity.</p>\n<p>Dropping <a href=\"tokio/sync/mpsc/bounded/struct.Permit.html\" title=\"struct tokio::sync::mpsc::bounded::Permit\"><code>Permit</code></a> without sending a message releases the capacity back\nto the channel.</p>\n<h5 id=\"cancel-safety-2\"><a class=\"doc-anchor\" href=\"#cancel-safety-2\">§</a>Cancel safety</h5>\n<p>This channel uses a queue to ensure that calls to <code>send</code> and <code>reserve</code>\ncomplete in the order they were requested.  Cancelling a call to\n<code>reserve</code> makes you lose your place in the queue.</p>\n<h5 id=\"examples-5\"><a class=\"doc-anchor\" href=\"#examples-5\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::mpsc;\n\n<span class=\"attr\">#[tokio::main]\n</span><span class=\"kw\">async fn </span>main() {\n    <span class=\"kw\">let </span>(tx, <span class=\"kw-2\">mut </span>rx) = mpsc::channel(<span class=\"number\">1</span>);\n\n    <span class=\"comment\">// Reserve capacity\n    </span><span class=\"kw\">let </span>permit = tx.reserve().<span class=\"kw\">await</span>.unwrap();\n\n    <span class=\"comment\">// Trying to send directly on the `tx` will fail due to no\n    // available capacity.\n    </span><span class=\"macro\">assert!</span>(tx.try_send(<span class=\"number\">123</span>).is_err());\n\n    <span class=\"comment\">// Sending on the permit succeeds\n    </span>permit.send(<span class=\"number\">456</span>);\n\n    <span class=\"comment\">// The value sent on the permit is received\n    </span><span class=\"macro\">assert_eq!</span>(rx.recv().<span class=\"kw\">await</span>.unwrap(), <span class=\"number\">456</span>);\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.reserve_many\" class=\"method\"><a class=\"src rightside\" href=\"src/tokio/sync/mpsc/bounded.rs.html#1168\">Source</a><h4 class=\"code-header\">pub async fn <a href=\"tokio/sync/mpsc/bounded/struct.Sender.html#tymethod.reserve_many\" class=\"fn\">reserve_many</a>(\n    &amp;self,\n    n: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.86.0/std/primitive.usize.html\">usize</a>,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.86.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"tokio/sync/mpsc/bounded/struct.PermitIterator.html\" title=\"struct tokio::sync::mpsc::bounded::PermitIterator\">PermitIterator</a>&lt;'_, T&gt;, <a class=\"struct\" href=\"tokio/sync/mpsc/error/struct.SendError.html\" title=\"struct tokio::sync::mpsc::error::SendError\">SendError</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.86.0/std/primitive.unit.html\">()</a>&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Waits for channel capacity. Once capacity to send <code>n</code> messages is\navailable, it is reserved for the caller.</p>\n<p>If the channel is full or if there are fewer than <code>n</code> permits available, the function waits\nfor the number of unreceived messages to become <code>n</code> less than the channel capacity.\nCapacity to send <code>n</code> message is then reserved for the caller.</p>\n<p>A <a href=\"tokio/sync/mpsc/bounded/struct.PermitIterator.html\" title=\"struct tokio::sync::mpsc::bounded::PermitIterator\"><code>PermitIterator</code></a> is returned to track the reserved capacity.\nYou can call this <a href=\"https://doc.rust-lang.org/1.86.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\"><code>Iterator</code></a> until it is exhausted to\nget a <a href=\"tokio/sync/mpsc/bounded/struct.Permit.html\" title=\"struct tokio::sync::mpsc::bounded::Permit\"><code>Permit</code></a> and then call <a href=\"tokio/sync/mpsc/bounded/struct.Permit.html#method.send\" title=\"method tokio::sync::mpsc::bounded::Permit::send\"><code>Permit::send</code></a>. This function is similar to\n<a href=\"tokio/sync/mpsc/bounded/struct.Sender.html#method.try_reserve_many\" title=\"method tokio::sync::mpsc::bounded::Sender::try_reserve_many\"><code>try_reserve_many</code></a> except it awaits for the slots to become available.</p>\n<p>If the channel is closed, the function returns a <a href=\"tokio/sync/mpsc/error/struct.SendError.html\" title=\"struct tokio::sync::mpsc::error::SendError\"><code>SendError</code></a>.</p>\n<p>Dropping <a href=\"tokio/sync/mpsc/bounded/struct.PermitIterator.html\" title=\"struct tokio::sync::mpsc::bounded::PermitIterator\"><code>PermitIterator</code></a> without consuming it entirely releases the remaining\npermits back to the channel.</p>\n<h5 id=\"cancel-safety-3\"><a class=\"doc-anchor\" href=\"#cancel-safety-3\">§</a>Cancel safety</h5>\n<p>This channel uses a queue to ensure that calls to <code>send</code> and <code>reserve_many</code>\ncomplete in the order they were requested. Cancelling a call to\n<code>reserve_many</code> makes you lose your place in the queue.</p>\n<h5 id=\"examples-6\"><a class=\"doc-anchor\" href=\"#examples-6\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::mpsc;\n\n<span class=\"attr\">#[tokio::main]\n</span><span class=\"kw\">async fn </span>main() {\n    <span class=\"kw\">let </span>(tx, <span class=\"kw-2\">mut </span>rx) = mpsc::channel(<span class=\"number\">2</span>);\n\n    <span class=\"comment\">// Reserve capacity\n    </span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>permit = tx.reserve_many(<span class=\"number\">2</span>).<span class=\"kw\">await</span>.unwrap();\n\n    <span class=\"comment\">// Trying to send directly on the `tx` will fail due to no\n    // available capacity.\n    </span><span class=\"macro\">assert!</span>(tx.try_send(<span class=\"number\">123</span>).is_err());\n\n    <span class=\"comment\">// Sending with the permit iterator succeeds\n    </span>permit.next().unwrap().send(<span class=\"number\">456</span>);\n    permit.next().unwrap().send(<span class=\"number\">457</span>);\n\n    <span class=\"comment\">// The iterator should now be exhausted\n    </span><span class=\"macro\">assert!</span>(permit.next().is_none());\n\n    <span class=\"comment\">// The value sent on the permit is received\n    </span><span class=\"macro\">assert_eq!</span>(rx.recv().<span class=\"kw\">await</span>.unwrap(), <span class=\"number\">456</span>);\n    <span class=\"macro\">assert_eq!</span>(rx.recv().<span class=\"kw\">await</span>.unwrap(), <span class=\"number\">457</span>);\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.reserve_owned\" class=\"method\"><a class=\"src rightside\" href=\"src/tokio/sync/mpsc/bounded.rs.html#1256\">Source</a><h4 class=\"code-header\">pub async fn <a href=\"tokio/sync/mpsc/bounded/struct.Sender.html#tymethod.reserve_owned\" class=\"fn\">reserve_owned</a>(self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.86.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"tokio/sync/mpsc/bounded/struct.OwnedPermit.html\" title=\"struct tokio::sync::mpsc::bounded::OwnedPermit\">OwnedPermit</a>&lt;T&gt;, <a class=\"struct\" href=\"tokio/sync/mpsc/error/struct.SendError.html\" title=\"struct tokio::sync::mpsc::error::SendError\">SendError</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.86.0/std/primitive.unit.html\">()</a>&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Waits for channel capacity, moving the <code>Sender</code> and returning an owned\npermit. Once capacity to send one message is available, it is reserved\nfor the caller.</p>\n<p>This moves the sender <em>by value</em>, and returns an owned permit that can\nbe used to send a message into the channel. Unlike <a href=\"tokio/sync/mpsc/bounded/struct.Sender.html#method.reserve\" title=\"method tokio::sync::mpsc::bounded::Sender::reserve\"><code>Sender::reserve</code></a>,\nthis method may be used in cases where the permit must be valid for the\n<code>'static</code> lifetime. <code>Sender</code>s may be cloned cheaply (<code>Sender::clone</code> is\nessentially a reference count increment, comparable to <a href=\"https://doc.rust-lang.org/1.86.0/alloc/sync/struct.Arc.html#method.clone\" title=\"method alloc::sync::Arc::clone\"><code>Arc::clone</code></a>),\nso when multiple <a href=\"tokio/sync/mpsc/bounded/struct.OwnedPermit.html\" title=\"struct tokio::sync::mpsc::bounded::OwnedPermit\"><code>OwnedPermit</code></a>s are needed or the <code>Sender</code> cannot be\nmoved, it can be cloned prior to calling <code>reserve_owned</code>.</p>\n<p>If the channel is full, the function waits for the number of unreceived\nmessages to become less than the channel capacity. Capacity to send one\nmessage is reserved for the caller. An <a href=\"tokio/sync/mpsc/bounded/struct.OwnedPermit.html\" title=\"struct tokio::sync::mpsc::bounded::OwnedPermit\"><code>OwnedPermit</code></a> is returned to\ntrack the reserved capacity. The <a href=\"tokio/sync/mpsc/bounded/struct.OwnedPermit.html#method.send\" title=\"method tokio::sync::mpsc::bounded::OwnedPermit::send\"><code>send</code></a> function on <a href=\"tokio/sync/mpsc/bounded/struct.OwnedPermit.html\" title=\"struct tokio::sync::mpsc::bounded::OwnedPermit\"><code>OwnedPermit</code></a>\nconsumes the reserved capacity.</p>\n<p>Dropping the <a href=\"tokio/sync/mpsc/bounded/struct.OwnedPermit.html\" title=\"struct tokio::sync::mpsc::bounded::OwnedPermit\"><code>OwnedPermit</code></a> without sending a message releases the\ncapacity back to the channel.</p>\n<h5 id=\"cancel-safety-4\"><a class=\"doc-anchor\" href=\"#cancel-safety-4\">§</a>Cancel safety</h5>\n<p>This channel uses a queue to ensure that calls to <code>send</code> and <code>reserve</code>\ncomplete in the order they were requested.  Cancelling a call to\n<code>reserve_owned</code> makes you lose your place in the queue.</p>\n<h5 id=\"examples-7\"><a class=\"doc-anchor\" href=\"#examples-7\">§</a>Examples</h5>\n<p>Sending a message using an <a href=\"tokio/sync/mpsc/bounded/struct.OwnedPermit.html\" title=\"struct tokio::sync::mpsc::bounded::OwnedPermit\"><code>OwnedPermit</code></a>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::mpsc;\n\n<span class=\"attr\">#[tokio::main]\n</span><span class=\"kw\">async fn </span>main() {\n    <span class=\"kw\">let </span>(tx, <span class=\"kw-2\">mut </span>rx) = mpsc::channel(<span class=\"number\">1</span>);\n\n    <span class=\"comment\">// Reserve capacity, moving the sender.\n    </span><span class=\"kw\">let </span>permit = tx.reserve_owned().<span class=\"kw\">await</span>.unwrap();\n\n    <span class=\"comment\">// Send a message, consuming the permit and returning\n    // the moved sender.\n    </span><span class=\"kw\">let </span>tx = permit.send(<span class=\"number\">123</span>);\n\n    <span class=\"comment\">// The value sent on the permit is received.\n    </span><span class=\"macro\">assert_eq!</span>(rx.recv().<span class=\"kw\">await</span>.unwrap(), <span class=\"number\">123</span>);\n\n    <span class=\"comment\">// The sender can now be used again.\n    </span>tx.send(<span class=\"number\">456</span>).<span class=\"kw\">await</span>.unwrap();\n}</code></pre></div>\n<p>When multiple <a href=\"tokio/sync/mpsc/bounded/struct.OwnedPermit.html\" title=\"struct tokio::sync::mpsc::bounded::OwnedPermit\"><code>OwnedPermit</code></a>s are needed, or the sender cannot be moved\nby value, it can be inexpensively cloned before calling <code>reserve_owned</code>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::mpsc;\n\n<span class=\"attr\">#[tokio::main]\n</span><span class=\"kw\">async fn </span>main() {\n    <span class=\"kw\">let </span>(tx, <span class=\"kw-2\">mut </span>rx) = mpsc::channel(<span class=\"number\">1</span>);\n\n    <span class=\"comment\">// Clone the sender and reserve capacity.\n    </span><span class=\"kw\">let </span>permit = tx.clone().reserve_owned().<span class=\"kw\">await</span>.unwrap();\n\n    <span class=\"comment\">// Trying to send directly on the `tx` will fail due to no\n    // available capacity.\n    </span><span class=\"macro\">assert!</span>(tx.try_send(<span class=\"number\">123</span>).is_err());\n\n    <span class=\"comment\">// Sending on the permit succeeds.\n    </span>permit.send(<span class=\"number\">456</span>);\n\n    <span class=\"comment\">// The value sent on the permit is received\n    </span><span class=\"macro\">assert_eq!</span>(rx.recv().<span class=\"kw\">await</span>.unwrap(), <span class=\"number\">456</span>);\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_reserve\" class=\"method\"><a class=\"src rightside\" href=\"src/tokio/sync/mpsc/bounded.rs.html#1318\">Source</a><h4 class=\"code-header\">pub fn <a href=\"tokio/sync/mpsc/bounded/struct.Sender.html#tymethod.try_reserve\" class=\"fn\">try_reserve</a>(&amp;self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.86.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"tokio/sync/mpsc/bounded/struct.Permit.html\" title=\"struct tokio::sync::mpsc::bounded::Permit\">Permit</a>&lt;'_, T&gt;, <a class=\"enum\" href=\"tokio/sync/mpsc/error/enum.TrySendError.html\" title=\"enum tokio::sync::mpsc::error::TrySendError\">TrySendError</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.86.0/std/primitive.unit.html\">()</a>&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Tries to acquire a slot in the channel without waiting for the slot to become\navailable.</p>\n<p>If the channel is full this function will return <a href=\"tokio/sync/mpsc/error/enum.TrySendError.html\" title=\"enum tokio::sync::mpsc::error::TrySendError\"><code>TrySendError</code></a>, otherwise\nif there is a slot available it will return a <a href=\"tokio/sync/mpsc/bounded/struct.Permit.html\" title=\"struct tokio::sync::mpsc::bounded::Permit\"><code>Permit</code></a> that will then allow you\nto <a href=\"tokio/sync/mpsc/bounded/struct.Permit.html#method.send\" title=\"method tokio::sync::mpsc::bounded::Permit::send\"><code>send</code></a> on the channel with a guaranteed slot. This function is similar to\n<a href=\"tokio/sync/mpsc/bounded/struct.Sender.html#method.reserve\" title=\"method tokio::sync::mpsc::bounded::Sender::reserve\"><code>reserve</code></a> except it does not await for the slot to become available.</p>\n<p>Dropping <a href=\"tokio/sync/mpsc/bounded/struct.Permit.html\" title=\"struct tokio::sync::mpsc::bounded::Permit\"><code>Permit</code></a> without sending a message releases the capacity back\nto the channel.</p>\n<h5 id=\"examples-8\"><a class=\"doc-anchor\" href=\"#examples-8\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::mpsc;\n\n<span class=\"attr\">#[tokio::main]\n</span><span class=\"kw\">async fn </span>main() {\n    <span class=\"kw\">let </span>(tx, <span class=\"kw-2\">mut </span>rx) = mpsc::channel(<span class=\"number\">1</span>);\n\n    <span class=\"comment\">// Reserve capacity\n    </span><span class=\"kw\">let </span>permit = tx.try_reserve().unwrap();\n\n    <span class=\"comment\">// Trying to send directly on the `tx` will fail due to no\n    // available capacity.\n    </span><span class=\"macro\">assert!</span>(tx.try_send(<span class=\"number\">123</span>).is_err());\n\n    <span class=\"comment\">// Trying to reserve an additional slot on the `tx` will\n    // fail because there is no capacity.\n    </span><span class=\"macro\">assert!</span>(tx.try_reserve().is_err());\n\n    <span class=\"comment\">// Sending on the permit succeeds\n    </span>permit.send(<span class=\"number\">456</span>);\n\n    <span class=\"comment\">// The value sent on the permit is received\n    </span><span class=\"macro\">assert_eq!</span>(rx.recv().<span class=\"kw\">await</span>.unwrap(), <span class=\"number\">456</span>);\n\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_reserve_many\" class=\"method\"><a class=\"src rightside\" href=\"src/tokio/sync/mpsc/bounded.rs.html#1396\">Source</a><h4 class=\"code-header\">pub fn <a href=\"tokio/sync/mpsc/bounded/struct.Sender.html#tymethod.try_reserve_many\" class=\"fn\">try_reserve_many</a>(\n    &amp;self,\n    n: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.86.0/std/primitive.usize.html\">usize</a>,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.86.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"tokio/sync/mpsc/bounded/struct.PermitIterator.html\" title=\"struct tokio::sync::mpsc::bounded::PermitIterator\">PermitIterator</a>&lt;'_, T&gt;, <a class=\"enum\" href=\"tokio/sync/mpsc/error/enum.TrySendError.html\" title=\"enum tokio::sync::mpsc::error::TrySendError\">TrySendError</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.86.0/std/primitive.unit.html\">()</a>&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Tries to acquire <code>n</code> slots in the channel without waiting for the slot to become\navailable.</p>\n<p>A <a href=\"tokio/sync/mpsc/bounded/struct.PermitIterator.html\" title=\"struct tokio::sync::mpsc::bounded::PermitIterator\"><code>PermitIterator</code></a> is returned to track the reserved capacity.\nYou can call this <a href=\"https://doc.rust-lang.org/1.86.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\"><code>Iterator</code></a> until it is exhausted to\nget a <a href=\"tokio/sync/mpsc/bounded/struct.Permit.html\" title=\"struct tokio::sync::mpsc::bounded::Permit\"><code>Permit</code></a> and then call <a href=\"tokio/sync/mpsc/bounded/struct.Permit.html#method.send\" title=\"method tokio::sync::mpsc::bounded::Permit::send\"><code>Permit::send</code></a>. This function is similar to\n<a href=\"tokio/sync/mpsc/bounded/struct.Sender.html#method.reserve_many\" title=\"method tokio::sync::mpsc::bounded::Sender::reserve_many\"><code>reserve_many</code></a> except it does not await for the slots to become available.</p>\n<p>If there are fewer than <code>n</code> permits available on the channel, then\nthis function will return a <a href=\"tokio/sync/mpsc/error/enum.TrySendError.html#variant.Full\" title=\"variant tokio::sync::mpsc::error::TrySendError::Full\"><code>TrySendError::Full</code></a>. If the channel is closed\nthis function will return a <a href=\"tokio/sync/mpsc/error/enum.TrySendError.html#variant.Closed\" title=\"variant tokio::sync::mpsc::error::TrySendError::Closed\"><code>TrySendError::Closed</code></a>.</p>\n<p>Dropping <a href=\"tokio/sync/mpsc/bounded/struct.PermitIterator.html\" title=\"struct tokio::sync::mpsc::bounded::PermitIterator\"><code>PermitIterator</code></a> without consuming it entirely releases the remaining\npermits back to the channel.</p>\n<h5 id=\"examples-9\"><a class=\"doc-anchor\" href=\"#examples-9\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::mpsc;\n\n<span class=\"attr\">#[tokio::main]\n</span><span class=\"kw\">async fn </span>main() {\n    <span class=\"kw\">let </span>(tx, <span class=\"kw-2\">mut </span>rx) = mpsc::channel(<span class=\"number\">2</span>);\n\n    <span class=\"comment\">// Reserve capacity\n    </span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>permit = tx.try_reserve_many(<span class=\"number\">2</span>).unwrap();\n\n    <span class=\"comment\">// Trying to send directly on the `tx` will fail due to no\n    // available capacity.\n    </span><span class=\"macro\">assert!</span>(tx.try_send(<span class=\"number\">123</span>).is_err());\n\n    <span class=\"comment\">// Trying to reserve an additional slot on the `tx` will\n    // fail because there is no capacity.\n    </span><span class=\"macro\">assert!</span>(tx.try_reserve().is_err());\n\n    <span class=\"comment\">// Sending with the permit iterator succeeds\n    </span>permit.next().unwrap().send(<span class=\"number\">456</span>);\n    permit.next().unwrap().send(<span class=\"number\">457</span>);\n\n    <span class=\"comment\">// The iterator should now be exhausted\n    </span><span class=\"macro\">assert!</span>(permit.next().is_none());\n\n    <span class=\"comment\">// The value sent on the permit is received\n    </span><span class=\"macro\">assert_eq!</span>(rx.recv().<span class=\"kw\">await</span>.unwrap(), <span class=\"number\">456</span>);\n    <span class=\"macro\">assert_eq!</span>(rx.recv().<span class=\"kw\">await</span>.unwrap(), <span class=\"number\">457</span>);\n\n    <span class=\"comment\">// Trying to call try_reserve_many with 0 will return an empty iterator\n    </span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>permit = tx.try_reserve_many(<span class=\"number\">0</span>).unwrap();\n    <span class=\"macro\">assert!</span>(permit.next().is_none());\n\n    <span class=\"comment\">// Trying to call try_reserve_many with a number greater than the channel\n    // capacity will return an error\n    </span><span class=\"kw\">let </span>permit = tx.try_reserve_many(<span class=\"number\">3</span>);\n    <span class=\"macro\">assert!</span>(permit.is_err());\n\n    <span class=\"comment\">// Trying to call try_reserve_many on a closed channel will return an error\n    </span>drop(rx);\n    <span class=\"kw\">let </span>permit = tx.try_reserve_many(<span class=\"number\">1</span>);\n    <span class=\"macro\">assert!</span>(permit.is_err());\n\n    <span class=\"kw\">let </span>permit = tx.try_reserve_many(<span class=\"number\">0</span>);\n    <span class=\"macro\">assert!</span>(permit.is_err());\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_reserve_owned\" class=\"method\"><a class=\"src rightside\" href=\"src/tokio/sync/mpsc/bounded.rs.html#1468\">Source</a><h4 class=\"code-header\">pub fn <a href=\"tokio/sync/mpsc/bounded/struct.Sender.html#tymethod.try_reserve_owned\" class=\"fn\">try_reserve_owned</a>(\n    self,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.86.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"tokio/sync/mpsc/bounded/struct.OwnedPermit.html\" title=\"struct tokio::sync::mpsc::bounded::OwnedPermit\">OwnedPermit</a>&lt;T&gt;, <a class=\"enum\" href=\"tokio/sync/mpsc/error/enum.TrySendError.html\" title=\"enum tokio::sync::mpsc::error::TrySendError\">TrySendError</a>&lt;<a class=\"struct\" href=\"tokio/sync/mpsc/bounded/struct.Sender.html\" title=\"struct tokio::sync::mpsc::bounded::Sender\">Sender</a>&lt;T&gt;&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Tries to acquire a slot in the channel without waiting for the slot to become\navailable, returning an owned permit.</p>\n<p>This moves the sender <em>by value</em>, and returns an owned permit that can\nbe used to send a message into the channel. Unlike <a href=\"tokio/sync/mpsc/bounded/struct.Sender.html#method.try_reserve\" title=\"method tokio::sync::mpsc::bounded::Sender::try_reserve\"><code>Sender::try_reserve</code></a>,\nthis method may be used in cases where the permit must be valid for the\n<code>'static</code> lifetime.  <code>Sender</code>s may be cloned cheaply (<code>Sender::clone</code> is\nessentially a reference count increment, comparable to <a href=\"https://doc.rust-lang.org/1.86.0/alloc/sync/struct.Arc.html#method.clone\" title=\"method alloc::sync::Arc::clone\"><code>Arc::clone</code></a>),\nso when multiple <a href=\"tokio/sync/mpsc/bounded/struct.OwnedPermit.html\" title=\"struct tokio::sync::mpsc::bounded::OwnedPermit\"><code>OwnedPermit</code></a>s are needed or the <code>Sender</code> cannot be\nmoved, it can be cloned prior to calling <code>try_reserve_owned</code>.</p>\n<p>If the channel is full this function will return a <a href=\"tokio/sync/mpsc/error/enum.TrySendError.html\" title=\"enum tokio::sync::mpsc::error::TrySendError\"><code>TrySendError</code></a>.\nSince the sender is taken by value, the <code>TrySendError</code> returned in this\ncase contains the sender, so that it may be used again. Otherwise, if\nthere is a slot available, this method will return an <a href=\"tokio/sync/mpsc/bounded/struct.OwnedPermit.html\" title=\"struct tokio::sync::mpsc::bounded::OwnedPermit\"><code>OwnedPermit</code></a>\nthat can then be used to <a href=\"tokio/sync/mpsc/bounded/struct.OwnedPermit.html#method.send\" title=\"method tokio::sync::mpsc::bounded::OwnedPermit::send\"><code>send</code></a> on the channel with a guaranteed slot.\nThis function is similar to  <a href=\"tokio/sync/mpsc/bounded/struct.Sender.html#method.reserve_owned\" title=\"method tokio::sync::mpsc::bounded::Sender::reserve_owned\"><code>reserve_owned</code></a> except it does not await\nfor the slot to become available.</p>\n<p>Dropping the <a href=\"tokio/sync/mpsc/bounded/struct.OwnedPermit.html\" title=\"struct tokio::sync::mpsc::bounded::OwnedPermit\"><code>OwnedPermit</code></a> without sending a message releases the capacity back\nto the channel.</p>\n<h5 id=\"examples-10\"><a class=\"doc-anchor\" href=\"#examples-10\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::mpsc;\n\n<span class=\"attr\">#[tokio::main]\n</span><span class=\"kw\">async fn </span>main() {\n    <span class=\"kw\">let </span>(tx, <span class=\"kw-2\">mut </span>rx) = mpsc::channel(<span class=\"number\">1</span>);\n\n    <span class=\"comment\">// Reserve capacity\n    </span><span class=\"kw\">let </span>permit = tx.clone().try_reserve_owned().unwrap();\n\n    <span class=\"comment\">// Trying to send directly on the `tx` will fail due to no\n    // available capacity.\n    </span><span class=\"macro\">assert!</span>(tx.try_send(<span class=\"number\">123</span>).is_err());\n\n    <span class=\"comment\">// Trying to reserve an additional slot on the `tx` will\n    // fail because there is no capacity.\n    </span><span class=\"macro\">assert!</span>(tx.try_reserve().is_err());\n\n    <span class=\"comment\">// Sending on the permit succeeds\n    </span>permit.send(<span class=\"number\">456</span>);\n\n    <span class=\"comment\">// The value sent on the permit is received\n    </span><span class=\"macro\">assert_eq!</span>(rx.recv().<span class=\"kw\">await</span>.unwrap(), <span class=\"number\">456</span>);\n\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.same_channel\" class=\"method\"><a class=\"src rightside\" href=\"src/tokio/sync/mpsc/bounded.rs.html#1492\">Source</a><h4 class=\"code-header\">pub fn <a href=\"tokio/sync/mpsc/bounded/struct.Sender.html#tymethod.same_channel\" class=\"fn\">same_channel</a>(&amp;self, other: &amp;<a class=\"struct\" href=\"tokio/sync/mpsc/bounded/struct.Sender.html\" title=\"struct tokio::sync::mpsc::bounded::Sender\">Sender</a>&lt;T&gt;) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.86.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Returns <code>true</code> if senders belong to the same channel.</p>\n<h5 id=\"examples-11\"><a class=\"doc-anchor\" href=\"#examples-11\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>(tx, rx) = tokio::sync::mpsc::channel::&lt;()&gt;(<span class=\"number\">1</span>);\n<span class=\"kw\">let  </span>tx2 = tx.clone();\n<span class=\"macro\">assert!</span>(tx.same_channel(<span class=\"kw-2\">&amp;</span>tx2));\n\n<span class=\"kw\">let </span>(tx3, rx3) = tokio::sync::mpsc::channel::&lt;()&gt;(<span class=\"number\">1</span>);\n<span class=\"macro\">assert!</span>(!tx3.same_channel(<span class=\"kw-2\">&amp;</span>tx2));</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.capacity\" class=\"method\"><a class=\"src rightside\" href=\"src/tokio/sync/mpsc/bounded.rs.html#1529\">Source</a><h4 class=\"code-header\">pub fn <a href=\"tokio/sync/mpsc/bounded/struct.Sender.html#tymethod.capacity\" class=\"fn\">capacity</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.86.0/std/primitive.usize.html\">usize</a></h4></section></summary><div class=\"docblock\"><p>Returns the current capacity of the channel.</p>\n<p>The capacity goes down when sending a value by calling <a href=\"tokio/sync/mpsc/bounded/struct.Sender.html#method.send\" title=\"method tokio::sync::mpsc::bounded::Sender::send\"><code>send</code></a> or by reserving capacity\nwith <a href=\"tokio/sync/mpsc/bounded/struct.Sender.html#method.reserve\" title=\"method tokio::sync::mpsc::bounded::Sender::reserve\"><code>reserve</code></a>. The capacity goes up when values are received by the <a href=\"tokio/sync/mpsc/bounded/struct.Receiver.html\" title=\"struct tokio::sync::mpsc::bounded::Receiver\"><code>Receiver</code></a>.\nThis is distinct from <a href=\"tokio/sync/mpsc/bounded/struct.Sender.html#method.max_capacity\" title=\"method tokio::sync::mpsc::bounded::Sender::max_capacity\"><code>max_capacity</code></a>, which always returns buffer capacity initially\nspecified when calling <a href=\"tokio/sync/mpsc/bounded/fn.channel.html\" title=\"fn tokio::sync::mpsc::bounded::channel\"><code>channel</code></a></p>\n<h5 id=\"examples-12\"><a class=\"doc-anchor\" href=\"#examples-12\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::mpsc;\n\n<span class=\"attr\">#[tokio::main]\n</span><span class=\"kw\">async fn </span>main() {\n    <span class=\"kw\">let </span>(tx, <span class=\"kw-2\">mut </span>rx) = mpsc::channel::&lt;()&gt;(<span class=\"number\">5</span>);\n\n    <span class=\"macro\">assert_eq!</span>(tx.capacity(), <span class=\"number\">5</span>);\n\n    <span class=\"comment\">// Making a reservation drops the capacity by one.\n    </span><span class=\"kw\">let </span>permit = tx.reserve().<span class=\"kw\">await</span>.unwrap();\n    <span class=\"macro\">assert_eq!</span>(tx.capacity(), <span class=\"number\">4</span>);\n\n    <span class=\"comment\">// Sending and receiving a value increases the capacity by one.\n    </span>permit.send(());\n    rx.recv().<span class=\"kw\">await</span>.unwrap();\n    <span class=\"macro\">assert_eq!</span>(tx.capacity(), <span class=\"number\">5</span>);\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.downgrade\" class=\"method\"><a class=\"src rightside\" href=\"src/tokio/sync/mpsc/bounded.rs.html#1538\">Source</a><h4 class=\"code-header\">pub fn <a href=\"tokio/sync/mpsc/bounded/struct.Sender.html#tymethod.downgrade\" class=\"fn\">downgrade</a>(&amp;self) -&gt; <a class=\"struct\" href=\"tokio/sync/mpsc/bounded/struct.WeakSender.html\" title=\"struct tokio::sync::mpsc::bounded::WeakSender\">WeakSender</a>&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Converts the <code>Sender</code> to a <a href=\"tokio/sync/mpsc/bounded/struct.WeakSender.html\" title=\"struct tokio::sync::mpsc::bounded::WeakSender\"><code>WeakSender</code></a> that does not count\ntowards RAII semantics, i.e. if all <code>Sender</code> instances of the\nchannel were dropped and only <code>WeakSender</code> instances remain,\nthe channel is closed.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.max_capacity\" class=\"method\"><a class=\"src rightside\" href=\"src/tokio/sync/mpsc/bounded.rs.html#1576\">Source</a><h4 class=\"code-header\">pub fn <a href=\"tokio/sync/mpsc/bounded/struct.Sender.html#tymethod.max_capacity\" class=\"fn\">max_capacity</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.86.0/std/primitive.usize.html\">usize</a></h4></section></summary><div class=\"docblock\"><p>Returns the maximum buffer capacity of the channel.</p>\n<p>The maximum capacity is the buffer capacity initially specified when calling\n<a href=\"tokio/sync/mpsc/bounded/fn.channel.html\" title=\"fn tokio::sync::mpsc::bounded::channel\"><code>channel</code></a>. This is distinct from <a href=\"tokio/sync/mpsc/bounded/struct.Sender.html#method.capacity\" title=\"method tokio::sync::mpsc::bounded::Sender::capacity\"><code>capacity</code></a>, which returns the <em>current</em>\navailable buffer capacity: as messages are sent and received, the\nvalue returned by <a href=\"tokio/sync/mpsc/bounded/struct.Sender.html#method.capacity\" title=\"method tokio::sync::mpsc::bounded::Sender::capacity\"><code>capacity</code></a> will go up or down, whereas the value\nreturned by <a href=\"tokio/sync/mpsc/bounded/struct.Sender.html#method.max_capacity\" title=\"method tokio::sync::mpsc::bounded::Sender::max_capacity\"><code>max_capacity</code></a> will remain constant.</p>\n<h5 id=\"examples-13\"><a class=\"doc-anchor\" href=\"#examples-13\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::mpsc;\n\n<span class=\"attr\">#[tokio::main]\n</span><span class=\"kw\">async fn </span>main() {\n    <span class=\"kw\">let </span>(tx, _rx) = mpsc::channel::&lt;()&gt;(<span class=\"number\">5</span>);\n\n    <span class=\"comment\">// both max capacity and capacity are the same at first\n    </span><span class=\"macro\">assert_eq!</span>(tx.max_capacity(), <span class=\"number\">5</span>);\n    <span class=\"macro\">assert_eq!</span>(tx.capacity(), <span class=\"number\">5</span>);\n\n    <span class=\"comment\">// Making a reservation doesn't change the max capacity.\n    </span><span class=\"kw\">let </span>permit = tx.reserve().<span class=\"kw\">await</span>.unwrap();\n    <span class=\"macro\">assert_eq!</span>(tx.max_capacity(), <span class=\"number\">5</span>);\n    <span class=\"comment\">// but drops the capacity by one\n    </span><span class=\"macro\">assert_eq!</span>(tx.capacity(), <span class=\"number\">4</span>);\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.strong_count\" class=\"method\"><a class=\"src rightside\" href=\"src/tokio/sync/mpsc/bounded.rs.html#1581\">Source</a><h4 class=\"code-header\">pub fn <a href=\"tokio/sync/mpsc/bounded/struct.Sender.html#tymethod.strong_count\" class=\"fn\">strong_count</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.86.0/std/primitive.usize.html\">usize</a></h4></section></summary><div class=\"docblock\"><p>Returns the number of <a href=\"tokio/sync/mpsc/bounded/struct.Sender.html\" title=\"struct tokio::sync::mpsc::bounded::Sender\"><code>Sender</code></a> handles.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.weak_count\" class=\"method\"><a class=\"src rightside\" href=\"src/tokio/sync/mpsc/bounded.rs.html#1586\">Source</a><h4 class=\"code-header\">pub fn <a href=\"tokio/sync/mpsc/bounded/struct.Sender.html#tymethod.weak_count\" class=\"fn\">weak_count</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.86.0/std/primitive.usize.html\">usize</a></h4></section></summary><div class=\"docblock\"><p>Returns the number of <a href=\"tokio/sync/mpsc/bounded/struct.WeakSender.html\" title=\"struct tokio::sync::mpsc::bounded::WeakSender\"><code>WeakSender</code></a> handles.</p>\n</div></details></div></details>",0,"linera_exporter::runloops::indexer::indexer_exporter::CanonicalBlockStream"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-TrySend-for-Sender%3CT%3E\" class=\"impl\"><a class=\"src rightside\" href=\"src/opentelemetry_sdk/runtime.rs.html#190\">Source</a><a href=\"#impl-TrySend-for-Sender%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"opentelemetry_sdk/runtime/trait.TrySend.html\" title=\"trait opentelemetry_sdk::runtime::TrySend\">TrySend</a> for <a class=\"struct\" href=\"tokio/sync/mpsc/bounded/struct.Sender.html\" title=\"struct tokio::sync::mpsc::bounded::Sender\">Sender</a>&lt;T&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.86.0/core/marker/trait.Send.html\" title=\"trait core::marker::Send\">Send</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Message\" class=\"associatedtype trait-impl\"><a class=\"src rightside\" href=\"src/opentelemetry_sdk/runtime.rs.html#191\">Source</a><a href=\"#associatedtype.Message\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"opentelemetry_sdk/runtime/trait.TrySend.html#associatedtype.Message\" class=\"associatedtype\">Message</a> = T</h4></section></summary><div class='docblock'>The message that will be sent.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_send\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"src/opentelemetry_sdk/runtime.rs.html#193\">Source</a><a href=\"#method.try_send\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"opentelemetry_sdk/runtime/trait.TrySend.html#tymethod.try_send\" class=\"fn\">try_send</a>(\n    &amp;self,\n    item: &lt;<a class=\"struct\" href=\"tokio/sync/mpsc/bounded/struct.Sender.html\" title=\"struct tokio::sync::mpsc::bounded::Sender\">Sender</a>&lt;T&gt; as <a class=\"trait\" href=\"opentelemetry_sdk/runtime/trait.TrySend.html\" title=\"trait opentelemetry_sdk::runtime::TrySend\">TrySend</a>&gt;::<a class=\"associatedtype\" href=\"opentelemetry_sdk/runtime/trait.TrySend.html#associatedtype.Message\" title=\"type opentelemetry_sdk::runtime::TrySend::Message\">Message</a>,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.86.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.86.0/std/primitive.unit.html\">()</a>, <a class=\"enum\" href=\"opentelemetry_sdk/runtime/enum.TrySendError.html\" title=\"enum opentelemetry_sdk::runtime::TrySendError\">TrySendError</a>&gt;</h4></section></summary><div class='docblock'>Try to send a message batch to a worker thread. <a href=\"opentelemetry_sdk/runtime/trait.TrySend.html#tymethod.try_send\">Read more</a></div></details></div></details>","TrySend","linera_exporter::runloops::indexer::indexer_exporter::CanonicalBlockStream"]]]]);
    if (window.register_type_impls) {
        window.register_type_impls(type_impls);
    } else {
        window.pending_type_impls = type_impls;
    }
})()
//{"start":55,"fragment_lengths":[63848]}
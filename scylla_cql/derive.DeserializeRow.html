<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Derive macro for the `DeserializeRow` trait that generates an implementation which deserializes a row with a similar layout to the Rust struct."><title>DeserializeRow in scylla_cql - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-6c3ea77c.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="scylla_cql" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0 (05f9846f8 2025-03-31)" data-channel="1.86.0" data-search-js="search-581efc7a.js" data-settings-js="settings-6dad6058.js" ><script src="../static.files/storage-3a5871a4.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-4d63596a.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc derive"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../scylla_cql/index.html">scylla_<wbr>cql</a><span class="version">1.3.1</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Deserialize<wbr>Row</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#example" title="Example">Example</a></li><li><a href="#attributes" title="Attributes">Attributes</a><ul><li><a href="#struct-attributes" title="Struct attributes">Struct attributes</a></li><li><a href="#field-attributes" title="Field attributes">Field attributes</a></li></ul></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate scylla_<wbr>cql</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="index.html">scylla_cql</a></div><h1>Derive Macro <span class="derive">DeserializeRow</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/scylla_macros/lib.rs.html#394">Source</a> </span></div><pre class="rust item-decl"><code>#[derive(DeserializeRow)]
{
    <span class="comment">// Attributes available to this derive:</span>
    #[scylla]
}
</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Derive macro for the <a href="./deserialize/row/trait.DeserializeRow.html"><code>DeserializeRow</code></a>
trait that generates an implementation which deserializes a row with
a similar layout to the Rust struct.</p>
<p>At the moment, only structs with named fields are supported.</p>
<p>This macro properly supports structs with lifetimes, meaning that you can
deserialize columns that borrow memory from the serialized response.</p>
<h2 id="example"><a class="doc-anchor" href="#example">§</a>Example</h2>
<p>Having a table defined like this:</p>
<div class="example-wrap"><pre class="language-text"><code>CREATE TABLE ks.my_table (a PRIMARY KEY, b text, c blob);</code></pre></div>
<p>results of a query “SELECT * FROM ks.my_table”
or “SELECT a, b, c FROM ks.my_table”
can be deserialized using the following struct:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(DeserializeRow)]
</span><span class="kw">struct </span>MyRow&lt;<span class="lifetime">'a</span>&gt; {
    a: i32,
    b: <span class="prelude-ty">Option</span>&lt;String&gt;,
    c: <span class="kw-2">&amp;</span><span class="lifetime">'a </span>[u8],
}</code></pre></div>
<p>In general, the struct must match the queried names and types,
not the table itself. For example, the query
“SELECT a AS b FROM ks.my_table” executed against
the aforementioned table can be deserialized to the struct:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(DeserializeRow)]
</span><span class="kw">struct </span>MyRow {
    b: i32,
}</code></pre></div>
<h2 id="attributes"><a class="doc-anchor" href="#attributes">§</a>Attributes</h2>
<p>The macro supports a number of attributes that customize the generated
implementation. Many of the attributes were inspired by procedural macros
from <code>serde</code> and try to follow the same naming conventions.</p>
<h3 id="struct-attributes"><a class="doc-anchor" href="#struct-attributes">§</a>Struct attributes</h3>
<p><code>#[scylla(crate = "crate_name")]</code></p>
<p>By default, the code generated by the derive macro will refer to the items
defined by the driver (types, traits, etc.) via the <code>::scylla</code> path.
For example, it will refer to the <a href="./deserialize/value/trait.DeserializeValue.html"><code>DeserializeValue</code></a>
trait using the following path:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>::scylla::_macro_internal::DeserializeValue;</code></pre></div>
<p>Most users will simply add <code>scylla</code> to their dependencies, then use
the derive macro and the path above will work. However, there are some
niche cases where this path will <em>not</em> work:</p>
<ul>
<li>The <code>scylla</code> crate is imported under a different name,</li>
<li>The <code>scylla</code> crate is <em>not imported at all</em> - the macro actually
is defined in the <code>scylla-macros</code> crate and the generated code depends
on items defined in <code>scylla-cql</code>.</li>
</ul>
<p>It’s not possible to automatically resolve those issues in the procedural
macro itself, so in those cases the user must provide an alternative path
to either the <code>scylla</code> or <code>scylla-cql</code> crate.</p>
<p><code>#[scylla(flavor = "flavor_name")]</code></p>
<p>Allows to choose one of the possible “flavors”, i.e. the way how the
generated code will approach deserialization. Possible flavors are:</p>
<ul>
<li><code>"match_by_name"</code> (default) - the generated implementation <em>does not
require</em> the fields in the Rust struct to be in the same order as the
columns in the row. During deserialization, the implementation will take
care to deserialize the columns in the order which the database provided.</li>
<li><code>"enforce_order"</code> - the generated implementation <em>requires</em> the fields
in the Rust struct to be in the same order as the columns in the row.
If the order is incorrect, type checking/deserialization will fail.
This is a less robust flavor than <code>"match_by_name"</code>, but should be
slightly more performant as it doesn’t need to perform lookups by name.
The generated code will still check that the column and field names match.</li>
</ul>
<p>#[(scylla(skip_name_checks))]</p>
<p>This attribute only works when used with <code>flavor = "enforce_order"</code>.</p>
<p>If set, the generated implementation will not verify the column names at
all. Because it only works with <code>enforce_order</code>, it will deserialize first
column into the first field, second column into the second field and so on.
It will still still verify that the column types and field types match.</p>
<h3 id="field-attributes"><a class="doc-anchor" href="#field-attributes">§</a>Field attributes</h3>
<p><code>#[scylla(skip)]</code></p>
<p>The field will be completely ignored during deserialization and will
be initialized with <code>Default::default()</code>.</p>
<p><code>#[scylla(rename = "field_name")]</code></p>
<p>By default, the generated implementation will try to match the Rust field
to a column with the same name. This attribute allows to match to a column
with provided name.</p>
</div></details></section></div></main></body></html>
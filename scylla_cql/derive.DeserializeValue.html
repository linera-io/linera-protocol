<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Derive macro for the `DeserializeValue` trait that generates an implementation which deserializes a User Defined Type with the same layout as the Rust struct."><title>DeserializeValue in scylla_cql - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-6c3ea77c.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="scylla_cql" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0 (05f9846f8 2025-03-31)" data-channel="1.86.0" data-search-js="search-581efc7a.js" data-settings-js="settings-6dad6058.js" ><script src="../static.files/storage-3a5871a4.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-4d63596a.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc derive"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../scylla_cql/index.html">scylla_<wbr>cql</a><span class="version">1.3.1</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Deserialize<wbr>Value</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#example" title="Example">Example</a></li><li><a href="#attributes" title="Attributes">Attributes</a><ul><li><a href="#struct-attributes" title="Struct attributes">Struct attributes</a></li><li><a href="#field-attributes" title="Field attributes">Field attributes</a></li></ul></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate scylla_<wbr>cql</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="index.html">scylla_cql</a></div><h1>Derive Macro <span class="derive">DeserializeValue</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/scylla_macros/lib.rs.html#522">Source</a> </span></div><pre class="rust item-decl"><code>#[derive(DeserializeValue)]
{
    <span class="comment">// Attributes available to this derive:</span>
    #[scylla]
}
</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Derive macro for the <a href="./deserialize/value/trait.DeserializeValue.html"><code>DeserializeValue</code></a>
trait that generates an implementation which deserializes a User Defined Type
with the same layout as the Rust struct.</p>
<p>At the moment, only structs with named fields are supported.</p>
<p>This macro properly supports structs with lifetimes, meaning that you can
deserialize UDTs with fields that borrow memory from the serialized response.</p>
<h2 id="example"><a class="doc-anchor" href="#example">§</a>Example</h2>
<p>A UDT defined like this:</p>
<div class="example-wrap"><pre class="language-text"><code>CREATE TYPE ks.my_udt (a i32, b text, c blob);</code></pre></div>
<p>…can be deserialized using the following struct:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(DeserializeValue)]
</span><span class="kw">struct </span>MyUdt&lt;<span class="lifetime">'a</span>&gt; {
    a: i32,
    b: <span class="prelude-ty">Option</span>&lt;String&gt;,
    c: <span class="kw-2">&amp;</span><span class="lifetime">'a </span>[u8],
}</code></pre></div>
<h2 id="attributes"><a class="doc-anchor" href="#attributes">§</a>Attributes</h2>
<p>The macro supports a number of attributes that customize the generated
implementation. Many of the attributes were inspired by procedural macros
from <code>serde</code> and try to follow the same naming conventions.</p>
<h3 id="struct-attributes"><a class="doc-anchor" href="#struct-attributes">§</a>Struct attributes</h3>
<p><code>#[scylla(crate = "crate_name")]</code></p>
<p>By default, the code generated by the derive macro will refer to the items
defined by the driver (types, traits, etc.) via the <code>::scylla</code> path.
For example, it will refer to the <a href="./deserialize/value/trait.DeserializeValue.html"><code>DeserializeValue</code></a>
trait using the following path:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>::scylla::_macro_internal::DeserializeValue;</code></pre></div>
<p>Most users will simply add <code>scylla</code> to their dependencies, then use
the derive macro and the path above will work. However, there are some
niche cases where this path will <em>not</em> work:</p>
<ul>
<li>The <code>scylla</code> crate is imported under a different name,</li>
<li>The <code>scylla</code> crate is <em>not imported at all</em> - the macro actually
is defined in the <code>scylla-macros</code> crate and the generated code depends
on items defined in <code>scylla-cql</code>.</li>
</ul>
<p>It’s not possible to automatically resolve those issues in the procedural
macro itself, so in those cases the user must provide an alternative path
to either the <code>scylla</code> or <code>scylla-cql</code> crate.</p>
<p><code>#[scylla(flavor = "flavor_name")]</code></p>
<p>Allows to choose one of the possible “flavors”, i.e. the way how the
generated code will approach deserialization. Possible flavors are:</p>
<ul>
<li><code>"match_by_name"</code> (default) - the generated implementation <em>does not
require</em> the fields in the Rust struct to be in the same order as the
fields in the UDT. During deserialization, the implementation will take
care to deserialize the fields in the order which the database expects.</li>
<li><code>"enforce_order"</code> - the generated implementation <em>requires</em> the fields
in the Rust struct to be in the same order as the fields in the UDT.
If the order is incorrect, type checking/deserialization will fail.
This is a less robust flavor than <code>"match_by_name"</code>, but should be
slightly more performant as it doesn’t need to perform lookups by name.
The UDT field names will still be checked during the type check phase.</li>
</ul>
<p>#[(scylla(skip_name_checks))]</p>
<p>This attribute only works when used with <code>flavor = "enforce_order"</code>.</p>
<p>If set, the generated implementation will not verify the UDT field names at
all. Because it only works with <code>enforce_order</code>, it will deserialize first
UDT field into the first struct field, second UDT field into the second
struct field and so on. It will still verify that the UDT field types
and struct field types match.</p>
<p>#[(scylla(forbid_excess_udt_fields))]</p>
<p>By default, the generated deserialization code ignores excess UDT fields.
I.e., <code>enforce_order</code> flavour ignores excess UDT fields in the suffix
of the UDT definition, and the default unordered flavour ignores excess
UDT fields anywhere.
If more strictness is desired, this flag makes sure that no excess fields
are present and forces error in case there are some.</p>
<h3 id="field-attributes"><a class="doc-anchor" href="#field-attributes">§</a>Field attributes</h3>
<p><code>#[scylla(skip)]</code></p>
<p>The field will be completely ignored during deserialization and will
be initialized with <code>Default::default()</code>.</p>
<p><code>#[scylla(allow_missing)]</code></p>
<p>If the UDT definition does not contain this field, it will be initialized
with <code>Default::default()</code>.</p>
<p><code>#[scylla(default_when_null)]</code></p>
<p>If the value of the field received from DB is null, the field will be
initialized with <code>Default::default()</code>.</p>
<p><code>#[scylla(rename = "field_name")]</code></p>
<p>By default, the generated implementation will try to match the Rust field
to a UDT field with the same name. This attribute instead allows to match
to a UDT field with provided name.</p>
</div></details></section></div></main></body></html>
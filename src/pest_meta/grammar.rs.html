<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/pest_meta-2.8.1/src/grammar.rs`."><title>grammar.rs - source</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-6c3ea77c.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="pest_meta" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0 (05f9846f8 2025-03-31)" data-channel="1.86.0" data-search-js="search-581efc7a.js" data-settings-js="settings-6dad6058.js" ><script src="../../static.files/storage-3a5871a4.js"></script><script defer src="../../static.files/src-script-b8d3f215.js"></script><script defer src="../../src-files.js"></script><script defer src="../../static.files/main-4d63596a.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="icon" href="https://raw.githubusercontent.com/pest-parser/pest/master/pest-logo.svg"></head><body class="rustdoc src"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="src-sidebar-title"><h2>Files</h2></div></nav><div class="sidebar-resizer"></div><main><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1><div class="sub-heading">pest_meta/</div>grammar.rs</h1><rustdoc-toolbar></rustdoc-toolbar></div><div class="example-wrap digits-1"><pre class="rust"><code><a href=#1 id=1 data-nosnippet>1</a><span class="kw">pub struct </span>PestParser;
<a href=#2 id=2 data-nosnippet>2</a># [doc = <span class="string">"Pest meta-grammar\n\n# Warning: Semantic Versioning\nThere may be non-breaking changes to the meta-grammar\nbetween minor versions. Those non-breaking changes, however,\nmay translate into semver-breaking changes due to the additional variants\nadded to the `Rule` enum. This is a known issue and will be fixed in the\nfuture (e.g. by increasing MSRV and non_exhaustive annotations)."</span>] # [allow (dead_code , non_camel_case_types , clippy :: upper_case_acronyms)] # [derive (Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] <span class="kw">pub enum </span>Rule { # [doc = <span class="string">"End-of-input"</span>] EOI , # [doc = <span class="string">"The top-level rule of a grammar."</span>] r#grammar_rules , # [doc = <span class="string">"A rule of a grammar."</span>] r#grammar_rule , # [doc = <span class="string">"Assignment operator."</span>] r#assignment_operator , # [doc = <span class="string">"Opening brace for a rule."</span>] r#opening_brace , # [doc = <span class="string">"Closing brace for a rule."</span>] r#closing_brace , # [doc = <span class="string">"Opening parenthesis for a branch, PUSH, etc."</span>] r#opening_paren , # [doc = <span class="string">"Closing parenthesis for a branch, PUSH, etc."</span>] r#closing_paren , # [doc = <span class="string">"Opening bracket for PEEK (slice inside)."</span>] r#opening_brack , # [doc = <span class="string">"Closing bracket for PEEK (slice inside)."</span>] r#closing_brack , # [doc = <span class="string">"A rule modifier."</span>] r#modifier , # [doc = <span class="string">"Silent rule prefix."</span>] r#silent_modifier , # [doc = <span class="string">"Atomic rule prefix."</span>] r#atomic_modifier , # [doc = <span class="string">"Compound atomic rule prefix."</span>] r#compound_atomic_modifier , # [doc = <span class="string">"Non-atomic rule prefix."</span>] r#non_atomic_modifier , # [doc = <span class="string">"A tag label."</span>] r#tag_id , # [doc = <span class="string">"For assigning labels to nodes."</span>] r#node_tag , # [doc = <span class="string">"A rule expression."</span>] r#expression , # [doc = <span class="string">"A rule term."</span>] r#term , # [doc = <span class="string">"A rule node (inside terms)."</span>] r#node , # [doc = <span class="string">"A terminal expression."</span>] r#terminal , # [doc = <span class="string">"Possible predicates for a rule."</span>] r#prefix_operator , # [doc = <span class="string">"Branches or sequences."</span>] r#infix_operator , # [doc = <span class="string">"Possible modifiers for a rule."</span>] r#postfix_operator , # [doc = <span class="string">"A positive predicate."</span>] r#positive_predicate_operator , # [doc = <span class="string">"A negative predicate."</span>] r#negative_predicate_operator , # [doc = <span class="string">"A sequence operator."</span>] r#sequence_operator , # [doc = <span class="string">"A choice operator."</span>] r#choice_operator , # [doc = <span class="string">"An optional operator."</span>] r#optional_operator , # [doc = <span class="string">"A repeat operator."</span>] r#repeat_operator , # [doc = <span class="string">"A repeat at least once operator."</span>] r#repeat_once_operator , # [doc = <span class="string">"A repeat exact times."</span>] r#repeat_exact , # [doc = <span class="string">"A repeat at least times."</span>] r#repeat_min , # [doc = <span class="string">"A repeat at most times."</span>] r#repeat_max , # [doc = <span class="string">"A repeat in a range."</span>] r#repeat_min_max , # [doc = <span class="string">"A number."</span>] r#number , # [doc = <span class="string">"An integer number (positive or negative)."</span>] r#integer , # [doc = <span class="string">"A comma terminal."</span>] r#comma , # [doc = <span class="string">"A PUSH expression."</span>] r#_push , # [doc = <span class="string">"A PUSH_LITERAL expression with one argument, which must be a literal string."</span>] r#_push_literal , # [doc = <span class="string">"A PEEK expression."</span>] r#peek_slice , # [doc = <span class="string">"An identifier."</span>] r#identifier , # [doc = <span class="string">"An alpha character."</span>] r#alpha , # [doc = <span class="string">"An alphanumeric character."</span>] r#alpha_num , # [doc = <span class="string">"A string."</span>] r#string , # [doc = <span class="string">"An insensitive string."</span>] r#insensitive_string , # [doc = <span class="string">"A character range."</span>] r#range , # [doc = <span class="string">"A single quoted character"</span>] r#character , # [doc = <span class="string">"A quoted string."</span>] r#inner_str , # [doc = <span class="string">"An escaped or any character."</span>] r#inner_chr , # [doc = <span class="string">"An escape sequence."</span>] r#escape , # [doc = <span class="string">"A hexadecimal code."</span>] r#code , # [doc = <span class="string">"A unicode code."</span>] r#unicode , # [doc = <span class="string">"A hexadecimal digit."</span>] r#hex_digit , # [doc = <span class="string">"A double quote."</span>] r#quote , # [doc = <span class="string">"A single quote."</span>] r#single_quote , # [doc = <span class="string">"A range operator."</span>] r#range_operator , # [doc = <span class="string">"A newline character."</span>] r#newline , # [doc = <span class="string">"A whitespace character."</span>] r#WHITESPACE , # [doc = <span class="string">"A single line comment."</span>] r#line_comment , # [doc = <span class="string">"A multi-line comment."</span>] r#block_comment , # [doc = <span class="string">"A grammar comment."</span>] r#COMMENT , # [doc = <span class="string">"A space character."</span>] r#space , # [doc = <span class="string">"A top-level comment."</span>] r#grammar_doc , # [doc = <span class="string">"A rule comment."</span>] r#line_doc , # [doc = <span class="string">"A comment content."</span>] r#inner_doc } <span class="kw">impl </span>Rule { <span class="kw">pub fn </span>all_rules () -&gt; &amp; <span class="lifetime">'static </span>[Rule] { &amp; [Rule :: r#grammar_rules , Rule :: r#grammar_rule , Rule :: r#assignment_operator , Rule :: r#opening_brace , Rule :: r#closing_brace , Rule :: r#opening_paren , Rule :: r#closing_paren , Rule :: r#opening_brack , Rule :: r#closing_brack , Rule :: r#modifier , Rule :: r#silent_modifier , Rule :: r#atomic_modifier , Rule :: r#compound_atomic_modifier , Rule :: r#non_atomic_modifier , Rule :: r#tag_id , Rule :: r#node_tag , Rule :: r#expression , Rule :: r#term , Rule :: r#node , Rule :: r#terminal , Rule :: r#prefix_operator , Rule :: r#infix_operator , Rule :: r#postfix_operator , Rule :: r#positive_predicate_operator , Rule :: r#negative_predicate_operator , Rule :: r#sequence_operator , Rule :: r#choice_operator , Rule :: r#optional_operator , Rule :: r#repeat_operator , Rule :: r#repeat_once_operator , Rule :: r#repeat_exact , Rule :: r#repeat_min , Rule :: r#repeat_max , Rule :: r#repeat_min_max , Rule :: r#number , Rule :: r#integer , Rule :: r#comma , Rule :: r#_push , Rule :: r#_push_literal , Rule :: r#peek_slice , Rule :: r#identifier , Rule :: r#alpha , Rule :: r#alpha_num , Rule :: r#string , Rule :: r#insensitive_string , Rule :: r#range , Rule :: r#character , Rule :: r#inner_str , Rule :: r#inner_chr , Rule :: r#escape , Rule :: r#code , Rule :: r#unicode , Rule :: r#hex_digit , Rule :: r#quote , Rule :: r#single_quote , Rule :: r#range_operator , Rule :: r#newline , Rule :: r#WHITESPACE , Rule :: r#line_comment , Rule :: r#block_comment , Rule :: r#COMMENT , Rule :: r#space , Rule :: r#grammar_doc , Rule :: r#line_doc , Rule :: r#inner_doc] } } # [allow (clippy :: all)] <span class="kw">impl </span>:: pest :: Parser &lt; Rule &gt; <span class="kw">for </span>PestParser { <span class="kw">fn </span>parse &lt; <span class="lifetime">'i </span>&gt; (rule : Rule , input : &amp; <span class="lifetime">'i </span>str) -&gt; :: std :: result :: <span class="prelude-ty">Result</span> &lt; :: pest :: iterators :: Pairs &lt; <span class="lifetime">'i </span>, Rule &gt; , :: pest :: error :: Error &lt; Rule &gt; &gt; { <span class="kw">mod </span>rules { # ! [allow (clippy :: upper_case_acronyms)] <span class="kw">pub mod </span>hidden { <span class="kw">use super </span>:: <span class="kw">super </span>:: Rule ; # [inline] # [allow (dead_code , non_snake_case , unused_variables)] <span class="kw">pub fn </span>skip (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { <span class="kw">if </span>state . atomicity () == :: pest :: Atomicity :: NonAtomic { state . sequence (| state | { state . repeat (| state | <span class="kw">super </span>:: visible :: WHITESPACE (state)) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: visible :: COMMENT (state) . and_then (| state | { state . repeat (| state | <span class="kw">super </span>:: visible :: WHITESPACE (state)) }) }) }) }) }) } <span class="kw">else </span>{ <span class="prelude-val">Ok </span>(state) } } } <span class="kw">pub mod </span>visible { <span class="kw">use super </span>:: <span class="kw">super </span>:: Rule ; # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#grammar_rules (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . sequence (| state | { <span class="self">self </span>:: r#SOI (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#grammar_doc (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#grammar_doc (state) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#grammar_rule (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#grammar_rule (state) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#EOI (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#grammar_rule (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#grammar_rule , | state | { state . sequence (| state | { <span class="self">self </span>:: r#identifier (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#assignment_operator (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#modifier (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#opening_brace (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#expression (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#closing_brace (state) }) }) . or_else (| state | { <span class="self">self </span>:: r#line_doc (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#assignment_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#assignment_operator , | state | { state . match_string (<span class="string">"="</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#opening_brace (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#opening_brace , | state | { state . match_string (<span class="string">"{"</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#closing_brace (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#closing_brace , | state | { state . match_string (<span class="string">"}"</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#opening_paren (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#opening_paren , | state | { state . match_string (<span class="string">"("</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#closing_paren (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#closing_paren , | state | { state . match_string (<span class="string">")"</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#opening_brack (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#opening_brack , | state | { state . match_string (<span class="string">"["</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#closing_brack (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#closing_brack , | state | { state . match_string (<span class="string">"]"</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#modifier (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { <span class="self">self </span>:: r#silent_modifier (state) . or_else (| state | { <span class="self">self </span>:: r#atomic_modifier (state) }) . or_else (| state | { <span class="self">self </span>:: r#compound_atomic_modifier (state) }) . or_else (| state | { <span class="self">self </span>:: r#non_atomic_modifier (state) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#silent_modifier (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#silent_modifier , | state | { state . match_string (<span class="string">"_"</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#atomic_modifier (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#atomic_modifier , | state | { state . match_string (<span class="string">"@"</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#compound_atomic_modifier (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#compound_atomic_modifier , | state | { state . match_string (<span class="string">"$"</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#non_atomic_modifier (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#non_atomic_modifier , | state | { state . match_string (<span class="string">"!"</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#tag_id (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#tag_id , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string (<span class="string">"#"</span>) . and_then (| state | { state . match_string (<span class="string">"_"</span>) . or_else (| state | { <span class="self">self </span>:: r#alpha (state) }) }) . and_then (| state | { state . repeat (| state | { state . match_string (<span class="string">"_"</span>) . or_else (| state | { <span class="self">self </span>:: r#alpha_num (state) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#node_tag (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . sequence (| state | { <span class="self">self </span>:: r#tag_id (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#assignment_operator (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#expression (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#expression , | state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#choice_operator (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#term (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { <span class="self">self </span>:: r#infix_operator (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#term (state) }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { <span class="self">self </span>:: r#infix_operator (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#term (state) }) }) }) }) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#term (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#term , | state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#node_tag (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#prefix_operator (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#prefix_operator (state) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#node (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#postfix_operator (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#postfix_operator (state) }) }) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#node (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . sequence (| state | { <span class="self">self </span>:: r#opening_paren (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#expression (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#closing_paren (state) }) }) . or_else (| state | { <span class="self">self </span>:: r#terminal (state) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#terminal (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { <span class="self">self </span>:: r#_push_literal (state) . or_else (| state | { <span class="self">self </span>:: r#_push (state) }) . or_else (| state | { <span class="self">self </span>:: r#peek_slice (state) }) . or_else (| state | { <span class="self">self </span>:: r#identifier (state) }) . or_else (| state | { <span class="self">self </span>:: r#string (state) }) . or_else (| state | { <span class="self">self </span>:: r#insensitive_string (state) }) . or_else (| state | { <span class="self">self </span>:: r#range (state) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#prefix_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { <span class="self">self </span>:: r#positive_predicate_operator (state) . or_else (| state | { <span class="self">self </span>:: r#negative_predicate_operator (state) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#infix_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { <span class="self">self </span>:: r#sequence_operator (state) . or_else (| state | { <span class="self">self </span>:: r#choice_operator (state) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#postfix_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { <span class="self">self </span>:: r#optional_operator (state) . or_else (| state | { <span class="self">self </span>:: r#repeat_operator (state) }) . or_else (| state | { <span class="self">self </span>:: r#repeat_once_operator (state) }) . or_else (| state | { <span class="self">self </span>:: r#repeat_exact (state) }) . or_else (| state | { <span class="self">self </span>:: r#repeat_min (state) }) . or_else (| state | { <span class="self">self </span>:: r#repeat_max (state) }) . or_else (| state | { <span class="self">self </span>:: r#repeat_min_max (state) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#positive_predicate_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#positive_predicate_operator , | state | { state . match_string (<span class="string">"&amp;"</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#negative_predicate_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#negative_predicate_operator , | state | { state . match_string (<span class="string">"!"</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#sequence_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#sequence_operator , | state | { state . match_string (<span class="string">"~"</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#choice_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#choice_operator , | state | { state . match_string (<span class="string">"|"</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#optional_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#optional_operator , | state | { state . match_string (<span class="string">"?"</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#repeat_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#repeat_operator , | state | { state . match_string (<span class="string">"*"</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#repeat_once_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#repeat_once_operator , | state | { state . match_string (<span class="string">"+"</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#repeat_exact (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#repeat_exact , | state | { state . sequence (| state | { <span class="self">self </span>:: r#opening_brace (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#number (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#closing_brace (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#repeat_min (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#repeat_min , | state | { state . sequence (| state | { <span class="self">self </span>:: r#opening_brace (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#number (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#comma (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#closing_brace (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#repeat_max (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#repeat_max , | state | { state . sequence (| state | { <span class="self">self </span>:: r#opening_brace (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#comma (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#number (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#closing_brace (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#repeat_min_max (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#repeat_min_max , | state | { state . sequence (| state | { <span class="self">self </span>:: r#opening_brace (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#number (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#comma (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#number (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#closing_brace (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#number (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#number , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_range (<span class="string">'0' </span>.. <span class="string">'9'</span>) . and_then (| state | { state . repeat (| state | { state . match_range (<span class="string">'0' </span>.. <span class="string">'9'</span>) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#integer (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#integer , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { <span class="self">self </span>:: r#number (state) . or_else (| state | { state . sequence (| state | { state . match_string (<span class="string">"-"</span>) . and_then (| state | { state . repeat (| state | { state . match_string (<span class="string">"0"</span>) }) }) . and_then (| state | { state . match_range (<span class="string">'1' </span>.. <span class="string">'9'</span>) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#number (state) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#comma (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#comma , | state | { state . match_string (<span class="string">","</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#_push (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#_push , | state | { state . sequence (| state | { state . match_string (<span class="string">"PUSH"</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#opening_paren (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#expression (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#closing_paren (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#_push_literal (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#_push_literal , | state | { state . sequence (| state | { state . match_string (<span class="string">"PUSH_LITERAL"</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#opening_paren (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#string (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#closing_paren (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#peek_slice (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#peek_slice , | state | { state . sequence (| state | { state . match_string (<span class="string">"PEEK"</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#opening_brack (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#integer (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#range_operator (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#integer (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#closing_brack (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#identifier (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#identifier , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . lookahead (<span class="bool-val">false </span>, | state | { state . match_string (<span class="string">"PUSH"</span>) }) . and_then (| state | { state . match_string (<span class="string">"_"</span>) . or_else (| state | { <span class="self">self </span>:: r#alpha (state) }) }) . and_then (| state | { state . repeat (| state | { state . match_string (<span class="string">"_"</span>) . or_else (| state | { <span class="self">self </span>:: r#alpha_num (state) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#alpha (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . match_range (<span class="string">'a' </span>.. <span class="string">'z'</span>) . or_else (| state | { state . match_range (<span class="string">'A' </span>.. <span class="string">'Z'</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#alpha_num (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { <span class="self">self </span>:: r#alpha (state) . or_else (| state | { state . match_range (<span class="string">'0' </span>.. <span class="string">'9'</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#string (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . atomic (:: pest :: Atomicity :: CompoundAtomic , | state | { state . rule (Rule :: r#string , | state | { state . sequence (| state | { <span class="self">self </span>:: r#quote (state) . and_then (| state | { <span class="self">self </span>:: r#inner_str (state) }) . and_then (| state | { <span class="self">self </span>:: r#quote (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#insensitive_string (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#insensitive_string , | state | { state . sequence (| state | { state . match_string (<span class="string">"^"</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#string (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#range (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#range , | state | { state . sequence (| state | { <span class="self">self </span>:: r#character (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#range_operator (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#character (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#character (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . atomic (:: pest :: Atomicity :: CompoundAtomic , | state | { state . rule (Rule :: r#character , | state | { state . sequence (| state | { <span class="self">self </span>:: r#single_quote (state) . and_then (| state | { <span class="self">self </span>:: r#inner_chr (state) }) . and_then (| state | { <span class="self">self </span>:: r#single_quote (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#inner_str (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#inner_str , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { <span class="kw">let </span>strings = [<span class="string">"\"" </span>, <span class="string">"\\"</span>] ; state . skip_until (&amp; strings) . and_then (| state | { state . optional (| state | { state . sequence (| state | { <span class="self">self </span>:: r#escape (state) . and_then (| state | { <span class="self">self </span>:: r#inner_str (state) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#inner_chr (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#inner_chr , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { <span class="self">self </span>:: r#escape (state) . or_else (| state | { <span class="self">self </span>:: r#ANY (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#escape (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#escape , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string (<span class="string">"\\"</span>) . and_then (| state | { state . match_string (<span class="string">"\""</span>) . or_else (| state | { state . match_string (<span class="string">"\\"</span>) }) . or_else (| state | { state . match_string (<span class="string">"r"</span>) }) . or_else (| state | { state . match_string (<span class="string">"n"</span>) }) . or_else (| state | { state . match_string (<span class="string">"t"</span>) }) . or_else (| state | { state . match_string (<span class="string">"0"</span>) }) . or_else (| state | { state . match_string (<span class="string">"'"</span>) }) . or_else (| state | { <span class="self">self </span>:: r#code (state) }) . or_else (| state | { <span class="self">self </span>:: r#unicode (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#code (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#code , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string (<span class="string">"x"</span>) . and_then (| state | { <span class="self">self </span>:: r#hex_digit (state) }) . and_then (| state | { <span class="self">self </span>:: r#hex_digit (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#unicode (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#unicode , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string (<span class="string">"u"</span>) . and_then (| state | { <span class="self">self </span>:: r#opening_brace (state) }) . and_then (| state | { state . sequence (| state | { <span class="self">self </span>:: r#hex_digit (state) . and_then (| state | { <span class="self">self </span>:: r#hex_digit (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#hex_digit (state) }) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#hex_digit (state) }) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#hex_digit (state) }) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#hex_digit (state) }) }) }) }) . and_then (| state | { <span class="self">self </span>:: r#closing_brace (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#hex_digit (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#hex_digit , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . match_range (<span class="string">'0' </span>.. <span class="string">'9'</span>) . or_else (| state | { state . match_range (<span class="string">'a' </span>.. <span class="string">'f'</span>) }) . or_else (| state | { state . match_range (<span class="string">'A' </span>.. <span class="string">'F'</span>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#quote (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#quote , | state | { state . match_string (<span class="string">"\""</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#single_quote (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#single_quote , | state | { state . match_string (<span class="string">"'"</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#range_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#range_operator , | state | { state . match_string (<span class="string">".."</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#newline (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . match_string (<span class="string">"\n"</span>) . or_else (| state | { state . match_string (<span class="string">"\r\n"</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#WHITESPACE (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . match_string (<span class="string">" "</span>) . or_else (| state | { state . match_string (<span class="string">"\t"</span>) }) . or_else (| state | { <span class="self">self </span>:: r#newline (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#line_comment (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . sequence (| state | { state . match_string (<span class="string">"//"</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . lookahead (<span class="bool-val">false </span>, | state | { state . match_string (<span class="string">"/"</span>) . or_else (| state | { state . match_string (<span class="string">"!"</span>) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { state . lookahead (<span class="bool-val">false </span>, | state | { <span class="self">self </span>:: r#newline (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#ANY (state) }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { state . lookahead (<span class="bool-val">false </span>, | state | { <span class="self">self </span>:: r#newline (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#ANY (state) }) }) }) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#block_comment (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . sequence (| state | { state . match_string (<span class="string">"/*"</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#block_comment (state) . or_else (| state | { state . sequence (| state | { state . lookahead (<span class="bool-val">false </span>, | state | { state . match_string (<span class="string">"*/"</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#ANY (state) }) }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#block_comment (state) . or_else (| state | { state . sequence (| state | { state . lookahead (<span class="bool-val">false </span>, | state | { state . match_string (<span class="string">"*/"</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#ANY (state) }) }) }) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">"*/"</span>) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#COMMENT (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . atomic (:: pest :: Atomicity :: Atomic , | state | { <span class="self">self </span>:: r#block_comment (state) . or_else (| state | { <span class="self">self </span>:: r#line_comment (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#space (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . match_string (<span class="string">" "</span>) . or_else (| state | { state . match_string (<span class="string">"\t"</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#grammar_doc (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . atomic (:: pest :: Atomicity :: CompoundAtomic , | state | { state . rule (Rule :: r#grammar_doc , | state | { state . sequence (| state | { state . match_string (<span class="string">"//!"</span>) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#space (state) }) }) . and_then (| state | { <span class="self">self </span>:: r#inner_doc (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#line_doc (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . atomic (:: pest :: Atomicity :: CompoundAtomic , | state | { state . rule (Rule :: r#line_doc , | state | { state . sequence (| state | { state . match_string (<span class="string">"///"</span>) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#space (state) }) }) . and_then (| state | { <span class="self">self </span>:: r#inner_doc (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#inner_doc (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#inner_doc , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { <span class="kw">let </span>strings = [<span class="string">"\n" </span>, <span class="string">"\r\n"</span>] ; state . skip_until (&amp; strings) }) }) } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] <span class="kw">pub fn </span>ANY (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . skip (<span class="number">1</span>) } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] <span class="kw">pub fn </span>EOI (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: EOI , | state | state . end_of_input ()) } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] <span class="kw">pub fn </span>SOI (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . start_of_input () } } <span class="kw">pub use </span><span class="self">self </span>:: visible :: * ; } :: pest :: state (input , | state | { <span class="kw">match </span>rule { Rule :: r#grammar_rules =&gt; rules :: r#grammar_rules (state) , Rule :: r#grammar_rule =&gt; rules :: r#grammar_rule (state) , Rule :: r#assignment_operator =&gt; rules :: r#assignment_operator (state) , Rule :: r#opening_brace =&gt; rules :: r#opening_brace (state) , Rule :: r#closing_brace =&gt; rules :: r#closing_brace (state) , Rule :: r#opening_paren =&gt; rules :: r#opening_paren (state) , Rule :: r#closing_paren =&gt; rules :: r#closing_paren (state) , Rule :: r#opening_brack =&gt; rules :: r#opening_brack (state) , Rule :: r#closing_brack =&gt; rules :: r#closing_brack (state) , Rule :: r#modifier =&gt; rules :: r#modifier (state) , Rule :: r#silent_modifier =&gt; rules :: r#silent_modifier (state) , Rule :: r#atomic_modifier =&gt; rules :: r#atomic_modifier (state) , Rule :: r#compound_atomic_modifier =&gt; rules :: r#compound_atomic_modifier (state) , Rule :: r#non_atomic_modifier =&gt; rules :: r#non_atomic_modifier (state) , Rule :: r#tag_id =&gt; rules :: r#tag_id (state) , Rule :: r#node_tag =&gt; rules :: r#node_tag (state) , Rule :: r#expression =&gt; rules :: r#expression (state) , Rule :: r#term =&gt; rules :: r#term (state) , Rule :: r#node =&gt; rules :: r#node (state) , Rule :: r#terminal =&gt; rules :: r#terminal (state) , Rule :: r#prefix_operator =&gt; rules :: r#prefix_operator (state) , Rule :: r#infix_operator =&gt; rules :: r#infix_operator (state) , Rule :: r#postfix_operator =&gt; rules :: r#postfix_operator (state) , Rule :: r#positive_predicate_operator =&gt; rules :: r#positive_predicate_operator (state) , Rule :: r#negative_predicate_operator =&gt; rules :: r#negative_predicate_operator (state) , Rule :: r#sequence_operator =&gt; rules :: r#sequence_operator (state) , Rule :: r#choice_operator =&gt; rules :: r#choice_operator (state) , Rule :: r#optional_operator =&gt; rules :: r#optional_operator (state) , Rule :: r#repeat_operator =&gt; rules :: r#repeat_operator (state) , Rule :: r#repeat_once_operator =&gt; rules :: r#repeat_once_operator (state) , Rule :: r#repeat_exact =&gt; rules :: r#repeat_exact (state) , Rule :: r#repeat_min =&gt; rules :: r#repeat_min (state) , Rule :: r#repeat_max =&gt; rules :: r#repeat_max (state) , Rule :: r#repeat_min_max =&gt; rules :: r#repeat_min_max (state) , Rule :: r#number =&gt; rules :: r#number (state) , Rule :: r#integer =&gt; rules :: r#integer (state) , Rule :: r#comma =&gt; rules :: r#comma (state) , Rule :: r#_push =&gt; rules :: r#_push (state) , Rule :: r#_push_literal =&gt; rules :: r#_push_literal (state) , Rule :: r#peek_slice =&gt; rules :: r#peek_slice (state) , Rule :: r#identifier =&gt; rules :: r#identifier (state) , Rule :: r#alpha =&gt; rules :: r#alpha (state) , Rule :: r#alpha_num =&gt; rules :: r#alpha_num (state) , Rule :: r#string =&gt; rules :: r#string (state) , Rule :: r#insensitive_string =&gt; rules :: r#insensitive_string (state) , Rule :: r#range =&gt; rules :: r#range (state) , Rule :: r#character =&gt; rules :: r#character (state) , Rule :: r#inner_str =&gt; rules :: r#inner_str (state) , Rule :: r#inner_chr =&gt; rules :: r#inner_chr (state) , Rule :: r#escape =&gt; rules :: r#escape (state) , Rule :: r#code =&gt; rules :: r#code (state) , Rule :: r#unicode =&gt; rules :: r#unicode (state) , Rule :: r#hex_digit =&gt; rules :: r#hex_digit (state) , Rule :: r#quote =&gt; rules :: r#quote (state) , Rule :: r#single_quote =&gt; rules :: r#single_quote (state) , Rule :: r#range_operator =&gt; rules :: r#range_operator (state) , Rule :: r#newline =&gt; rules :: r#newline (state) , Rule :: r#WHITESPACE =&gt; rules :: r#WHITESPACE (state) , Rule :: r#line_comment =&gt; rules :: r#line_comment (state) , Rule :: r#block_comment =&gt; rules :: r#block_comment (state) , Rule :: r#COMMENT =&gt; rules :: r#COMMENT (state) , Rule :: r#space =&gt; rules :: r#space (state) , Rule :: r#grammar_doc =&gt; rules :: r#grammar_doc (state) , Rule :: r#line_doc =&gt; rules :: r#line_doc (state) , Rule :: r#inner_doc =&gt; rules :: r#inner_doc (state) , Rule :: EOI =&gt; rules :: EOI (state) } }) } }</code></pre></div></section></main></body></html>
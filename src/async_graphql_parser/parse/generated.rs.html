<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/async-graphql-parser-7.0.17/src/parse/generated.rs`."><title>generated.rs - source</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-6c3ea77c.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="async_graphql_parser" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0 (05f9846f8 2025-03-31)" data-channel="1.86.0" data-search-js="search-581efc7a.js" data-settings-js="settings-6dad6058.js" ><script src="../../../static.files/storage-3a5871a4.js"></script><script defer src="../../../static.files/src-script-b8d3f215.js"></script><script defer src="../../../src-files.js"></script><script defer src="../../../static.files/main-4d63596a.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc src"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="src-sidebar-title"><h2>Files</h2></div></nav><div class="sidebar-resizer"></div><main><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1><div class="sub-heading">async_graphql_parser/parse/</div>generated.rs</h1><rustdoc-toolbar></rustdoc-toolbar></div><div class="example-wrap digits-1"><pre class="rust"><code><a href=#1 id=1 data-nosnippet>1</a>
<a href=#2 id=2 data-nosnippet>2</a><span class="doccomment">//! This is @generated code, do not edit by hand.
<a href=#3 id=3 data-nosnippet>3</a>//! See `graphql.pest` and `tests/codegen.rs`.
<a href=#4 id=4 data-nosnippet>4</a></span><span class="attr">#![allow(unused_attributes)]
<a href=#5 id=5 data-nosnippet>5</a></span><span class="kw">use </span><span class="kw">super</span>::GraphQLParser;
<a href=#6 id=6 data-nosnippet>6</a>
<a href=#7 id=7 data-nosnippet>7</a># [allow (dead_code , non_camel_case_types , clippy :: upper_case_acronyms)] # [derive (Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] <span class="kw">pub enum </span>Rule { # [doc = <span class="string">"End-of-input"</span>] EOI , r#WHITESPACE , r#COMMENT , r#line_terminator , r#executable_document , r#executable_definition , r#operation_definition , r#named_operation_definition , r#variable_definitions , r#variable_definition , r#selection_set , r#selection , r#field , r#alias , r#fragment_spread , r#inline_fragment , r#fragment_definition , r#type_condition , r#service_document , r#type_system_definition , r#schema_definition , r#operation_type_definition , r#type_definition , r#scalar_type , r#object_type , r#implements_interfaces , r#interface_type , r#fields_definition , r#field_definition , r#union_type , r#union_member_types , r#enum_type , r#enum_values , r#enum_value_definition , r#input_object_type , r#input_fields_definition , r#extend , r#directive_definition , r#repeatable , r#directive_locations , r#directive_location , r#arguments_definition , r#input_value_definition , r#operation_type , r#default_value , r#type_ , r#const_value , r#value , r#variable , r#number , r#float , r#fractional , r#exponent , r#int , r#string , r#block_string_content , r#block_string_character , r#string_content , r#string_character , r#unicode_scalar_value_hex , r#boolean , r#null , r#enum_value , r#const_list , r#list , r#const_object , r#object , r#const_object_field , r#object_field , r#const_directives , r#directives , r#const_directive , r#directive , r#const_arguments , r#arguments , r#const_argument , r#argument , r#name_start , r#name } <span class="kw">impl </span>Rule { <span class="kw">pub fn </span>all_rules () -&gt; &amp; <span class="lifetime">'static </span>[Rule] { &amp; [Rule :: r#WHITESPACE , Rule :: r#COMMENT , Rule :: r#line_terminator , Rule :: r#executable_document , Rule :: r#executable_definition , Rule :: r#operation_definition , Rule :: r#named_operation_definition , Rule :: r#variable_definitions , Rule :: r#variable_definition , Rule :: r#selection_set , Rule :: r#selection , Rule :: r#field , Rule :: r#alias , Rule :: r#fragment_spread , Rule :: r#inline_fragment , Rule :: r#fragment_definition , Rule :: r#type_condition , Rule :: r#service_document , Rule :: r#type_system_definition , Rule :: r#schema_definition , Rule :: r#operation_type_definition , Rule :: r#type_definition , Rule :: r#scalar_type , Rule :: r#object_type , Rule :: r#implements_interfaces , Rule :: r#interface_type , Rule :: r#fields_definition , Rule :: r#field_definition , Rule :: r#union_type , Rule :: r#union_member_types , Rule :: r#enum_type , Rule :: r#enum_values , Rule :: r#enum_value_definition , Rule :: r#input_object_type , Rule :: r#input_fields_definition , Rule :: r#extend , Rule :: r#directive_definition , Rule :: r#repeatable , Rule :: r#directive_locations , Rule :: r#directive_location , Rule :: r#arguments_definition , Rule :: r#input_value_definition , Rule :: r#operation_type , Rule :: r#default_value , Rule :: r#type_ , Rule :: r#const_value , Rule :: r#value , Rule :: r#variable , Rule :: r#number , Rule :: r#float , Rule :: r#fractional , Rule :: r#exponent , Rule :: r#int , Rule :: r#string , Rule :: r#block_string_content , Rule :: r#block_string_character , Rule :: r#string_content , Rule :: r#string_character , Rule :: r#unicode_scalar_value_hex , Rule :: r#boolean , Rule :: r#null , Rule :: r#enum_value , Rule :: r#const_list , Rule :: r#list , Rule :: r#const_object , Rule :: r#object , Rule :: r#const_object_field , Rule :: r#object_field , Rule :: r#const_directives , Rule :: r#directives , Rule :: r#const_directive , Rule :: r#directive , Rule :: r#const_arguments , Rule :: r#arguments , Rule :: r#const_argument , Rule :: r#argument , Rule :: r#name_start , Rule :: r#name] } } # [allow (clippy :: all)] <span class="kw">impl </span>:: pest :: Parser &lt; Rule &gt; <span class="kw">for </span>GraphQLParser { <span class="kw">fn </span>parse &lt; <span class="lifetime">'i </span>&gt; (rule : Rule , input : &amp; <span class="lifetime">'i </span>str) -&gt; :: std :: result :: <span class="prelude-ty">Result</span> &lt; :: pest :: iterators :: Pairs &lt; <span class="lifetime">'i </span>, Rule &gt; , :: pest :: error :: Error &lt; Rule &gt; &gt; { <span class="kw">mod </span>rules { # ! [allow (clippy :: upper_case_acronyms)] <span class="kw">pub mod </span>hidden { <span class="kw">use super </span>:: <span class="kw">super </span>:: Rule ; # [inline] # [allow (dead_code , non_snake_case , unused_variables)] <span class="kw">pub fn </span>skip (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { <span class="kw">if </span>state . atomicity () == :: pest :: Atomicity :: NonAtomic { state . sequence (| state | { state . repeat (| state | <span class="kw">super </span>:: visible :: WHITESPACE (state)) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: visible :: COMMENT (state) . and_then (| state | { state . repeat (| state | <span class="kw">super </span>:: visible :: WHITESPACE (state)) }) }) }) }) }) } <span class="kw">else </span>{ <span class="prelude-val">Ok </span>(state) } } } <span class="kw">pub mod </span>visible { <span class="kw">use super </span>:: <span class="kw">super </span>:: Rule ; # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#WHITESPACE (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . match_string (<span class="string">" "</span>) . or_else (| state | { state . match_string (<span class="string">","</span>) }) . or_else (| state | { state . match_string (<span class="string">"\t"</span>) }) . or_else (| state | { state . match_string (<span class="string">"\u{feff}"</span>) }) . or_else (| state | { <span class="self">self </span>:: r#line_terminator (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#COMMENT (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { state . match_string (<span class="string">"#"</span>) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { state . lookahead (<span class="bool-val">false </span>, | state | { <span class="self">self </span>:: r#line_terminator (state) }) . and_then (| state | { <span class="self">self </span>:: r#ANY (state) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#line_terminator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#line_terminator , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . match_string (<span class="string">"\r\n"</span>) . or_else (| state | { state . match_string (<span class="string">"\r"</span>) }) . or_else (| state | { state . match_string (<span class="string">"\n"</span>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#executable_document (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#executable_document , | state | { state . sequence (| state | { <span class="self">self </span>:: r#SOI (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { <span class="self">self </span>:: r#executable_definition (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#executable_definition (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#executable_definition (state) }) }) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#EOI (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#executable_definition (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#executable_definition , | state | { <span class="self">self </span>:: r#operation_definition (state) . or_else (| state | { <span class="self">self </span>:: r#fragment_definition (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#operation_definition (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#operation_definition , | state | { <span class="self">self </span>:: r#named_operation_definition (state) . or_else (| state | { <span class="self">self </span>:: r#selection_set (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#named_operation_definition (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#named_operation_definition , | state | { state . sequence (| state | { <span class="self">self </span>:: r#operation_type (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#name (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#variable_definitions (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#directives (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#selection_set (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#variable_definitions (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#variable_definitions , | state | { state . sequence (| state | { state . match_string (<span class="string">"("</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#variable_definition (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#variable_definition (state) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">")"</span>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#variable_definition (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#variable_definition , | state | { state . sequence (| state | { <span class="self">self </span>:: r#variable (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">":"</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#type_ (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#directives (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#default_value (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#selection_set (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#selection_set , | state | { state . sequence (| state | { state . match_string (<span class="string">"{"</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { <span class="self">self </span>:: r#selection (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#selection (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#selection (state) }) }) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">"}"</span>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#selection (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#selection , | state | { <span class="self">self </span>:: r#field (state) . or_else (| state | { <span class="self">self </span>:: r#inline_fragment (state) }) . or_else (| state | { <span class="self">self </span>:: r#fragment_spread (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#field (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#field , | state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#alias (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#arguments (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#directives (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#selection_set (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#alias (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#alias , | state | { state . sequence (| state | { <span class="self">self </span>:: r#name (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">":"</span>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#fragment_spread (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#fragment_spread , | state | { state . sequence (| state | { state . match_string (<span class="string">"..."</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . lookahead (<span class="bool-val">false </span>, | state | { <span class="self">self </span>:: r#type_condition (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#directives (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#inline_fragment (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#inline_fragment , | state | { state . sequence (| state | { state . match_string (<span class="string">"..."</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#type_condition (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#directives (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#selection_set (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#fragment_definition (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#fragment_definition , | state | { state . sequence (| state | { state . match_string (<span class="string">"fragment"</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#type_condition (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#directives (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#selection_set (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#type_condition (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . atomic (:: pest :: Atomicity :: CompoundAtomic , | state | { state . rule (Rule :: r#type_condition , | state | { state . sequence (| state | { state . match_string (<span class="string">"on"</span>) . and_then (| state | { state . sequence (| state | { <span class="self">self </span>:: r#WHITESPACE (state) . and_then (| state | { state . repeat (| state | { <span class="self">self </span>:: r#WHITESPACE (state) }) }) }) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#service_document (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#service_document , | state | { state . sequence (| state | { <span class="self">self </span>:: r#SOI (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { <span class="self">self </span>:: r#type_system_definition (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#type_system_definition (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#type_system_definition (state) }) }) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#EOI (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#type_system_definition (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#type_system_definition , | state | { <span class="self">self </span>:: r#schema_definition (state) . or_else (| state | { <span class="self">self </span>:: r#type_definition (state) }) . or_else (| state | { <span class="self">self </span>:: r#directive_definition (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#schema_definition (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#schema_definition , | state | { state . sequence (| state | { state . match_string (<span class="string">"schema"</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_directives (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">"{"</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { <span class="self">self </span>:: r#operation_type_definition (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#operation_type_definition (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#operation_type_definition (state) }) }) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">"}"</span>) }) }) . or_else (| state | { state . sequence (| state | { <span class="self">self </span>:: r#extend (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">"schema"</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_directives (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">"{"</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { <span class="self">self </span>:: r#operation_type_definition (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#operation_type_definition (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#operation_type_definition (state) }) }) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">"}"</span>) }) }) . or_else (| state | { <span class="self">self </span>:: r#const_directives (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#operation_type_definition (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#operation_type_definition , | state | { state . sequence (| state | { <span class="self">self </span>:: r#operation_type (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">":"</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#type_definition (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#type_definition , | state | { <span class="self">self </span>:: r#scalar_type (state) . or_else (| state | { <span class="self">self </span>:: r#object_type (state) }) . or_else (| state | { <span class="self">self </span>:: r#interface_type (state) }) . or_else (| state | { <span class="self">self </span>:: r#union_type (state) }) . or_else (| state | { <span class="self">self </span>:: r#enum_type (state) }) . or_else (| state | { <span class="self">self </span>:: r#input_object_type (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#scalar_type (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#scalar_type , | state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#string (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">"scalar"</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_directives (state) }) }) }) . or_else (| state | { state . sequence (| state | { <span class="self">self </span>:: r#extend (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">"scalar"</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#const_directives (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#object_type (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#object_type , | state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#string (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">"type"</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#implements_interfaces (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_directives (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#fields_definition (state) }) }) }) . or_else (| state | { state . sequence (| state | { <span class="self">self </span>:: r#extend (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">"type"</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#implements_interfaces (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_directives (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#fields_definition (state) }) }) . or_else (| state | { <span class="self">self </span>:: r#const_directives (state) }) }) }) . or_else (| state | { <span class="self">self </span>:: r#implements_interfaces (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#implements_interfaces (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#implements_interfaces , | state | { state . sequence (| state | { state . match_string (<span class="string">"implements"</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { state . match_string (<span class="string">"&amp;"</span>) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { state . match_string (<span class="string">"&amp;"</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { state . match_string (<span class="string">"&amp;"</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) }) }) }) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#interface_type (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#interface_type , | state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#string (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">"interface"</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#implements_interfaces (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_directives (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#fields_definition (state) }) }) }) . or_else (| state | { state . sequence (| state | { <span class="self">self </span>:: r#extend (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">"interface"</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#implements_interfaces (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_directives (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#fields_definition (state) }) }) . or_else (| state | { <span class="self">self </span>:: r#const_directives (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#fields_definition (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#fields_definition , | state | { state . sequence (| state | { state . match_string (<span class="string">"{"</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { <span class="self">self </span>:: r#field_definition (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#field_definition (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#field_definition (state) }) }) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">"}"</span>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#field_definition (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#field_definition , | state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#string (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#arguments_definition (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">":"</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#type_ (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_directives (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#union_type (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#union_type , | state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#string (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">"union"</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_directives (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#union_member_types (state) }) }) }) . or_else (| state | { state . sequence (| state | { <span class="self">self </span>:: r#extend (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">"union"</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_directives (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#union_member_types (state) }) }) . or_else (| state | { <span class="self">self </span>:: r#const_directives (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#union_member_types (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#union_member_types , | state | { state . sequence (| state | { state . match_string (<span class="string">"="</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { state . match_string (<span class="string">"|"</span>) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { state . match_string (<span class="string">"|"</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { state . match_string (<span class="string">"|"</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) }) }) }) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#enum_type (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#enum_type , | state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#string (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">"enum"</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_directives (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#enum_values (state) }) }) }) . or_else (| state | { state . sequence (| state | { <span class="self">self </span>:: r#extend (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">"enum"</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_directives (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#enum_values (state) }) }) . or_else (| state | { <span class="self">self </span>:: r#const_directives (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#enum_values (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#enum_values , | state | { state . sequence (| state | { state . match_string (<span class="string">"{"</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { <span class="self">self </span>:: r#enum_value_definition (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#enum_value_definition (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#enum_value_definition (state) }) }) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">"}"</span>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#enum_value_definition (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#enum_value_definition , | state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#string (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#enum_value (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_directives (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#input_object_type (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#input_object_type , | state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#string (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">"input"</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_directives (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#input_fields_definition (state) }) }) }) . or_else (| state | { state . sequence (| state | { <span class="self">self </span>:: r#extend (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">"input"</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_directives (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#input_fields_definition (state) }) }) . or_else (| state | { <span class="self">self </span>:: r#const_directives (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#input_fields_definition (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#input_fields_definition , | state | { state . sequence (| state | { state . match_string (<span class="string">"{"</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { <span class="self">self </span>:: r#input_value_definition (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#input_value_definition (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#input_value_definition (state) }) }) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">"}"</span>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#extend (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#extend , | state | { state . match_string (<span class="string">"extend"</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#directive_definition (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#directive_definition , | state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#string (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">"directive"</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">"@"</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#arguments_definition (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#repeatable (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">"on"</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#directive_locations (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#repeatable (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#repeatable , | state | { state . optional (| state | { state . match_string (<span class="string">"repeatable"</span>) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#directive_locations (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#directive_locations , | state | { state . sequence (| state | { state . optional (| state | { state . match_string (<span class="string">"|"</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#directive_location (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { state . match_string (<span class="string">"|"</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#directive_location (state) }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { state . match_string (<span class="string">"|"</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#directive_location (state) }) }) }) }) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#directive_location (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#directive_location , | state | { state . match_string (<span class="string">"QUERY"</span>) . or_else (| state | { state . match_string (<span class="string">"MUTATION"</span>) }) . or_else (| state | { state . match_string (<span class="string">"SUBSCRIPTION"</span>) }) . or_else (| state | { state . match_string (<span class="string">"FIELD_DEFINITION"</span>) }) . or_else (| state | { state . match_string (<span class="string">"FIELD"</span>) }) . or_else (| state | { state . match_string (<span class="string">"FRAGMENT_DEFINITION"</span>) }) . or_else (| state | { state . match_string (<span class="string">"FRAGMENT_SPREAD"</span>) }) . or_else (| state | { state . match_string (<span class="string">"INLINE_FRAGMENT"</span>) }) . or_else (| state | { state . match_string (<span class="string">"VARIABLE_DEFINITION"</span>) }) . or_else (| state | { state . match_string (<span class="string">"SCHEMA"</span>) }) . or_else (| state | { state . match_string (<span class="string">"SCALAR"</span>) }) . or_else (| state | { state . match_string (<span class="string">"OBJECT"</span>) }) . or_else (| state | { state . match_string (<span class="string">"ARGUMENT_DEFINITION"</span>) }) . or_else (| state | { state . match_string (<span class="string">"INTERFACE"</span>) }) . or_else (| state | { state . match_string (<span class="string">"UNION"</span>) }) . or_else (| state | { state . match_string (<span class="string">"ENUM_VALUE"</span>) }) . or_else (| state | { state . match_string (<span class="string">"ENUM"</span>) }) . or_else (| state | { state . match_string (<span class="string">"INPUT_OBJECT"</span>) }) . or_else (| state | { state . match_string (<span class="string">"INPUT_FIELD_DEFINITION"</span>) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#arguments_definition (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#arguments_definition , | state | { state . sequence (| state | { state . match_string (<span class="string">"("</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { <span class="self">self </span>:: r#input_value_definition (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#input_value_definition (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#input_value_definition (state) }) }) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">")"</span>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#input_value_definition (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#input_value_definition , | state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#string (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">":"</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#type_ (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#default_value (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_directives (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#operation_type (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#operation_type , | state | { state . match_string (<span class="string">"query"</span>) . or_else (| state | { state . match_string (<span class="string">"mutation"</span>) }) . or_else (| state | { state . match_string (<span class="string">"subscription"</span>) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#default_value (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#default_value , | state | { state . sequence (| state | { state . match_string (<span class="string">"="</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#const_value (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#type_ (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#type_ , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { <span class="self">self </span>:: r#name (state) . or_else (| state | { state . sequence (| state | { state . match_string (<span class="string">"["</span>) . and_then (| state | { <span class="self">self </span>:: r#type_ (state) }) . and_then (| state | { state . match_string (<span class="string">"]"</span>) }) }) }) . and_then (| state | { state . optional (| state | { state . match_string (<span class="string">"!"</span>) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#const_value (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#const_value , | state | { <span class="self">self </span>:: r#number (state) . or_else (| state | { <span class="self">self </span>:: r#string (state) }) . or_else (| state | { <span class="self">self </span>:: r#boolean (state) }) . or_else (| state | { <span class="self">self </span>:: r#null (state) }) . or_else (| state | { <span class="self">self </span>:: r#enum_value (state) }) . or_else (| state | { <span class="self">self </span>:: r#const_list (state) }) . or_else (| state | { <span class="self">self </span>:: r#const_object (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#value (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#value , | state | { <span class="self">self </span>:: r#variable (state) . or_else (| state | { <span class="self">self </span>:: r#number (state) }) . or_else (| state | { <span class="self">self </span>:: r#string (state) }) . or_else (| state | { <span class="self">self </span>:: r#boolean (state) }) . or_else (| state | { <span class="self">self </span>:: r#null (state) }) . or_else (| state | { <span class="self">self </span>:: r#enum_value (state) }) . or_else (| state | { <span class="self">self </span>:: r#list (state) }) . or_else (| state | { <span class="self">self </span>:: r#object (state) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#variable (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#variable , | state | { state . sequence (| state | { state . match_string (<span class="string">"$"</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#number (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#number , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { <span class="self">self </span>:: r#float (state) . or_else (| state | { <span class="self">self </span>:: r#int (state) }) . and_then (| state | { state . lookahead (<span class="bool-val">false </span>, | state | { <span class="self">self </span>:: r#name_start (state) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#float (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#float , | state | { state . sequence (| state | { <span class="self">self </span>:: r#int (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { <span class="self">self </span>:: r#fractional (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#exponent (state) }) }) . or_else (| state | { <span class="self">self </span>:: r#fractional (state) }) . or_else (| state | { <span class="self">self </span>:: r#exponent (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#fractional (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#fractional , | state | { state . sequence (| state | { state . match_string (<span class="string">"."</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#ASCII_DIGIT (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#ASCII_DIGIT (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#ASCII_DIGIT (state) }) }) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#exponent (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#exponent , | state | { state . sequence (| state | { state . match_string (<span class="string">"E"</span>) . or_else (| state | { state . match_string (<span class="string">"e"</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { state . match_string (<span class="string">"+"</span>) . or_else (| state | { state . match_string (<span class="string">"-"</span>) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#ASCII_DIGIT (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#ASCII_DIGIT (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#ASCII_DIGIT (state) }) }) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#int (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#int , | state | { state . sequence (| state | { state . optional (| state | { state . match_string (<span class="string">"-"</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">"0"</span>) . or_else (| state | { state . sequence (| state | { <span class="self">self </span>:: r#ASCII_NONZERO_DIGIT (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#ASCII_DIGIT (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#ASCII_DIGIT (state) }) }) }) }) }) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#string (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . atomic (:: pest :: Atomicity :: CompoundAtomic , | state | { state . rule (Rule :: r#string , | state | { state . sequence (| state | { state . match_string (<span class="string">"\"\"\""</span>) . and_then (| state | { <span class="self">self </span>:: r#block_string_content (state) }) . and_then (| state | { state . match_string (<span class="string">"\"\"\""</span>) }) }) . or_else (| state | { state . sequence (| state | { state . match_string (<span class="string">"\""</span>) . and_then (| state | { <span class="self">self </span>:: r#string_content (state) }) . and_then (| state | { state . match_string (<span class="string">"\""</span>) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#block_string_content (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#block_string_content , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . repeat (| state | { <span class="self">self </span>:: r#block_string_character (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#block_string_character (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#block_string_character , | state | { state . sequence (| state | { state . lookahead (<span class="bool-val">false </span>, | state | { state . match_string (<span class="string">"\"\"\""</span>) . or_else (| state | { state . match_string (<span class="string">"\\\"\"\""</span>) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#ANY (state) }) }) . or_else (| state | { state . match_string (<span class="string">"\\\"\"\""</span>) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#string_content (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#string_content , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . repeat (| state | { <span class="self">self </span>:: r#string_character (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#string_character (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#string_character , | state | { state . sequence (| state | { state . lookahead (<span class="bool-val">false </span>, | state | { state . match_string (<span class="string">"\""</span>) . or_else (| state | { state . match_string (<span class="string">"\\"</span>) }) . or_else (| state | { <span class="self">self </span>:: r#line_terminator (state) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#ANY (state) }) }) . or_else (| state | { state . sequence (| state | { state . match_string (<span class="string">"\\"</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">"\""</span>) . or_else (| state | { state . match_string (<span class="string">"\\"</span>) }) . or_else (| state | { state . match_string (<span class="string">"/"</span>) }) . or_else (| state | { state . match_string (<span class="string">"b"</span>) }) . or_else (| state | { state . match_string (<span class="string">"f"</span>) }) . or_else (| state | { state . match_string (<span class="string">"n"</span>) }) . or_else (| state | { state . match_string (<span class="string">"r"</span>) }) . or_else (| state | { state . match_string (<span class="string">"t"</span>) }) }) }) }) . or_else (| state | { state . sequence (| state | { state . match_string (<span class="string">"\\u"</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#unicode_scalar_value_hex (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#unicode_scalar_value_hex (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#unicode_scalar_value_hex , | state | { state . sequence (| state | { state . lookahead (<span class="bool-val">false </span>, | state | { state . sequence (| state | { state . match_insensitive (<span class="string">"d"</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_range (<span class="string">'8' </span>.. <span class="string">'9'</span>) . or_else (| state | { state . match_range (<span class="string">'a' </span>.. <span class="string">'f'</span>) }) . or_else (| state | { state . match_range (<span class="string">'A' </span>.. <span class="string">'F'</span>) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#ASCII_HEX_DIGIT (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#ASCII_HEX_DIGIT (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#ASCII_HEX_DIGIT (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#ASCII_HEX_DIGIT (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#boolean (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#boolean , | state | { state . match_string (<span class="string">"true"</span>) . or_else (| state | { state . match_string (<span class="string">"false"</span>) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#null (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#null , | state | { state . match_string (<span class="string">"null"</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#enum_value (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . atomic (:: pest :: Atomicity :: CompoundAtomic , | state | { state . rule (Rule :: r#enum_value , | state | { state . sequence (| state | { state . lookahead (<span class="bool-val">false </span>, | state | { <span class="self">self </span>:: r#boolean (state) . or_else (| state | { <span class="self">self </span>:: r#null (state) }) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#const_list (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#const_list , | state | { state . sequence (| state | { state . match_string (<span class="string">"["</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_value (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#const_value (state) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">"]"</span>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#list (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#list , | state | { state . sequence (| state | { state . match_string (<span class="string">"["</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#value (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#value (state) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">"]"</span>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#const_object (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#const_object , | state | { state . sequence (| state | { state . match_string (<span class="string">"{"</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_object_field (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#const_object_field (state) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">"}"</span>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#object (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#object , | state | { state . sequence (| state | { state . match_string (<span class="string">"{"</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#object_field (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#object_field (state) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">"}"</span>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#const_object_field (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#const_object_field , | state | { state . sequence (| state | { <span class="self">self </span>:: r#name (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">":"</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#const_value (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#object_field (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#object_field , | state | { state . sequence (| state | { <span class="self">self </span>:: r#name (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">":"</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#value (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#const_directives (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#const_directives , | state | { state . sequence (| state | { <span class="self">self </span>:: r#const_directive (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_directive (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#const_directive (state) }) }) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#directives (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#directives , | state | { state . sequence (| state | { <span class="self">self </span>:: r#directive (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#directive (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#directive (state) }) }) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#const_directive (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#const_directive , | state | { state . sequence (| state | { state . match_string (<span class="string">"@"</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_arguments (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#directive (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#directive , | state | { state . sequence (| state | { state . match_string (<span class="string">"@"</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#name (state) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . optional (| state | { <span class="self">self </span>:: r#arguments (state) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#const_arguments (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#const_arguments , | state | { state . sequence (| state | { state . match_string (<span class="string">"("</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { <span class="self">self </span>:: r#const_argument (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#const_argument (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#const_argument (state) }) }) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">")"</span>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#arguments (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#arguments , | state | { state . sequence (| state | { state . match_string (<span class="string">"("</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { <span class="self">self </span>:: r#argument (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { <span class="self">self </span>:: r#argument (state) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (state) . and_then (| state | { <span class="self">self </span>:: r#argument (state) }) }) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">")"</span>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#const_argument (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#const_argument , | state | { state . sequence (| state | { <span class="self">self </span>:: r#name (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">":"</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#const_value (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#argument (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#argument , | state | { state . sequence (| state | { <span class="self">self </span>:: r#name (state) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { state . match_string (<span class="string">":"</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (state) }) . and_then (| state | { <span class="self">self </span>:: r#value (state) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#name_start (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#name_start , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { <span class="self">self </span>:: r#ASCII_ALPHA (state) . or_else (| state | { state . match_string (<span class="string">"_"</span>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>r#name (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: r#name , | state | { state . atomic (:: pest :: Atomicity :: Atomic , | state | { state . sequence (| state | { <span class="self">self </span>:: r#name_start (state) . and_then (| state | { state . repeat (| state | { <span class="self">self </span>:: r#ASCII_ALPHA (state) . or_else (| state | { <span class="self">self </span>:: r#ASCII_DIGIT (state) }) . or_else (| state | { state . match_string (<span class="string">"_"</span>) }) }) }) }) }) }) } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] <span class="kw">pub fn </span>ANY (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . skip (<span class="number">1</span>) } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] <span class="kw">pub fn </span>EOI (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . rule (Rule :: EOI , | state | state . end_of_input ()) } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] <span class="kw">pub fn </span>SOI (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . start_of_input () } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] <span class="kw">pub fn </span>ASCII_DIGIT (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . match_range (<span class="string">'0' </span>..<span class="string">'9'</span>) } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] <span class="kw">pub fn </span>ASCII_NONZERO_DIGIT (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . match_range (<span class="string">'1' </span>..<span class="string">'9'</span>) } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] <span class="kw">pub fn </span>ASCII_HEX_DIGIT (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . match_range (<span class="string">'0' </span>..<span class="string">'9'</span>) . or_else (| state | state . match_range (<span class="string">'a' </span>..<span class="string">'f'</span>)) . or_else (| state | state . match_range (<span class="string">'A' </span>..<span class="string">'F'</span>)) } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] <span class="kw">pub fn </span>ASCII_ALPHA (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <span class="lifetime">'_ </span>, Rule &gt;&gt; &gt; { state . match_range (<span class="string">'a' </span>..<span class="string">'z'</span>) . or_else (| state | state . match_range (<span class="string">'A' </span>..<span class="string">'Z'</span>)) } } <span class="kw">pub use </span><span class="self">self </span>:: visible :: * ; } :: pest :: state (input , | state | { <span class="kw">match </span>rule { Rule :: r#WHITESPACE =&gt; rules :: r#WHITESPACE (state) , Rule :: r#COMMENT =&gt; rules :: r#COMMENT (state) , Rule :: r#line_terminator =&gt; rules :: r#line_terminator (state) , Rule :: r#executable_document =&gt; rules :: r#executable_document (state) , Rule :: r#executable_definition =&gt; rules :: r#executable_definition (state) , Rule :: r#operation_definition =&gt; rules :: r#operation_definition (state) , Rule :: r#named_operation_definition =&gt; rules :: r#named_operation_definition (state) , Rule :: r#variable_definitions =&gt; rules :: r#variable_definitions (state) , Rule :: r#variable_definition =&gt; rules :: r#variable_definition (state) , Rule :: r#selection_set =&gt; rules :: r#selection_set (state) , Rule :: r#selection =&gt; rules :: r#selection (state) , Rule :: r#field =&gt; rules :: r#field (state) , Rule :: r#alias =&gt; rules :: r#alias (state) , Rule :: r#fragment_spread =&gt; rules :: r#fragment_spread (state) , Rule :: r#inline_fragment =&gt; rules :: r#inline_fragment (state) , Rule :: r#fragment_definition =&gt; rules :: r#fragment_definition (state) , Rule :: r#type_condition =&gt; rules :: r#type_condition (state) , Rule :: r#service_document =&gt; rules :: r#service_document (state) , Rule :: r#type_system_definition =&gt; rules :: r#type_system_definition (state) , Rule :: r#schema_definition =&gt; rules :: r#schema_definition (state) , Rule :: r#operation_type_definition =&gt; rules :: r#operation_type_definition (state) , Rule :: r#type_definition =&gt; rules :: r#type_definition (state) , Rule :: r#scalar_type =&gt; rules :: r#scalar_type (state) , Rule :: r#object_type =&gt; rules :: r#object_type (state) , Rule :: r#implements_interfaces =&gt; rules :: r#implements_interfaces (state) , Rule :: r#interface_type =&gt; rules :: r#interface_type (state) , Rule :: r#fields_definition =&gt; rules :: r#fields_definition (state) , Rule :: r#field_definition =&gt; rules :: r#field_definition (state) , Rule :: r#union_type =&gt; rules :: r#union_type (state) , Rule :: r#union_member_types =&gt; rules :: r#union_member_types (state) , Rule :: r#enum_type =&gt; rules :: r#enum_type (state) , Rule :: r#enum_values =&gt; rules :: r#enum_values (state) , Rule :: r#enum_value_definition =&gt; rules :: r#enum_value_definition (state) , Rule :: r#input_object_type =&gt; rules :: r#input_object_type (state) , Rule :: r#input_fields_definition =&gt; rules :: r#input_fields_definition (state) , Rule :: r#extend =&gt; rules :: r#extend (state) , Rule :: r#directive_definition =&gt; rules :: r#directive_definition (state) , Rule :: r#repeatable =&gt; rules :: r#repeatable (state) , Rule :: r#directive_locations =&gt; rules :: r#directive_locations (state) , Rule :: r#directive_location =&gt; rules :: r#directive_location (state) , Rule :: r#arguments_definition =&gt; rules :: r#arguments_definition (state) , Rule :: r#input_value_definition =&gt; rules :: r#input_value_definition (state) , Rule :: r#operation_type =&gt; rules :: r#operation_type (state) , Rule :: r#default_value =&gt; rules :: r#default_value (state) , Rule :: r#type_ =&gt; rules :: r#type_ (state) , Rule :: r#const_value =&gt; rules :: r#const_value (state) , Rule :: r#value =&gt; rules :: r#value (state) , Rule :: r#variable =&gt; rules :: r#variable (state) , Rule :: r#number =&gt; rules :: r#number (state) , Rule :: r#float =&gt; rules :: r#float (state) , Rule :: r#fractional =&gt; rules :: r#fractional (state) , Rule :: r#exponent =&gt; rules :: r#exponent (state) , Rule :: r#int =&gt; rules :: r#int (state) , Rule :: r#string =&gt; rules :: r#string (state) , Rule :: r#block_string_content =&gt; rules :: r#block_string_content (state) , Rule :: r#block_string_character =&gt; rules :: r#block_string_character (state) , Rule :: r#string_content =&gt; rules :: r#string_content (state) , Rule :: r#string_character =&gt; rules :: r#string_character (state) , Rule :: r#unicode_scalar_value_hex =&gt; rules :: r#unicode_scalar_value_hex (state) , Rule :: r#boolean =&gt; rules :: r#boolean (state) , Rule :: r#null =&gt; rules :: r#null (state) , Rule :: r#enum_value =&gt; rules :: r#enum_value (state) , Rule :: r#const_list =&gt; rules :: r#const_list (state) , Rule :: r#list =&gt; rules :: r#list (state) , Rule :: r#const_object =&gt; rules :: r#const_object (state) , Rule :: r#object =&gt; rules :: r#object (state) , Rule :: r#const_object_field =&gt; rules :: r#const_object_field (state) , Rule :: r#object_field =&gt; rules :: r#object_field (state) , Rule :: r#const_directives =&gt; rules :: r#const_directives (state) , Rule :: r#directives =&gt; rules :: r#directives (state) , Rule :: r#const_directive =&gt; rules :: r#const_directive (state) , Rule :: r#directive =&gt; rules :: r#directive (state) , Rule :: r#const_arguments =&gt; rules :: r#const_arguments (state) , Rule :: r#arguments =&gt; rules :: r#arguments (state) , Rule :: r#const_argument =&gt; rules :: r#const_argument (state) , Rule :: r#argument =&gt; rules :: r#argument (state) , Rule :: r#name_start =&gt; rules :: r#name_start (state) , Rule :: r#name =&gt; rules :: r#name (state) , Rule :: EOI =&gt; rules :: EOI (state) } }) } }</code></pre></div></section></main></body></html>
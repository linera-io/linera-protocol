<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/papaya-0.1.9/src/lib.rs`."><title>lib.rs - source</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-6c3ea77c.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="papaya" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0 (05f9846f8 2025-03-31)" data-channel="1.86.0" data-search-js="search-581efc7a.js" data-settings-js="settings-6dad6058.js" ><script src="../../static.files/storage-3a5871a4.js"></script><script defer src="../../static.files/src-script-b8d3f215.js"></script><script defer src="../../src-files.js"></script><script defer src="../../static.files/main-4d63596a.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc src"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="src-sidebar-title"><h2>Files</h2></div></nav><div class="sidebar-resizer"></div><main><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1><div class="sub-heading">papaya/</div>lib.rs</h1><rustdoc-toolbar></rustdoc-toolbar></div><div class="example-wrap digits-3"><pre class="rust"><code><a href=#1 id=1 data-nosnippet>1</a><span class="doccomment">//! A fast and ergonomic concurrent hash-table for read-heavy workloads.
<a href=#2 id=2 data-nosnippet>2</a>//!
<a href=#3 id=3 data-nosnippet>3</a>//! # Features
<a href=#4 id=4 data-nosnippet>4</a>//!
<a href=#5 id=5 data-nosnippet>5</a>//! - An ergonomic lock-free API â€” no more deadlocks!
<a href=#6 id=6 data-nosnippet>6</a>//! - Powerful atomic operations.
<a href=#7 id=7 data-nosnippet>7</a>//! - Seamless usage in async contexts.
<a href=#8 id=8 data-nosnippet>8</a>//! - Extremely scalable, low-latency reads (see [performance](#performance)).
<a href=#9 id=9 data-nosnippet>9</a>//! - Predictable latency across all operations.
<a href=#10 id=10 data-nosnippet>10</a>//! - Efficient memory usage, with garbage collection powered by [`seize`].
<a href=#11 id=11 data-nosnippet>11</a>//!
<a href=#12 id=12 data-nosnippet>12</a>//! # Overview
<a href=#13 id=13 data-nosnippet>13</a>//!
<a href=#14 id=14 data-nosnippet>14</a>//! The top-level crate documentation is organized as follows:
<a href=#15 id=15 data-nosnippet>15</a>//!
<a href=#16 id=16 data-nosnippet>16</a>//! - [Usage](#usage) shows how to interact with the concurrent `HashMap`.
<a href=#17 id=17 data-nosnippet>17</a>//! - [Consistency](#consistency) describes the guarantees of concurrent operations.
<a href=#18 id=18 data-nosnippet>18</a>//! - [Atomic Operations](#atomic-operations) shows how to perform dynamic operations atomically.
<a href=#19 id=19 data-nosnippet>19</a>//! - [Async Support](#async-support) shows how to use the map in an async context.
<a href=#20 id=20 data-nosnippet>20</a>//! - [Advanced Lifetimes](#advanced-lifetimes) explains how to use guards when working with nested types.
<a href=#21 id=21 data-nosnippet>21</a>//! - [Performance](#performance) provides details of expected performance characteristics.
<a href=#22 id=22 data-nosnippet>22</a>//!
<a href=#23 id=23 data-nosnippet>23</a>//! # Usage
<a href=#24 id=24 data-nosnippet>24</a>//!
<a href=#25 id=25 data-nosnippet>25</a>//! `papaya` aims to provide an ergonomic API without sacrificing performance. [`HashMap`] exposes a lock-free API, enabling it to hand out direct references to objects in the map without the need for wrapper types that are clunky and prone to deadlocks. However, you can't hold on to references forever due to concurrent removals. Because of this, the `HashMap` API is structured around *pinning*. Through a pin you can access the map just like a standard `HashMap`. A pin is similar to a lock guard, so any references that are returned will be tied to the lifetime of the guard. Unlike a lock however, pinning is cheap and can never cause deadlocks.
<a href=#26 id=26 data-nosnippet>26</a>//!
<a href=#27 id=27 data-nosnippet>27</a>//! ```rust
<a href=#28 id=28 data-nosnippet>28</a>//! use papaya::HashMap;
<a href=#29 id=29 data-nosnippet>29</a>//!
<a href=#30 id=30 data-nosnippet>30</a>//! // Create a map.
<a href=#31 id=31 data-nosnippet>31</a>//! let map = HashMap::new();
<a href=#32 id=32 data-nosnippet>32</a>//!
<a href=#33 id=33 data-nosnippet>33</a>//! // Pin the map.
<a href=#34 id=34 data-nosnippet>34</a>//! let map = map.pin();
<a href=#35 id=35 data-nosnippet>35</a>//!
<a href=#36 id=36 data-nosnippet>36</a>//! // Use the map as normal.
<a href=#37 id=37 data-nosnippet>37</a>//! map.insert('A', 1);
<a href=#38 id=38 data-nosnippet>38</a>//! assert_eq!(map.get(&amp;'A'), Some(&amp;1));
<a href=#39 id=39 data-nosnippet>39</a>//! assert_eq!(map.len(), 1);
<a href=#40 id=40 data-nosnippet>40</a>//! ```
<a href=#41 id=41 data-nosnippet>41</a>//!
<a href=#42 id=42 data-nosnippet>42</a>//! As expected of a concurrent `HashMap`, all operations take a shared reference. This allows the map to be freely pinned and accessed from multiple threads:
<a href=#43 id=43 data-nosnippet>43</a>//!
<a href=#44 id=44 data-nosnippet>44</a>//! ```rust
<a href=#45 id=45 data-nosnippet>45</a>//! use papaya::HashMap;
<a href=#46 id=46 data-nosnippet>46</a>//!
<a href=#47 id=47 data-nosnippet>47</a>//! // Use a map from multiple threads.
<a href=#48 id=48 data-nosnippet>48</a>//! let map = HashMap::new();
<a href=#49 id=49 data-nosnippet>49</a>//! std::thread::scope(|s| {
<a href=#50 id=50 data-nosnippet>50</a>//!     // Insert some values.
<a href=#51 id=51 data-nosnippet>51</a>//!     s.spawn(|| {
<a href=#52 id=52 data-nosnippet>52</a>//!         let map = map.pin();
<a href=#53 id=53 data-nosnippet>53</a>//!         for i in 'A'..='Z' {
<a href=#54 id=54 data-nosnippet>54</a>//!             map.insert(i, 1);
<a href=#55 id=55 data-nosnippet>55</a>//!         }
<a href=#56 id=56 data-nosnippet>56</a>//!     });
<a href=#57 id=57 data-nosnippet>57</a>//!
<a href=#58 id=58 data-nosnippet>58</a>//!     // Remove the values.
<a href=#59 id=59 data-nosnippet>59</a>//!     s.spawn(|| {
<a href=#60 id=60 data-nosnippet>60</a>//!         let map = map.pin();
<a href=#61 id=61 data-nosnippet>61</a>//!         for i in 'A'..='Z' {
<a href=#62 id=62 data-nosnippet>62</a>//!             map.remove(&amp;i);
<a href=#63 id=63 data-nosnippet>63</a>//!         }
<a href=#64 id=64 data-nosnippet>64</a>//!     });
<a href=#65 id=65 data-nosnippet>65</a>//!
<a href=#66 id=66 data-nosnippet>66</a>//!     // Read the values.
<a href=#67 id=67 data-nosnippet>67</a>//!     s.spawn(|| {
<a href=#68 id=68 data-nosnippet>68</a>//!         for (key, value) in map.pin().iter() {
<a href=#69 id=69 data-nosnippet>69</a>//!             println!("{key}: {value}");
<a href=#70 id=70 data-nosnippet>70</a>//!         }
<a href=#71 id=71 data-nosnippet>71</a>//!     });
<a href=#72 id=72 data-nosnippet>72</a>//! });
<a href=#73 id=73 data-nosnippet>73</a>//! ```
<a href=#74 id=74 data-nosnippet>74</a>//!
<a href=#75 id=75 data-nosnippet>75</a>//! It is important to note that as long as you are holding on to a guard, you are preventing the map from performing garbage collection. Pinning and unpinning the table is relatively cheap but not free, similar to the cost of locking and unlocking an uncontended or lightly contended `Mutex`. Thus guard reuse is encouraged, within reason. See the [`seize`] crate for advanced usage and specifics of the garbage collection algorithm.
<a href=#76 id=76 data-nosnippet>76</a>//!
<a href=#77 id=77 data-nosnippet>77</a>//! # Consistency
<a href=#78 id=78 data-nosnippet>78</a>//!
<a href=#79 id=79 data-nosnippet>79</a>//! Due to the concurrent nature of the map, read and write operations may overlap in time. There is no support for locking the entire table nor individual keys to prevent concurrent access, except through external fine-grained locking. As such, read operations (such as `get`) reflect the results of the *most-recent* write. More formally, a read establishes a *happens-before* relationship with the corresponding write.
<a href=#80 id=80 data-nosnippet>80</a>//!
<a href=#81 id=81 data-nosnippet>81</a>//! Aggregate operations, such as iterators, rely on a weak snapshot of the table and return results reflecting the state of the table at or some point after the creation of the iterator. This means that they may, but are not guaranteed to, reflect concurrent modifications to the table that occur during iteration. Similarly, operations such as `clear` and `clone` rely on iteration and may not produce "perfect" results if the map is being concurrently modified.
<a href=#82 id=82 data-nosnippet>82</a>//!
<a href=#83 id=83 data-nosnippet>83</a>//! Note that to obtain a stable snapshot of the table, aggregate table operations require completing any in-progress resizes. If you rely heavily on iteration or similar operations you should consider configuring [`ResizeMode::Blocking`].
<a href=#84 id=84 data-nosnippet>84</a>//!
<a href=#85 id=85 data-nosnippet>85</a>//! # Atomic Operations
<a href=#86 id=86 data-nosnippet>86</a>//!
<a href=#87 id=87 data-nosnippet>87</a>//! As mentioned above, `papaya` does not support locking keys to prevent access, which makes performing complex operations more challenging. Instead, `papaya` exposes a number of atomic operations. The most basic of these is [`HashMap::update`], which can be used to update an existing value in the map using a closure:
<a href=#88 id=88 data-nosnippet>88</a>//!
<a href=#89 id=89 data-nosnippet>89</a>//! ```rust
<a href=#90 id=90 data-nosnippet>90</a>//! let map = papaya::HashMap::new();
<a href=#91 id=91 data-nosnippet>91</a>//! map.pin().insert("poneyland", 42);
<a href=#92 id=92 data-nosnippet>92</a>//! assert_eq!(map.pin().update("poneyland", |e| e + 1), Some(&amp;43));
<a href=#93 id=93 data-nosnippet>93</a>//! ```
<a href=#94 id=94 data-nosnippet>94</a>//!
<a href=#95 id=95 data-nosnippet>95</a>//! Note that in the event that the entry is concurrently modified during an `update`, the closure may be called multiple times to retry the operation. For this reason, update operations are intended to be quick and *pure*, as they may be retried or internally memoized.
<a href=#96 id=96 data-nosnippet>96</a>//!
<a href=#97 id=97 data-nosnippet>97</a>//! `papaya` also exposes more powerful atomic operations that serve as a replacement for the [standard entry API](std::collections::hash_map::Entry). These include:
<a href=#98 id=98 data-nosnippet>98</a>//!
<a href=#99 id=99 data-nosnippet>99</a>//! - [`HashMap::update`]
<a href=#100 id=100 data-nosnippet>100</a>//! - [`HashMap::update_or_insert`]
<a href=#101 id=101 data-nosnippet>101</a>//! - [`HashMap::update_or_insert_with`]
<a href=#102 id=102 data-nosnippet>102</a>//! - [`HashMap::get_or_insert`]
<a href=#103 id=103 data-nosnippet>103</a>//! - [`HashMap::get_or_insert_with`]
<a href=#104 id=104 data-nosnippet>104</a>//! - [`HashMap::compute`]
<a href=#105 id=105 data-nosnippet>105</a>//!
<a href=#106 id=106 data-nosnippet>106</a>//! For example, with a standard `HashMap`, `Entry::and_modify` is often paired with `Entry::or_insert`:
<a href=#107 id=107 data-nosnippet>107</a>//!
<a href=#108 id=108 data-nosnippet>108</a>//! ```rust
<a href=#109 id=109 data-nosnippet>109</a>//! use std::collections::HashMap;
<a href=#110 id=110 data-nosnippet>110</a>//!
<a href=#111 id=111 data-nosnippet>111</a>//! let mut map = HashMap::new();
<a href=#112 id=112 data-nosnippet>112</a>//! // Insert `poneyland` with the value `42` if it doesn't exist,
<a href=#113 id=113 data-nosnippet>113</a>//! // otherwise increment it's value.
<a href=#114 id=114 data-nosnippet>114</a>//! map.entry("poneyland")
<a href=#115 id=115 data-nosnippet>115</a>//!    .and_modify(|e| { *e += 1 })
<a href=#116 id=116 data-nosnippet>116</a>//!    .or_insert(42);
<a href=#117 id=117 data-nosnippet>117</a>//! ```
<a href=#118 id=118 data-nosnippet>118</a>//!
<a href=#119 id=119 data-nosnippet>119</a>//! However, implementing this with a concurrent `HashMap` is tricky as the entry may be modified in-between operations. Instead, you can write the above operation using [`HashMap::update_or_insert`]:
<a href=#120 id=120 data-nosnippet>120</a>//!
<a href=#121 id=121 data-nosnippet>121</a>//! ```rust
<a href=#122 id=122 data-nosnippet>122</a>//! use papaya::HashMap;
<a href=#123 id=123 data-nosnippet>123</a>//!
<a href=#124 id=124 data-nosnippet>124</a>//! let map = HashMap::new();
<a href=#125 id=125 data-nosnippet>125</a>//! // Insert `poneyland` with the value `42` if it doesn't exist,
<a href=#126 id=126 data-nosnippet>126</a>//! // otherwise increment it's value.
<a href=#127 id=127 data-nosnippet>127</a>//! map.pin().update_or_insert("poneyland", |e| e + 1, 42);
<a href=#128 id=128 data-nosnippet>128</a>//! ```
<a href=#129 id=129 data-nosnippet>129</a>//!
<a href=#130 id=130 data-nosnippet>130</a>//! Atomic operations are extremely powerful but also easy to misuse. They may be less efficient than update mechanisms tailored for the specific type of data in the map. For example, concurrent counters should avoid using `update` and instead use `AtomicUsize`. Entries that are frequently modified may also benefit from fine-grained locking.
<a href=#131 id=131 data-nosnippet>131</a>//!
<a href=#132 id=132 data-nosnippet>132</a>//! # Async Support
<a href=#133 id=133 data-nosnippet>133</a>//!
<a href=#134 id=134 data-nosnippet>134</a>//! By default, a pinned map guard does not implement `Send` as it is tied to the current thread, similar to a lock guard. This leads to an issue in work-stealing schedulers as guards are not valid across `.await` points.
<a href=#135 id=135 data-nosnippet>135</a>//!
<a href=#136 id=136 data-nosnippet>136</a>//! To overcome this, you can use an *owned* guard.
<a href=#137 id=137 data-nosnippet>137</a>//!
<a href=#138 id=138 data-nosnippet>138</a>//! ```rust
<a href=#139 id=139 data-nosnippet>139</a>//! # use std::sync::Arc;
<a href=#140 id=140 data-nosnippet>140</a>//! use papaya::HashMap;
<a href=#141 id=141 data-nosnippet>141</a>//!
<a href=#142 id=142 data-nosnippet>142</a>//! async fn run(map: Arc&lt;HashMap&lt;i32, String&gt;&gt;) {
<a href=#143 id=143 data-nosnippet>143</a>//!     tokio::spawn(async move {
<a href=#144 id=144 data-nosnippet>144</a>//!         // Pin the map with an owned guard.
<a href=#145 id=145 data-nosnippet>145</a>//!         let map = map.pin_owned();
<a href=#146 id=146 data-nosnippet>146</a>//!
<a href=#147 id=147 data-nosnippet>147</a>//!         // Hold references across await points.
<a href=#148 id=148 data-nosnippet>148</a>//!         let value = map.get(&amp;37);
<a href=#149 id=149 data-nosnippet>149</a>//!         tokio::fs::write("db.txt", format!("{value:?}")).await;
<a href=#150 id=150 data-nosnippet>150</a>//!         println!("{value:?}");
<a href=#151 id=151 data-nosnippet>151</a>//!     });
<a href=#152 id=152 data-nosnippet>152</a>//! }
<a href=#153 id=153 data-nosnippet>153</a>//! ```
<a href=#154 id=154 data-nosnippet>154</a>//!
<a href=#155 id=155 data-nosnippet>155</a>//! Note that owned guards are more expensive to create than regular guards, so they should only be used if necessary. In the above example, you could instead drop the reference and call `get` a second time after the asynchronous call. A more fitting example involves asynchronous iteration:
<a href=#156 id=156 data-nosnippet>156</a>//!
<a href=#157 id=157 data-nosnippet>157</a>//! ```rust
<a href=#158 id=158 data-nosnippet>158</a>//! # use std::sync::Arc;
<a href=#159 id=159 data-nosnippet>159</a>//! use papaya::HashMap;
<a href=#160 id=160 data-nosnippet>160</a>//!
<a href=#161 id=161 data-nosnippet>161</a>//! async fn run(map: Arc&lt;HashMap&lt;i32, String&gt;&gt;) {
<a href=#162 id=162 data-nosnippet>162</a>//!     tokio::spawn(async move {
<a href=#163 id=163 data-nosnippet>163</a>//!         for (key, value) in map.pin_owned().iter() {
<a href=#164 id=164 data-nosnippet>164</a>//!             tokio::fs::write("db.txt", format!("{key}: {value}\n")).await;
<a href=#165 id=165 data-nosnippet>165</a>//!         }
<a href=#166 id=166 data-nosnippet>166</a>//!     });
<a href=#167 id=167 data-nosnippet>167</a>//! }
<a href=#168 id=168 data-nosnippet>168</a>//! ```
<a href=#169 id=169 data-nosnippet>169</a>//!
<a href=#170 id=170 data-nosnippet>170</a>//! # Advanced Lifetimes
<a href=#171 id=171 data-nosnippet>171</a>//!
<a href=#172 id=172 data-nosnippet>172</a>//! You may run into issues when you try to return a reference to a map contained within an outer type. For example:
<a href=#173 id=173 data-nosnippet>173</a>//!
<a href=#174 id=174 data-nosnippet>174</a>//! ```rust,compile_fail
<a href=#175 id=175 data-nosnippet>175</a>//! pub struct Metrics {
<a href=#176 id=176 data-nosnippet>176</a>//!     map: papaya::HashMap&lt;String, Vec&lt;u64&gt;&gt;
<a href=#177 id=177 data-nosnippet>177</a>//! }
<a href=#178 id=178 data-nosnippet>178</a>//!
<a href=#179 id=179 data-nosnippet>179</a>//! impl Metrics {
<a href=#180 id=180 data-nosnippet>180</a>//!     pub fn get(&amp;self, name: &amp;str) -&gt; Option&lt;&amp;[u64]&gt; {
<a href=#181 id=181 data-nosnippet>181</a>//!         // error[E0515]: cannot return value referencing temporary value
<a href=#182 id=182 data-nosnippet>182</a>//!         Some(self.map.pin().get(name)?.as_slice())
<a href=#183 id=183 data-nosnippet>183</a>//!     }
<a href=#184 id=184 data-nosnippet>184</a>//! }
<a href=#185 id=185 data-nosnippet>185</a>//! ```
<a href=#186 id=186 data-nosnippet>186</a>//!
<a href=#187 id=187 data-nosnippet>187</a>//! The solution is to accept a guard in the method directly, tying the lifetime to the caller's stack frame:
<a href=#188 id=188 data-nosnippet>188</a>//!
<a href=#189 id=189 data-nosnippet>189</a>//! ```rust
<a href=#190 id=190 data-nosnippet>190</a>//! use papaya::Guard;
<a href=#191 id=191 data-nosnippet>191</a>//!
<a href=#192 id=192 data-nosnippet>192</a>//! pub struct Metrics {
<a href=#193 id=193 data-nosnippet>193</a>//!     map: papaya::HashMap&lt;String, Vec&lt;u64&gt;&gt;
<a href=#194 id=194 data-nosnippet>194</a>//! }
<a href=#195 id=195 data-nosnippet>195</a>//!
<a href=#196 id=196 data-nosnippet>196</a>//! impl Metrics {
<a href=#197 id=197 data-nosnippet>197</a>//!     pub fn guard(&amp;self) -&gt; impl Guard + '_ {
<a href=#198 id=198 data-nosnippet>198</a>//!         self.map.guard()
<a href=#199 id=199 data-nosnippet>199</a>//!     }
<a href=#200 id=200 data-nosnippet>200</a>//!
<a href=#201 id=201 data-nosnippet>201</a>//!     pub fn get&lt;'guard&gt;(&amp;self, name: &amp;str, guard: &amp;'guard impl Guard) -&gt; Option&lt;&amp;'guard [u64]&gt; {
<a href=#202 id=202 data-nosnippet>202</a>//!         Some(self.map.get(name, guard)?.as_slice())
<a href=#203 id=203 data-nosnippet>203</a>//!     }
<a href=#204 id=204 data-nosnippet>204</a>//! }
<a href=#205 id=205 data-nosnippet>205</a>//! ```
<a href=#206 id=206 data-nosnippet>206</a>//!
<a href=#207 id=207 data-nosnippet>207</a>//! The `Guard` trait supports both local and owned guards. Note the `'guard` lifetime that ties the guard to the returned reference. No wrapper types or guard mapping is necessary.
<a href=#208 id=208 data-nosnippet>208</a>//!
<a href=#209 id=209 data-nosnippet>209</a>//! # Performance
<a href=#210 id=210 data-nosnippet>210</a>//!
<a href=#211 id=211 data-nosnippet>211</a>//! `papaya` is built with read-heavy workloads in mind. As such, read operations are extremely high throughput and provide consistent performance that scales with concurrency, meaning `papaya` will excel in workloads where reads are more common than writes. In write heavy workloads, `papaya` will still provide competitive performance despite not being it's primary use case. See the [benchmarks] for details.
<a href=#212 id=212 data-nosnippet>212</a>//!
<a href=#213 id=213 data-nosnippet>213</a>//! `papaya` aims to provide predictable and consistent latency across all operations. Most operations are lock-free, and those that aren't only block under rare and constrained conditions. `papaya` also features [incremental resizing](ResizeMode). Predictable latency is an important part of performance that doesn't often show up in benchmarks, but has significant implications for real-world usage.
<a href=#214 id=214 data-nosnippet>214</a>//!
<a href=#215 id=215 data-nosnippet>215</a>//! [benchmarks]: https://github.com/ibraheemdev/papaya/blob/master/BENCHMARKS.md
<a href=#216 id=216 data-nosnippet>216</a>
<a href=#217 id=217 data-nosnippet>217</a></span><span class="attr">#![deny(
<a href=#218 id=218 data-nosnippet>218</a>    missing_debug_implementations,
<a href=#219 id=219 data-nosnippet>219</a>    missing_docs,
<a href=#220 id=220 data-nosnippet>220</a>    dead_code,
<a href=#221 id=221 data-nosnippet>221</a>    unsafe_op_in_unsafe_fn
<a href=#222 id=222 data-nosnippet>222</a>)]
<a href=#223 id=223 data-nosnippet>223</a></span><span class="comment">// Polyfills for unstable APIs related to strict-provenance.
<a href=#224 id=224 data-nosnippet>224</a></span><span class="attr">#![allow(unstable_name_collisions)]
<a href=#225 id=225 data-nosnippet>225</a></span><span class="comment">// Stylistic preferences.
<a href=#226 id=226 data-nosnippet>226</a></span><span class="attr">#![allow(clippy::multiple_bound_locations, clippy::single_match)]
<a href=#227 id=227 data-nosnippet>227</a>
<a href=#228 id=228 data-nosnippet>228</a></span><span class="kw">mod </span>map;
<a href=#229 id=229 data-nosnippet>229</a><span class="kw">mod </span>raw;
<a href=#230 id=230 data-nosnippet>230</a><span class="kw">mod </span>set;
<a href=#231 id=231 data-nosnippet>231</a>
<a href=#232 id=232 data-nosnippet>232</a><span class="attr">#[cfg(feature = <span class="string">"serde"</span>)]
<a href=#233 id=233 data-nosnippet>233</a></span><span class="kw">mod </span>serde_impls;
<a href=#234 id=234 data-nosnippet>234</a>
<a href=#235 id=235 data-nosnippet>235</a><span class="kw">pub use </span>equivalent::Equivalent;
<a href=#236 id=236 data-nosnippet>236</a><span class="kw">pub use </span>map::{
<a href=#237 id=237 data-nosnippet>237</a>    Compute, HashMap, HashMapBuilder, HashMapRef, Iter, Keys, OccupiedError, Operation, ResizeMode,
<a href=#238 id=238 data-nosnippet>238</a>    Values,
<a href=#239 id=239 data-nosnippet>239</a>};
<a href=#240 id=240 data-nosnippet>240</a><span class="kw">pub use </span>seize::{Guard, LocalGuard, OwnedGuard};
<a href=#241 id=241 data-nosnippet>241</a><span class="kw">pub use </span>set::{HashSet, HashSetBuilder, HashSetRef};</code></pre></div></section></main></body></html>
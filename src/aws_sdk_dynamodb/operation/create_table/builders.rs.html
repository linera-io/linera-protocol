<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/aws-sdk-dynamodb-1.88.0/src/operation/create_table/builders.rs`."><title>builders.rs - source</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../../static.files/rustdoc-6c3ea77c.css"><meta name="rustdoc-vars" data-root-path="../../../../" data-static-root-path="../../../../static.files/" data-current-crate="aws_sdk_dynamodb" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0 (05f9846f8 2025-03-31)" data-channel="1.86.0" data-search-js="search-581efc7a.js" data-settings-js="settings-6dad6058.js" ><script src="../../../../static.files/storage-3a5871a4.js"></script><script defer src="../../../../static.files/src-script-b8d3f215.js"></script><script defer src="../../../../src-files.js"></script><script defer src="../../../../static.files/main-4d63596a.js"></script><noscript><link rel="stylesheet" href="../../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../../static.files/favicon-044be391.svg"></head><body class="rustdoc src"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="src-sidebar-title"><h2>Files</h2></div></nav><div class="sidebar-resizer"></div><main><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1><div class="sub-heading">aws_sdk_dynamodb/operation/create_table/</div>builders.rs</h1><rustdoc-toolbar></rustdoc-toolbar></div><div class="example-wrap digits-3"><pre class="rust"><code><a href=#1 id=1 data-nosnippet>1</a><span class="comment">// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
<a href=#2 id=2 data-nosnippet>2</a></span><span class="kw">pub use </span><span class="kw">crate</span>::operation::create_table::_create_table_output::CreateTableOutputBuilder;
<a href=#3 id=3 data-nosnippet>3</a>
<a href=#4 id=4 data-nosnippet>4</a><span class="kw">pub use </span><span class="kw">crate</span>::operation::create_table::_create_table_input::CreateTableInputBuilder;
<a href=#5 id=5 data-nosnippet>5</a>
<a href=#6 id=6 data-nosnippet>6</a><span class="kw">impl </span><span class="kw">crate</span>::operation::create_table::builders::CreateTableInputBuilder {
<a href=#7 id=7 data-nosnippet>7</a>    <span class="doccomment">/// Sends a request with this input using the given client.
<a href=#8 id=8 data-nosnippet>8</a>    </span><span class="kw">pub async fn </span>send_with(
<a href=#9 id=9 data-nosnippet>9</a>        <span class="self">self</span>,
<a href=#10 id=10 data-nosnippet>10</a>        client: <span class="kw-2">&amp;</span><span class="kw">crate</span>::Client,
<a href=#11 id=11 data-nosnippet>11</a>    ) -&gt; ::std::result::Result&lt;
<a href=#12 id=12 data-nosnippet>12</a>        <span class="kw">crate</span>::operation::create_table::CreateTableOutput,
<a href=#13 id=13 data-nosnippet>13</a>        ::aws_smithy_runtime_api::client::result::SdkError&lt;
<a href=#14 id=14 data-nosnippet>14</a>            <span class="kw">crate</span>::operation::create_table::CreateTableError,
<a href=#15 id=15 data-nosnippet>15</a>            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
<a href=#16 id=16 data-nosnippet>16</a>        &gt;,
<a href=#17 id=17 data-nosnippet>17</a>    &gt; {
<a href=#18 id=18 data-nosnippet>18</a>        <span class="kw">let </span><span class="kw-2">mut </span>fluent_builder = client.create_table();
<a href=#19 id=19 data-nosnippet>19</a>        fluent_builder.inner = <span class="self">self</span>;
<a href=#20 id=20 data-nosnippet>20</a>        fluent_builder.send().<span class="kw">await
<a href=#21 id=21 data-nosnippet>21</a>    </span>}
<a href=#22 id=22 data-nosnippet>22</a>}
<a href=#23 id=23 data-nosnippet>23</a><span class="doccomment">/// Fluent builder constructing a request to `CreateTable`.
<a href=#24 id=24 data-nosnippet>24</a>///
<a href=#25 id=25 data-nosnippet>25</a>/// &lt;p&gt;The &lt;code&gt;CreateTable&lt;/code&gt; operation adds a new table to your account. In an Amazon Web Services account, table names must be unique within each Region. That is, you can have two tables with same name if you create the tables in different Regions.&lt;/p&gt;
<a href=#26 id=26 data-nosnippet>26</a>/// &lt;p&gt;&lt;code&gt;CreateTable&lt;/code&gt; is an asynchronous operation. Upon receiving a &lt;code&gt;CreateTable&lt;/code&gt; request, DynamoDB immediately returns a response with a &lt;code&gt;TableStatus&lt;/code&gt; of &lt;code&gt;CREATING&lt;/code&gt;. After the table is created, DynamoDB sets the &lt;code&gt;TableStatus&lt;/code&gt; to &lt;code&gt;ACTIVE&lt;/code&gt;. You can perform read and write operations only on an &lt;code&gt;ACTIVE&lt;/code&gt; table.&lt;/p&gt;
<a href=#27 id=27 data-nosnippet>27</a>/// &lt;p&gt;You can optionally define secondary indexes on the new table, as part of the &lt;code&gt;CreateTable&lt;/code&gt; operation. If you want to create multiple tables with secondary indexes on them, you must create the tables sequentially. Only one table with secondary indexes can be in the &lt;code&gt;CREATING&lt;/code&gt; state at any given time.&lt;/p&gt;
<a href=#28 id=28 data-nosnippet>28</a>/// &lt;p&gt;You can use the &lt;code&gt;DescribeTable&lt;/code&gt; action to check the table status.&lt;/p&gt;
<a href=#29 id=29 data-nosnippet>29</a></span><span class="attr">#[derive(::std::clone::Clone, ::std::fmt::Debug)]
<a href=#30 id=30 data-nosnippet>30</a></span><span class="kw">pub struct </span>CreateTableFluentBuilder {
<a href=#31 id=31 data-nosnippet>31</a>    handle: ::std::sync::Arc&lt;<span class="kw">crate</span>::client::Handle&gt;,
<a href=#32 id=32 data-nosnippet>32</a>    inner: <span class="kw">crate</span>::operation::create_table::builders::CreateTableInputBuilder,
<a href=#33 id=33 data-nosnippet>33</a>    config_override: ::std::option::Option&lt;<span class="kw">crate</span>::config::Builder&gt;,
<a href=#34 id=34 data-nosnippet>34</a>}
<a href=#35 id=35 data-nosnippet>35</a><span class="kw">impl
<a href=#36 id=36 data-nosnippet>36</a>    </span><span class="kw">crate</span>::client::customize::internal::CustomizableSend&lt;
<a href=#37 id=37 data-nosnippet>37</a>        <span class="kw">crate</span>::operation::create_table::CreateTableOutput,
<a href=#38 id=38 data-nosnippet>38</a>        <span class="kw">crate</span>::operation::create_table::CreateTableError,
<a href=#39 id=39 data-nosnippet>39</a>    &gt; <span class="kw">for </span>CreateTableFluentBuilder
<a href=#40 id=40 data-nosnippet>40</a>{
<a href=#41 id=41 data-nosnippet>41</a>    <span class="kw">fn </span>send(
<a href=#42 id=42 data-nosnippet>42</a>        <span class="self">self</span>,
<a href=#43 id=43 data-nosnippet>43</a>        config_override: <span class="kw">crate</span>::config::Builder,
<a href=#44 id=44 data-nosnippet>44</a>    ) -&gt; <span class="kw">crate</span>::client::customize::internal::BoxFuture&lt;
<a href=#45 id=45 data-nosnippet>45</a>        <span class="kw">crate</span>::client::customize::internal::SendResult&lt;
<a href=#46 id=46 data-nosnippet>46</a>            <span class="kw">crate</span>::operation::create_table::CreateTableOutput,
<a href=#47 id=47 data-nosnippet>47</a>            <span class="kw">crate</span>::operation::create_table::CreateTableError,
<a href=#48 id=48 data-nosnippet>48</a>        &gt;,
<a href=#49 id=49 data-nosnippet>49</a>    &gt; {
<a href=#50 id=50 data-nosnippet>50</a>        ::std::boxed::Box::pin(<span class="kw">async move </span>{ <span class="self">self</span>.config_override(config_override).send().<span class="kw">await </span>})
<a href=#51 id=51 data-nosnippet>51</a>    }
<a href=#52 id=52 data-nosnippet>52</a>}
<a href=#53 id=53 data-nosnippet>53</a><span class="kw">impl </span>CreateTableFluentBuilder {
<a href=#54 id=54 data-nosnippet>54</a>    <span class="doccomment">/// Creates a new `CreateTableFluentBuilder`.
<a href=#55 id=55 data-nosnippet>55</a>    </span><span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>new(handle: ::std::sync::Arc&lt;<span class="kw">crate</span>::client::Handle&gt;) -&gt; <span class="self">Self </span>{
<a href=#56 id=56 data-nosnippet>56</a>        <span class="self">Self </span>{
<a href=#57 id=57 data-nosnippet>57</a>            handle,
<a href=#58 id=58 data-nosnippet>58</a>            inner: ::std::default::Default::default(),
<a href=#59 id=59 data-nosnippet>59</a>            config_override: ::std::option::Option::None,
<a href=#60 id=60 data-nosnippet>60</a>        }
<a href=#61 id=61 data-nosnippet>61</a>    }
<a href=#62 id=62 data-nosnippet>62</a>    <span class="doccomment">/// Access the CreateTable as a reference.
<a href=#63 id=63 data-nosnippet>63</a>    </span><span class="kw">pub fn </span>as_input(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span><span class="kw">crate</span>::operation::create_table::builders::CreateTableInputBuilder {
<a href=#64 id=64 data-nosnippet>64</a>        <span class="kw-2">&amp;</span><span class="self">self</span>.inner
<a href=#65 id=65 data-nosnippet>65</a>    }
<a href=#66 id=66 data-nosnippet>66</a>    <span class="doccomment">/// Sends the request and returns the response.
<a href=#67 id=67 data-nosnippet>67</a>    ///
<a href=#68 id=68 data-nosnippet>68</a>    /// If an error occurs, an `SdkError` will be returned with additional details that
<a href=#69 id=69 data-nosnippet>69</a>    /// can be matched against.
<a href=#70 id=70 data-nosnippet>70</a>    ///
<a href=#71 id=71 data-nosnippet>71</a>    /// By default, any retryable failures will be retried twice. Retry behavior
<a href=#72 id=72 data-nosnippet>72</a>    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
<a href=#73 id=73 data-nosnippet>73</a>    /// set when configuring the client.
<a href=#74 id=74 data-nosnippet>74</a>    </span><span class="kw">pub async fn </span>send(
<a href=#75 id=75 data-nosnippet>75</a>        <span class="self">self</span>,
<a href=#76 id=76 data-nosnippet>76</a>    ) -&gt; ::std::result::Result&lt;
<a href=#77 id=77 data-nosnippet>77</a>        <span class="kw">crate</span>::operation::create_table::CreateTableOutput,
<a href=#78 id=78 data-nosnippet>78</a>        ::aws_smithy_runtime_api::client::result::SdkError&lt;
<a href=#79 id=79 data-nosnippet>79</a>            <span class="kw">crate</span>::operation::create_table::CreateTableError,
<a href=#80 id=80 data-nosnippet>80</a>            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
<a href=#81 id=81 data-nosnippet>81</a>        &gt;,
<a href=#82 id=82 data-nosnippet>82</a>    &gt; {
<a href=#83 id=83 data-nosnippet>83</a>        <span class="kw">let </span>input = <span class="self">self
<a href=#84 id=84 data-nosnippet>84</a>            </span>.inner
<a href=#85 id=85 data-nosnippet>85</a>            .build()
<a href=#86 id=86 data-nosnippet>86</a>            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)<span class="question-mark">?</span>;
<a href=#87 id=87 data-nosnippet>87</a>        <span class="kw">let </span>runtime_plugins = <span class="kw">crate</span>::operation::create_table::CreateTable::operation_runtime_plugins(
<a href=#88 id=88 data-nosnippet>88</a>            <span class="self">self</span>.handle.runtime_plugins.clone(),
<a href=#89 id=89 data-nosnippet>89</a>            <span class="kw-2">&amp;</span><span class="self">self</span>.handle.conf,
<a href=#90 id=90 data-nosnippet>90</a>            <span class="self">self</span>.config_override,
<a href=#91 id=91 data-nosnippet>91</a>        );
<a href=#92 id=92 data-nosnippet>92</a>        <span class="kw">crate</span>::operation::create_table::CreateTable::orchestrate(<span class="kw-2">&amp;</span>runtime_plugins, input).<span class="kw">await
<a href=#93 id=93 data-nosnippet>93</a>    </span>}
<a href=#94 id=94 data-nosnippet>94</a>
<a href=#95 id=95 data-nosnippet>95</a>    <span class="doccomment">/// Consumes this builder, creating a customizable operation that can be modified before being sent.
<a href=#96 id=96 data-nosnippet>96</a>    </span><span class="kw">pub fn </span>customize(
<a href=#97 id=97 data-nosnippet>97</a>        <span class="self">self</span>,
<a href=#98 id=98 data-nosnippet>98</a>    ) -&gt; <span class="kw">crate</span>::client::customize::CustomizableOperation&lt;
<a href=#99 id=99 data-nosnippet>99</a>        <span class="kw">crate</span>::operation::create_table::CreateTableOutput,
<a href=#100 id=100 data-nosnippet>100</a>        <span class="kw">crate</span>::operation::create_table::CreateTableError,
<a href=#101 id=101 data-nosnippet>101</a>        <span class="self">Self</span>,
<a href=#102 id=102 data-nosnippet>102</a>    &gt; {
<a href=#103 id=103 data-nosnippet>103</a>        <span class="kw">crate</span>::client::customize::CustomizableOperation::new(<span class="self">self</span>)
<a href=#104 id=104 data-nosnippet>104</a>    }
<a href=#105 id=105 data-nosnippet>105</a>    <span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>config_override(<span class="kw-2">mut </span><span class="self">self</span>, config_override: <span class="kw">impl </span>::std::convert::Into&lt;<span class="kw">crate</span>::config::Builder&gt;) -&gt; <span class="self">Self </span>{
<a href=#106 id=106 data-nosnippet>106</a>        <span class="self">self</span>.set_config_override(::std::option::Option::Some(config_override.into()));
<a href=#107 id=107 data-nosnippet>107</a>        <span class="self">self
<a href=#108 id=108 data-nosnippet>108</a>    </span>}
<a href=#109 id=109 data-nosnippet>109</a>
<a href=#110 id=110 data-nosnippet>110</a>    <span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn </span>set_config_override(<span class="kw-2">&amp;mut </span><span class="self">self</span>, config_override: ::std::option::Option&lt;<span class="kw">crate</span>::config::Builder&gt;) -&gt; <span class="kw-2">&amp;mut </span><span class="self">Self </span>{
<a href=#111 id=111 data-nosnippet>111</a>        <span class="self">self</span>.config_override = config_override;
<a href=#112 id=112 data-nosnippet>112</a>        <span class="self">self
<a href=#113 id=113 data-nosnippet>113</a>    </span>}
<a href=#114 id=114 data-nosnippet>114</a>    <span class="doccomment">///
<a href=#115 id=115 data-nosnippet>115</a>    /// Appends an item to `AttributeDefinitions`.
<a href=#116 id=116 data-nosnippet>116</a>    ///
<a href=#117 id=117 data-nosnippet>117</a>    /// To override the contents of this collection use [`set_attribute_definitions`](Self::set_attribute_definitions).
<a href=#118 id=118 data-nosnippet>118</a>    ///
<a href=#119 id=119 data-nosnippet>119</a>    /// &lt;p&gt;An array of attributes that describe the key schema for the table and indexes.&lt;/p&gt;
<a href=#120 id=120 data-nosnippet>120</a>    </span><span class="kw">pub fn </span>attribute_definitions(<span class="kw-2">mut </span><span class="self">self</span>, input: <span class="kw">crate</span>::types::AttributeDefinition) -&gt; <span class="self">Self </span>{
<a href=#121 id=121 data-nosnippet>121</a>        <span class="self">self</span>.inner = <span class="self">self</span>.inner.attribute_definitions(input);
<a href=#122 id=122 data-nosnippet>122</a>        <span class="self">self
<a href=#123 id=123 data-nosnippet>123</a>    </span>}
<a href=#124 id=124 data-nosnippet>124</a>    <span class="doccomment">/// &lt;p&gt;An array of attributes that describe the key schema for the table and indexes.&lt;/p&gt;
<a href=#125 id=125 data-nosnippet>125</a>    </span><span class="kw">pub fn </span>set_attribute_definitions(<span class="kw-2">mut </span><span class="self">self</span>, input: ::std::option::Option&lt;::std::vec::Vec&lt;<span class="kw">crate</span>::types::AttributeDefinition&gt;&gt;) -&gt; <span class="self">Self </span>{
<a href=#126 id=126 data-nosnippet>126</a>        <span class="self">self</span>.inner = <span class="self">self</span>.inner.set_attribute_definitions(input);
<a href=#127 id=127 data-nosnippet>127</a>        <span class="self">self
<a href=#128 id=128 data-nosnippet>128</a>    </span>}
<a href=#129 id=129 data-nosnippet>129</a>    <span class="doccomment">/// &lt;p&gt;An array of attributes that describe the key schema for the table and indexes.&lt;/p&gt;
<a href=#130 id=130 data-nosnippet>130</a>    </span><span class="kw">pub fn </span>get_attribute_definitions(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span>::std::option::Option&lt;::std::vec::Vec&lt;<span class="kw">crate</span>::types::AttributeDefinition&gt;&gt; {
<a href=#131 id=131 data-nosnippet>131</a>        <span class="self">self</span>.inner.get_attribute_definitions()
<a href=#132 id=132 data-nosnippet>132</a>    }
<a href=#133 id=133 data-nosnippet>133</a>    <span class="doccomment">/// &lt;p&gt;The name of the table to create. You can also provide the Amazon Resource Name (ARN) of the table in this parameter.&lt;/p&gt;
<a href=#134 id=134 data-nosnippet>134</a>    </span><span class="kw">pub fn </span>table_name(<span class="kw-2">mut </span><span class="self">self</span>, input: <span class="kw">impl </span>::std::convert::Into&lt;::std::string::String&gt;) -&gt; <span class="self">Self </span>{
<a href=#135 id=135 data-nosnippet>135</a>        <span class="self">self</span>.inner = <span class="self">self</span>.inner.table_name(input.into());
<a href=#136 id=136 data-nosnippet>136</a>        <span class="self">self
<a href=#137 id=137 data-nosnippet>137</a>    </span>}
<a href=#138 id=138 data-nosnippet>138</a>    <span class="doccomment">/// &lt;p&gt;The name of the table to create. You can also provide the Amazon Resource Name (ARN) of the table in this parameter.&lt;/p&gt;
<a href=#139 id=139 data-nosnippet>139</a>    </span><span class="kw">pub fn </span>set_table_name(<span class="kw-2">mut </span><span class="self">self</span>, input: ::std::option::Option&lt;::std::string::String&gt;) -&gt; <span class="self">Self </span>{
<a href=#140 id=140 data-nosnippet>140</a>        <span class="self">self</span>.inner = <span class="self">self</span>.inner.set_table_name(input);
<a href=#141 id=141 data-nosnippet>141</a>        <span class="self">self
<a href=#142 id=142 data-nosnippet>142</a>    </span>}
<a href=#143 id=143 data-nosnippet>143</a>    <span class="doccomment">/// &lt;p&gt;The name of the table to create. You can also provide the Amazon Resource Name (ARN) of the table in this parameter.&lt;/p&gt;
<a href=#144 id=144 data-nosnippet>144</a>    </span><span class="kw">pub fn </span>get_table_name(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span>::std::option::Option&lt;::std::string::String&gt; {
<a href=#145 id=145 data-nosnippet>145</a>        <span class="self">self</span>.inner.get_table_name()
<a href=#146 id=146 data-nosnippet>146</a>    }
<a href=#147 id=147 data-nosnippet>147</a>    <span class="doccomment">///
<a href=#148 id=148 data-nosnippet>148</a>    /// Appends an item to `KeySchema`.
<a href=#149 id=149 data-nosnippet>149</a>    ///
<a href=#150 id=150 data-nosnippet>150</a>    /// To override the contents of this collection use [`set_key_schema`](Self::set_key_schema).
<a href=#151 id=151 data-nosnippet>151</a>    ///
<a href=#152 id=152 data-nosnippet>152</a>    /// &lt;p&gt;Specifies the attributes that make up the primary key for a table or an index. The attributes in &lt;code&gt;KeySchema&lt;/code&gt; must also be defined in the &lt;code&gt;AttributeDefinitions&lt;/code&gt; array. For more information, see &lt;a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DataModel.html"&gt;Data Model&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;.&lt;/p&gt;
<a href=#153 id=153 data-nosnippet>153</a>    /// &lt;p&gt;Each &lt;code&gt;KeySchemaElement&lt;/code&gt; in the array is composed of:&lt;/p&gt;
<a href=#154 id=154 data-nosnippet>154</a>    /// &lt;ul&gt;
<a href=#155 id=155 data-nosnippet>155</a>    /// &lt;li&gt;
<a href=#156 id=156 data-nosnippet>156</a>    /// &lt;p&gt;&lt;code&gt;AttributeName&lt;/code&gt; - The name of this key attribute.&lt;/p&gt;&lt;/li&gt;
<a href=#157 id=157 data-nosnippet>157</a>    /// &lt;li&gt;
<a href=#158 id=158 data-nosnippet>158</a>    /// &lt;p&gt;&lt;code&gt;KeyType&lt;/code&gt; - The role that the key attribute will assume:&lt;/p&gt;
<a href=#159 id=159 data-nosnippet>159</a>    /// &lt;ul&gt;
<a href=#160 id=160 data-nosnippet>160</a>    /// &lt;li&gt;
<a href=#161 id=161 data-nosnippet>161</a>    /// &lt;p&gt;&lt;code&gt;HASH&lt;/code&gt; - partition key&lt;/p&gt;&lt;/li&gt;
<a href=#162 id=162 data-nosnippet>162</a>    /// &lt;li&gt;
<a href=#163 id=163 data-nosnippet>163</a>    /// &lt;p&gt;&lt;code&gt;RANGE&lt;/code&gt; - sort key&lt;/p&gt;&lt;/li&gt;
<a href=#164 id=164 data-nosnippet>164</a>    /// &lt;/ul&gt;&lt;/li&gt;
<a href=#165 id=165 data-nosnippet>165</a>    /// &lt;/ul&gt;&lt;note&gt;
<a href=#166 id=166 data-nosnippet>166</a>    /// &lt;p&gt;The partition key of an item is also known as its &lt;i&gt;hash attribute&lt;/i&gt;. The term "hash attribute" derives from the DynamoDB usage of an internal hash function to evenly distribute data items across partitions, based on their partition key values.&lt;/p&gt;
<a href=#167 id=167 data-nosnippet>167</a>    /// &lt;p&gt;The sort key of an item is also known as its &lt;i&gt;range attribute&lt;/i&gt;. The term "range attribute" derives from the way DynamoDB stores items with the same partition key physically close together, in sorted order by the sort key value.&lt;/p&gt;
<a href=#168 id=168 data-nosnippet>168</a>    /// &lt;/note&gt;
<a href=#169 id=169 data-nosnippet>169</a>    /// &lt;p&gt;For a simple primary key (partition key), you must provide exactly one element with a &lt;code&gt;KeyType&lt;/code&gt; of &lt;code&gt;HASH&lt;/code&gt;.&lt;/p&gt;
<a href=#170 id=170 data-nosnippet>170</a>    /// &lt;p&gt;For a composite primary key (partition key and sort key), you must provide exactly two elements, in this order: The first element must have a &lt;code&gt;KeyType&lt;/code&gt; of &lt;code&gt;HASH&lt;/code&gt;, and the second element must have a &lt;code&gt;KeyType&lt;/code&gt; of &lt;code&gt;RANGE&lt;/code&gt;.&lt;/p&gt;
<a href=#171 id=171 data-nosnippet>171</a>    /// &lt;p&gt;For more information, see &lt;a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#WorkingWithTables.primary.key"&gt;Working with Tables&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;.&lt;/p&gt;
<a href=#172 id=172 data-nosnippet>172</a>    </span><span class="kw">pub fn </span>key_schema(<span class="kw-2">mut </span><span class="self">self</span>, input: <span class="kw">crate</span>::types::KeySchemaElement) -&gt; <span class="self">Self </span>{
<a href=#173 id=173 data-nosnippet>173</a>        <span class="self">self</span>.inner = <span class="self">self</span>.inner.key_schema(input);
<a href=#174 id=174 data-nosnippet>174</a>        <span class="self">self
<a href=#175 id=175 data-nosnippet>175</a>    </span>}
<a href=#176 id=176 data-nosnippet>176</a>    <span class="doccomment">/// &lt;p&gt;Specifies the attributes that make up the primary key for a table or an index. The attributes in &lt;code&gt;KeySchema&lt;/code&gt; must also be defined in the &lt;code&gt;AttributeDefinitions&lt;/code&gt; array. For more information, see &lt;a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DataModel.html"&gt;Data Model&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;.&lt;/p&gt;
<a href=#177 id=177 data-nosnippet>177</a>    /// &lt;p&gt;Each &lt;code&gt;KeySchemaElement&lt;/code&gt; in the array is composed of:&lt;/p&gt;
<a href=#178 id=178 data-nosnippet>178</a>    /// &lt;ul&gt;
<a href=#179 id=179 data-nosnippet>179</a>    /// &lt;li&gt;
<a href=#180 id=180 data-nosnippet>180</a>    /// &lt;p&gt;&lt;code&gt;AttributeName&lt;/code&gt; - The name of this key attribute.&lt;/p&gt;&lt;/li&gt;
<a href=#181 id=181 data-nosnippet>181</a>    /// &lt;li&gt;
<a href=#182 id=182 data-nosnippet>182</a>    /// &lt;p&gt;&lt;code&gt;KeyType&lt;/code&gt; - The role that the key attribute will assume:&lt;/p&gt;
<a href=#183 id=183 data-nosnippet>183</a>    /// &lt;ul&gt;
<a href=#184 id=184 data-nosnippet>184</a>    /// &lt;li&gt;
<a href=#185 id=185 data-nosnippet>185</a>    /// &lt;p&gt;&lt;code&gt;HASH&lt;/code&gt; - partition key&lt;/p&gt;&lt;/li&gt;
<a href=#186 id=186 data-nosnippet>186</a>    /// &lt;li&gt;
<a href=#187 id=187 data-nosnippet>187</a>    /// &lt;p&gt;&lt;code&gt;RANGE&lt;/code&gt; - sort key&lt;/p&gt;&lt;/li&gt;
<a href=#188 id=188 data-nosnippet>188</a>    /// &lt;/ul&gt;&lt;/li&gt;
<a href=#189 id=189 data-nosnippet>189</a>    /// &lt;/ul&gt;&lt;note&gt;
<a href=#190 id=190 data-nosnippet>190</a>    /// &lt;p&gt;The partition key of an item is also known as its &lt;i&gt;hash attribute&lt;/i&gt;. The term "hash attribute" derives from the DynamoDB usage of an internal hash function to evenly distribute data items across partitions, based on their partition key values.&lt;/p&gt;
<a href=#191 id=191 data-nosnippet>191</a>    /// &lt;p&gt;The sort key of an item is also known as its &lt;i&gt;range attribute&lt;/i&gt;. The term "range attribute" derives from the way DynamoDB stores items with the same partition key physically close together, in sorted order by the sort key value.&lt;/p&gt;
<a href=#192 id=192 data-nosnippet>192</a>    /// &lt;/note&gt;
<a href=#193 id=193 data-nosnippet>193</a>    /// &lt;p&gt;For a simple primary key (partition key), you must provide exactly one element with a &lt;code&gt;KeyType&lt;/code&gt; of &lt;code&gt;HASH&lt;/code&gt;.&lt;/p&gt;
<a href=#194 id=194 data-nosnippet>194</a>    /// &lt;p&gt;For a composite primary key (partition key and sort key), you must provide exactly two elements, in this order: The first element must have a &lt;code&gt;KeyType&lt;/code&gt; of &lt;code&gt;HASH&lt;/code&gt;, and the second element must have a &lt;code&gt;KeyType&lt;/code&gt; of &lt;code&gt;RANGE&lt;/code&gt;.&lt;/p&gt;
<a href=#195 id=195 data-nosnippet>195</a>    /// &lt;p&gt;For more information, see &lt;a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#WorkingWithTables.primary.key"&gt;Working with Tables&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;.&lt;/p&gt;
<a href=#196 id=196 data-nosnippet>196</a>    </span><span class="kw">pub fn </span>set_key_schema(<span class="kw-2">mut </span><span class="self">self</span>, input: ::std::option::Option&lt;::std::vec::Vec&lt;<span class="kw">crate</span>::types::KeySchemaElement&gt;&gt;) -&gt; <span class="self">Self </span>{
<a href=#197 id=197 data-nosnippet>197</a>        <span class="self">self</span>.inner = <span class="self">self</span>.inner.set_key_schema(input);
<a href=#198 id=198 data-nosnippet>198</a>        <span class="self">self
<a href=#199 id=199 data-nosnippet>199</a>    </span>}
<a href=#200 id=200 data-nosnippet>200</a>    <span class="doccomment">/// &lt;p&gt;Specifies the attributes that make up the primary key for a table or an index. The attributes in &lt;code&gt;KeySchema&lt;/code&gt; must also be defined in the &lt;code&gt;AttributeDefinitions&lt;/code&gt; array. For more information, see &lt;a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DataModel.html"&gt;Data Model&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;.&lt;/p&gt;
<a href=#201 id=201 data-nosnippet>201</a>    /// &lt;p&gt;Each &lt;code&gt;KeySchemaElement&lt;/code&gt; in the array is composed of:&lt;/p&gt;
<a href=#202 id=202 data-nosnippet>202</a>    /// &lt;ul&gt;
<a href=#203 id=203 data-nosnippet>203</a>    /// &lt;li&gt;
<a href=#204 id=204 data-nosnippet>204</a>    /// &lt;p&gt;&lt;code&gt;AttributeName&lt;/code&gt; - The name of this key attribute.&lt;/p&gt;&lt;/li&gt;
<a href=#205 id=205 data-nosnippet>205</a>    /// &lt;li&gt;
<a href=#206 id=206 data-nosnippet>206</a>    /// &lt;p&gt;&lt;code&gt;KeyType&lt;/code&gt; - The role that the key attribute will assume:&lt;/p&gt;
<a href=#207 id=207 data-nosnippet>207</a>    /// &lt;ul&gt;
<a href=#208 id=208 data-nosnippet>208</a>    /// &lt;li&gt;
<a href=#209 id=209 data-nosnippet>209</a>    /// &lt;p&gt;&lt;code&gt;HASH&lt;/code&gt; - partition key&lt;/p&gt;&lt;/li&gt;
<a href=#210 id=210 data-nosnippet>210</a>    /// &lt;li&gt;
<a href=#211 id=211 data-nosnippet>211</a>    /// &lt;p&gt;&lt;code&gt;RANGE&lt;/code&gt; - sort key&lt;/p&gt;&lt;/li&gt;
<a href=#212 id=212 data-nosnippet>212</a>    /// &lt;/ul&gt;&lt;/li&gt;
<a href=#213 id=213 data-nosnippet>213</a>    /// &lt;/ul&gt;&lt;note&gt;
<a href=#214 id=214 data-nosnippet>214</a>    /// &lt;p&gt;The partition key of an item is also known as its &lt;i&gt;hash attribute&lt;/i&gt;. The term "hash attribute" derives from the DynamoDB usage of an internal hash function to evenly distribute data items across partitions, based on their partition key values.&lt;/p&gt;
<a href=#215 id=215 data-nosnippet>215</a>    /// &lt;p&gt;The sort key of an item is also known as its &lt;i&gt;range attribute&lt;/i&gt;. The term "range attribute" derives from the way DynamoDB stores items with the same partition key physically close together, in sorted order by the sort key value.&lt;/p&gt;
<a href=#216 id=216 data-nosnippet>216</a>    /// &lt;/note&gt;
<a href=#217 id=217 data-nosnippet>217</a>    /// &lt;p&gt;For a simple primary key (partition key), you must provide exactly one element with a &lt;code&gt;KeyType&lt;/code&gt; of &lt;code&gt;HASH&lt;/code&gt;.&lt;/p&gt;
<a href=#218 id=218 data-nosnippet>218</a>    /// &lt;p&gt;For a composite primary key (partition key and sort key), you must provide exactly two elements, in this order: The first element must have a &lt;code&gt;KeyType&lt;/code&gt; of &lt;code&gt;HASH&lt;/code&gt;, and the second element must have a &lt;code&gt;KeyType&lt;/code&gt; of &lt;code&gt;RANGE&lt;/code&gt;.&lt;/p&gt;
<a href=#219 id=219 data-nosnippet>219</a>    /// &lt;p&gt;For more information, see &lt;a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#WorkingWithTables.primary.key"&gt;Working with Tables&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;.&lt;/p&gt;
<a href=#220 id=220 data-nosnippet>220</a>    </span><span class="kw">pub fn </span>get_key_schema(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span>::std::option::Option&lt;::std::vec::Vec&lt;<span class="kw">crate</span>::types::KeySchemaElement&gt;&gt; {
<a href=#221 id=221 data-nosnippet>221</a>        <span class="self">self</span>.inner.get_key_schema()
<a href=#222 id=222 data-nosnippet>222</a>    }
<a href=#223 id=223 data-nosnippet>223</a>    <span class="doccomment">///
<a href=#224 id=224 data-nosnippet>224</a>    /// Appends an item to `LocalSecondaryIndexes`.
<a href=#225 id=225 data-nosnippet>225</a>    ///
<a href=#226 id=226 data-nosnippet>226</a>    /// To override the contents of this collection use [`set_local_secondary_indexes`](Self::set_local_secondary_indexes).
<a href=#227 id=227 data-nosnippet>227</a>    ///
<a href=#228 id=228 data-nosnippet>228</a>    /// &lt;p&gt;One or more local secondary indexes (the maximum is 5) to be created on the table. Each index is scoped to a given partition key value. There is a 10 GB size limit per partition key value; otherwise, the size of a local secondary index is unconstrained.&lt;/p&gt;
<a href=#229 id=229 data-nosnippet>229</a>    /// &lt;p&gt;Each local secondary index in the array includes the following:&lt;/p&gt;
<a href=#230 id=230 data-nosnippet>230</a>    /// &lt;ul&gt;
<a href=#231 id=231 data-nosnippet>231</a>    /// &lt;li&gt;
<a href=#232 id=232 data-nosnippet>232</a>    /// &lt;p&gt;&lt;code&gt;IndexName&lt;/code&gt; - The name of the local secondary index. Must be unique only for this table.&lt;/p&gt;
<a href=#233 id=233 data-nosnippet>233</a>    /// &lt;p&gt;&lt;/p&gt;&lt;/li&gt;
<a href=#234 id=234 data-nosnippet>234</a>    /// &lt;li&gt;
<a href=#235 id=235 data-nosnippet>235</a>    /// &lt;p&gt;&lt;code&gt;KeySchema&lt;/code&gt; - Specifies the key schema for the local secondary index. The key schema must begin with the same partition key as the table.&lt;/p&gt;&lt;/li&gt;
<a href=#236 id=236 data-nosnippet>236</a>    /// &lt;li&gt;
<a href=#237 id=237 data-nosnippet>237</a>    /// &lt;p&gt;&lt;code&gt;Projection&lt;/code&gt; - Specifies attributes that are copied (projected) from the table into the index. These are in addition to the primary key attributes and index key attributes, which are automatically projected. Each attribute specification is composed of:&lt;/p&gt;
<a href=#238 id=238 data-nosnippet>238</a>    /// &lt;ul&gt;
<a href=#239 id=239 data-nosnippet>239</a>    /// &lt;li&gt;
<a href=#240 id=240 data-nosnippet>240</a>    /// &lt;p&gt;&lt;code&gt;ProjectionType&lt;/code&gt; - One of the following:&lt;/p&gt;
<a href=#241 id=241 data-nosnippet>241</a>    /// &lt;ul&gt;
<a href=#242 id=242 data-nosnippet>242</a>    /// &lt;li&gt;
<a href=#243 id=243 data-nosnippet>243</a>    /// &lt;p&gt;&lt;code&gt;KEYS_ONLY&lt;/code&gt; - Only the index and primary keys are projected into the index.&lt;/p&gt;&lt;/li&gt;
<a href=#244 id=244 data-nosnippet>244</a>    /// &lt;li&gt;
<a href=#245 id=245 data-nosnippet>245</a>    /// &lt;p&gt;&lt;code&gt;INCLUDE&lt;/code&gt; - Only the specified table attributes are projected into the index. The list of projected attributes is in &lt;code&gt;NonKeyAttributes&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
<a href=#246 id=246 data-nosnippet>246</a>    /// &lt;li&gt;
<a href=#247 id=247 data-nosnippet>247</a>    /// &lt;p&gt;&lt;code&gt;ALL&lt;/code&gt; - All of the table attributes are projected into the index.&lt;/p&gt;&lt;/li&gt;
<a href=#248 id=248 data-nosnippet>248</a>    /// &lt;/ul&gt;&lt;/li&gt;
<a href=#249 id=249 data-nosnippet>249</a>    /// &lt;li&gt;
<a href=#250 id=250 data-nosnippet>250</a>    /// &lt;p&gt;&lt;code&gt;NonKeyAttributes&lt;/code&gt; - A list of one or more non-key attribute names that are projected into the secondary index. The total count of attributes provided in &lt;code&gt;NonKeyAttributes&lt;/code&gt;, summed across all of the secondary indexes, must not exceed 100. If you project the same attribute into two different indexes, this counts as two distinct attributes when determining the total. This limit only applies when you specify the ProjectionType of &lt;code&gt;INCLUDE&lt;/code&gt;. You still can specify the ProjectionType of &lt;code&gt;ALL&lt;/code&gt; to project all attributes from the source table, even if the table has more than 100 attributes.&lt;/p&gt;&lt;/li&gt;
<a href=#251 id=251 data-nosnippet>251</a>    /// &lt;/ul&gt;&lt;/li&gt;
<a href=#252 id=252 data-nosnippet>252</a>    /// &lt;/ul&gt;
<a href=#253 id=253 data-nosnippet>253</a>    </span><span class="kw">pub fn </span>local_secondary_indexes(<span class="kw-2">mut </span><span class="self">self</span>, input: <span class="kw">crate</span>::types::LocalSecondaryIndex) -&gt; <span class="self">Self </span>{
<a href=#254 id=254 data-nosnippet>254</a>        <span class="self">self</span>.inner = <span class="self">self</span>.inner.local_secondary_indexes(input);
<a href=#255 id=255 data-nosnippet>255</a>        <span class="self">self
<a href=#256 id=256 data-nosnippet>256</a>    </span>}
<a href=#257 id=257 data-nosnippet>257</a>    <span class="doccomment">/// &lt;p&gt;One or more local secondary indexes (the maximum is 5) to be created on the table. Each index is scoped to a given partition key value. There is a 10 GB size limit per partition key value; otherwise, the size of a local secondary index is unconstrained.&lt;/p&gt;
<a href=#258 id=258 data-nosnippet>258</a>    /// &lt;p&gt;Each local secondary index in the array includes the following:&lt;/p&gt;
<a href=#259 id=259 data-nosnippet>259</a>    /// &lt;ul&gt;
<a href=#260 id=260 data-nosnippet>260</a>    /// &lt;li&gt;
<a href=#261 id=261 data-nosnippet>261</a>    /// &lt;p&gt;&lt;code&gt;IndexName&lt;/code&gt; - The name of the local secondary index. Must be unique only for this table.&lt;/p&gt;
<a href=#262 id=262 data-nosnippet>262</a>    /// &lt;p&gt;&lt;/p&gt;&lt;/li&gt;
<a href=#263 id=263 data-nosnippet>263</a>    /// &lt;li&gt;
<a href=#264 id=264 data-nosnippet>264</a>    /// &lt;p&gt;&lt;code&gt;KeySchema&lt;/code&gt; - Specifies the key schema for the local secondary index. The key schema must begin with the same partition key as the table.&lt;/p&gt;&lt;/li&gt;
<a href=#265 id=265 data-nosnippet>265</a>    /// &lt;li&gt;
<a href=#266 id=266 data-nosnippet>266</a>    /// &lt;p&gt;&lt;code&gt;Projection&lt;/code&gt; - Specifies attributes that are copied (projected) from the table into the index. These are in addition to the primary key attributes and index key attributes, which are automatically projected. Each attribute specification is composed of:&lt;/p&gt;
<a href=#267 id=267 data-nosnippet>267</a>    /// &lt;ul&gt;
<a href=#268 id=268 data-nosnippet>268</a>    /// &lt;li&gt;
<a href=#269 id=269 data-nosnippet>269</a>    /// &lt;p&gt;&lt;code&gt;ProjectionType&lt;/code&gt; - One of the following:&lt;/p&gt;
<a href=#270 id=270 data-nosnippet>270</a>    /// &lt;ul&gt;
<a href=#271 id=271 data-nosnippet>271</a>    /// &lt;li&gt;
<a href=#272 id=272 data-nosnippet>272</a>    /// &lt;p&gt;&lt;code&gt;KEYS_ONLY&lt;/code&gt; - Only the index and primary keys are projected into the index.&lt;/p&gt;&lt;/li&gt;
<a href=#273 id=273 data-nosnippet>273</a>    /// &lt;li&gt;
<a href=#274 id=274 data-nosnippet>274</a>    /// &lt;p&gt;&lt;code&gt;INCLUDE&lt;/code&gt; - Only the specified table attributes are projected into the index. The list of projected attributes is in &lt;code&gt;NonKeyAttributes&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
<a href=#275 id=275 data-nosnippet>275</a>    /// &lt;li&gt;
<a href=#276 id=276 data-nosnippet>276</a>    /// &lt;p&gt;&lt;code&gt;ALL&lt;/code&gt; - All of the table attributes are projected into the index.&lt;/p&gt;&lt;/li&gt;
<a href=#277 id=277 data-nosnippet>277</a>    /// &lt;/ul&gt;&lt;/li&gt;
<a href=#278 id=278 data-nosnippet>278</a>    /// &lt;li&gt;
<a href=#279 id=279 data-nosnippet>279</a>    /// &lt;p&gt;&lt;code&gt;NonKeyAttributes&lt;/code&gt; - A list of one or more non-key attribute names that are projected into the secondary index. The total count of attributes provided in &lt;code&gt;NonKeyAttributes&lt;/code&gt;, summed across all of the secondary indexes, must not exceed 100. If you project the same attribute into two different indexes, this counts as two distinct attributes when determining the total. This limit only applies when you specify the ProjectionType of &lt;code&gt;INCLUDE&lt;/code&gt;. You still can specify the ProjectionType of &lt;code&gt;ALL&lt;/code&gt; to project all attributes from the source table, even if the table has more than 100 attributes.&lt;/p&gt;&lt;/li&gt;
<a href=#280 id=280 data-nosnippet>280</a>    /// &lt;/ul&gt;&lt;/li&gt;
<a href=#281 id=281 data-nosnippet>281</a>    /// &lt;/ul&gt;
<a href=#282 id=282 data-nosnippet>282</a>    </span><span class="kw">pub fn </span>set_local_secondary_indexes(<span class="kw-2">mut </span><span class="self">self</span>, input: ::std::option::Option&lt;::std::vec::Vec&lt;<span class="kw">crate</span>::types::LocalSecondaryIndex&gt;&gt;) -&gt; <span class="self">Self </span>{
<a href=#283 id=283 data-nosnippet>283</a>        <span class="self">self</span>.inner = <span class="self">self</span>.inner.set_local_secondary_indexes(input);
<a href=#284 id=284 data-nosnippet>284</a>        <span class="self">self
<a href=#285 id=285 data-nosnippet>285</a>    </span>}
<a href=#286 id=286 data-nosnippet>286</a>    <span class="doccomment">/// &lt;p&gt;One or more local secondary indexes (the maximum is 5) to be created on the table. Each index is scoped to a given partition key value. There is a 10 GB size limit per partition key value; otherwise, the size of a local secondary index is unconstrained.&lt;/p&gt;
<a href=#287 id=287 data-nosnippet>287</a>    /// &lt;p&gt;Each local secondary index in the array includes the following:&lt;/p&gt;
<a href=#288 id=288 data-nosnippet>288</a>    /// &lt;ul&gt;
<a href=#289 id=289 data-nosnippet>289</a>    /// &lt;li&gt;
<a href=#290 id=290 data-nosnippet>290</a>    /// &lt;p&gt;&lt;code&gt;IndexName&lt;/code&gt; - The name of the local secondary index. Must be unique only for this table.&lt;/p&gt;
<a href=#291 id=291 data-nosnippet>291</a>    /// &lt;p&gt;&lt;/p&gt;&lt;/li&gt;
<a href=#292 id=292 data-nosnippet>292</a>    /// &lt;li&gt;
<a href=#293 id=293 data-nosnippet>293</a>    /// &lt;p&gt;&lt;code&gt;KeySchema&lt;/code&gt; - Specifies the key schema for the local secondary index. The key schema must begin with the same partition key as the table.&lt;/p&gt;&lt;/li&gt;
<a href=#294 id=294 data-nosnippet>294</a>    /// &lt;li&gt;
<a href=#295 id=295 data-nosnippet>295</a>    /// &lt;p&gt;&lt;code&gt;Projection&lt;/code&gt; - Specifies attributes that are copied (projected) from the table into the index. These are in addition to the primary key attributes and index key attributes, which are automatically projected. Each attribute specification is composed of:&lt;/p&gt;
<a href=#296 id=296 data-nosnippet>296</a>    /// &lt;ul&gt;
<a href=#297 id=297 data-nosnippet>297</a>    /// &lt;li&gt;
<a href=#298 id=298 data-nosnippet>298</a>    /// &lt;p&gt;&lt;code&gt;ProjectionType&lt;/code&gt; - One of the following:&lt;/p&gt;
<a href=#299 id=299 data-nosnippet>299</a>    /// &lt;ul&gt;
<a href=#300 id=300 data-nosnippet>300</a>    /// &lt;li&gt;
<a href=#301 id=301 data-nosnippet>301</a>    /// &lt;p&gt;&lt;code&gt;KEYS_ONLY&lt;/code&gt; - Only the index and primary keys are projected into the index.&lt;/p&gt;&lt;/li&gt;
<a href=#302 id=302 data-nosnippet>302</a>    /// &lt;li&gt;
<a href=#303 id=303 data-nosnippet>303</a>    /// &lt;p&gt;&lt;code&gt;INCLUDE&lt;/code&gt; - Only the specified table attributes are projected into the index. The list of projected attributes is in &lt;code&gt;NonKeyAttributes&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
<a href=#304 id=304 data-nosnippet>304</a>    /// &lt;li&gt;
<a href=#305 id=305 data-nosnippet>305</a>    /// &lt;p&gt;&lt;code&gt;ALL&lt;/code&gt; - All of the table attributes are projected into the index.&lt;/p&gt;&lt;/li&gt;
<a href=#306 id=306 data-nosnippet>306</a>    /// &lt;/ul&gt;&lt;/li&gt;
<a href=#307 id=307 data-nosnippet>307</a>    /// &lt;li&gt;
<a href=#308 id=308 data-nosnippet>308</a>    /// &lt;p&gt;&lt;code&gt;NonKeyAttributes&lt;/code&gt; - A list of one or more non-key attribute names that are projected into the secondary index. The total count of attributes provided in &lt;code&gt;NonKeyAttributes&lt;/code&gt;, summed across all of the secondary indexes, must not exceed 100. If you project the same attribute into two different indexes, this counts as two distinct attributes when determining the total. This limit only applies when you specify the ProjectionType of &lt;code&gt;INCLUDE&lt;/code&gt;. You still can specify the ProjectionType of &lt;code&gt;ALL&lt;/code&gt; to project all attributes from the source table, even if the table has more than 100 attributes.&lt;/p&gt;&lt;/li&gt;
<a href=#309 id=309 data-nosnippet>309</a>    /// &lt;/ul&gt;&lt;/li&gt;
<a href=#310 id=310 data-nosnippet>310</a>    /// &lt;/ul&gt;
<a href=#311 id=311 data-nosnippet>311</a>    </span><span class="kw">pub fn </span>get_local_secondary_indexes(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span>::std::option::Option&lt;::std::vec::Vec&lt;<span class="kw">crate</span>::types::LocalSecondaryIndex&gt;&gt; {
<a href=#312 id=312 data-nosnippet>312</a>        <span class="self">self</span>.inner.get_local_secondary_indexes()
<a href=#313 id=313 data-nosnippet>313</a>    }
<a href=#314 id=314 data-nosnippet>314</a>    <span class="doccomment">///
<a href=#315 id=315 data-nosnippet>315</a>    /// Appends an item to `GlobalSecondaryIndexes`.
<a href=#316 id=316 data-nosnippet>316</a>    ///
<a href=#317 id=317 data-nosnippet>317</a>    /// To override the contents of this collection use [`set_global_secondary_indexes`](Self::set_global_secondary_indexes).
<a href=#318 id=318 data-nosnippet>318</a>    ///
<a href=#319 id=319 data-nosnippet>319</a>    /// &lt;p&gt;One or more global secondary indexes (the maximum is 20) to be created on the table. Each global secondary index in the array includes the following:&lt;/p&gt;
<a href=#320 id=320 data-nosnippet>320</a>    /// &lt;ul&gt;
<a href=#321 id=321 data-nosnippet>321</a>    /// &lt;li&gt;
<a href=#322 id=322 data-nosnippet>322</a>    /// &lt;p&gt;&lt;code&gt;IndexName&lt;/code&gt; - The name of the global secondary index. Must be unique only for this table.&lt;/p&gt;
<a href=#323 id=323 data-nosnippet>323</a>    /// &lt;p&gt;&lt;/p&gt;&lt;/li&gt;
<a href=#324 id=324 data-nosnippet>324</a>    /// &lt;li&gt;
<a href=#325 id=325 data-nosnippet>325</a>    /// &lt;p&gt;&lt;code&gt;KeySchema&lt;/code&gt; - Specifies the key schema for the global secondary index.&lt;/p&gt;&lt;/li&gt;
<a href=#326 id=326 data-nosnippet>326</a>    /// &lt;li&gt;
<a href=#327 id=327 data-nosnippet>327</a>    /// &lt;p&gt;&lt;code&gt;Projection&lt;/code&gt; - Specifies attributes that are copied (projected) from the table into the index. These are in addition to the primary key attributes and index key attributes, which are automatically projected. Each attribute specification is composed of:&lt;/p&gt;
<a href=#328 id=328 data-nosnippet>328</a>    /// &lt;ul&gt;
<a href=#329 id=329 data-nosnippet>329</a>    /// &lt;li&gt;
<a href=#330 id=330 data-nosnippet>330</a>    /// &lt;p&gt;&lt;code&gt;ProjectionType&lt;/code&gt; - One of the following:&lt;/p&gt;
<a href=#331 id=331 data-nosnippet>331</a>    /// &lt;ul&gt;
<a href=#332 id=332 data-nosnippet>332</a>    /// &lt;li&gt;
<a href=#333 id=333 data-nosnippet>333</a>    /// &lt;p&gt;&lt;code&gt;KEYS_ONLY&lt;/code&gt; - Only the index and primary keys are projected into the index.&lt;/p&gt;&lt;/li&gt;
<a href=#334 id=334 data-nosnippet>334</a>    /// &lt;li&gt;
<a href=#335 id=335 data-nosnippet>335</a>    /// &lt;p&gt;&lt;code&gt;INCLUDE&lt;/code&gt; - Only the specified table attributes are projected into the index. The list of projected attributes is in &lt;code&gt;NonKeyAttributes&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
<a href=#336 id=336 data-nosnippet>336</a>    /// &lt;li&gt;
<a href=#337 id=337 data-nosnippet>337</a>    /// &lt;p&gt;&lt;code&gt;ALL&lt;/code&gt; - All of the table attributes are projected into the index.&lt;/p&gt;&lt;/li&gt;
<a href=#338 id=338 data-nosnippet>338</a>    /// &lt;/ul&gt;&lt;/li&gt;
<a href=#339 id=339 data-nosnippet>339</a>    /// &lt;li&gt;
<a href=#340 id=340 data-nosnippet>340</a>    /// &lt;p&gt;&lt;code&gt;NonKeyAttributes&lt;/code&gt; - A list of one or more non-key attribute names that are projected into the secondary index. The total count of attributes provided in &lt;code&gt;NonKeyAttributes&lt;/code&gt;, summed across all of the secondary indexes, must not exceed 100. If you project the same attribute into two different indexes, this counts as two distinct attributes when determining the total. This limit only applies when you specify the ProjectionType of &lt;code&gt;INCLUDE&lt;/code&gt;. You still can specify the ProjectionType of &lt;code&gt;ALL&lt;/code&gt; to project all attributes from the source table, even if the table has more than 100 attributes.&lt;/p&gt;&lt;/li&gt;
<a href=#341 id=341 data-nosnippet>341</a>    /// &lt;/ul&gt;&lt;/li&gt;
<a href=#342 id=342 data-nosnippet>342</a>    /// &lt;li&gt;
<a href=#343 id=343 data-nosnippet>343</a>    /// &lt;p&gt;&lt;code&gt;ProvisionedThroughput&lt;/code&gt; - The provisioned throughput settings for the global secondary index, consisting of read and write capacity units.&lt;/p&gt;&lt;/li&gt;
<a href=#344 id=344 data-nosnippet>344</a>    /// &lt;/ul&gt;
<a href=#345 id=345 data-nosnippet>345</a>    </span><span class="kw">pub fn </span>global_secondary_indexes(<span class="kw-2">mut </span><span class="self">self</span>, input: <span class="kw">crate</span>::types::GlobalSecondaryIndex) -&gt; <span class="self">Self </span>{
<a href=#346 id=346 data-nosnippet>346</a>        <span class="self">self</span>.inner = <span class="self">self</span>.inner.global_secondary_indexes(input);
<a href=#347 id=347 data-nosnippet>347</a>        <span class="self">self
<a href=#348 id=348 data-nosnippet>348</a>    </span>}
<a href=#349 id=349 data-nosnippet>349</a>    <span class="doccomment">/// &lt;p&gt;One or more global secondary indexes (the maximum is 20) to be created on the table. Each global secondary index in the array includes the following:&lt;/p&gt;
<a href=#350 id=350 data-nosnippet>350</a>    /// &lt;ul&gt;
<a href=#351 id=351 data-nosnippet>351</a>    /// &lt;li&gt;
<a href=#352 id=352 data-nosnippet>352</a>    /// &lt;p&gt;&lt;code&gt;IndexName&lt;/code&gt; - The name of the global secondary index. Must be unique only for this table.&lt;/p&gt;
<a href=#353 id=353 data-nosnippet>353</a>    /// &lt;p&gt;&lt;/p&gt;&lt;/li&gt;
<a href=#354 id=354 data-nosnippet>354</a>    /// &lt;li&gt;
<a href=#355 id=355 data-nosnippet>355</a>    /// &lt;p&gt;&lt;code&gt;KeySchema&lt;/code&gt; - Specifies the key schema for the global secondary index.&lt;/p&gt;&lt;/li&gt;
<a href=#356 id=356 data-nosnippet>356</a>    /// &lt;li&gt;
<a href=#357 id=357 data-nosnippet>357</a>    /// &lt;p&gt;&lt;code&gt;Projection&lt;/code&gt; - Specifies attributes that are copied (projected) from the table into the index. These are in addition to the primary key attributes and index key attributes, which are automatically projected. Each attribute specification is composed of:&lt;/p&gt;
<a href=#358 id=358 data-nosnippet>358</a>    /// &lt;ul&gt;
<a href=#359 id=359 data-nosnippet>359</a>    /// &lt;li&gt;
<a href=#360 id=360 data-nosnippet>360</a>    /// &lt;p&gt;&lt;code&gt;ProjectionType&lt;/code&gt; - One of the following:&lt;/p&gt;
<a href=#361 id=361 data-nosnippet>361</a>    /// &lt;ul&gt;
<a href=#362 id=362 data-nosnippet>362</a>    /// &lt;li&gt;
<a href=#363 id=363 data-nosnippet>363</a>    /// &lt;p&gt;&lt;code&gt;KEYS_ONLY&lt;/code&gt; - Only the index and primary keys are projected into the index.&lt;/p&gt;&lt;/li&gt;
<a href=#364 id=364 data-nosnippet>364</a>    /// &lt;li&gt;
<a href=#365 id=365 data-nosnippet>365</a>    /// &lt;p&gt;&lt;code&gt;INCLUDE&lt;/code&gt; - Only the specified table attributes are projected into the index. The list of projected attributes is in &lt;code&gt;NonKeyAttributes&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
<a href=#366 id=366 data-nosnippet>366</a>    /// &lt;li&gt;
<a href=#367 id=367 data-nosnippet>367</a>    /// &lt;p&gt;&lt;code&gt;ALL&lt;/code&gt; - All of the table attributes are projected into the index.&lt;/p&gt;&lt;/li&gt;
<a href=#368 id=368 data-nosnippet>368</a>    /// &lt;/ul&gt;&lt;/li&gt;
<a href=#369 id=369 data-nosnippet>369</a>    /// &lt;li&gt;
<a href=#370 id=370 data-nosnippet>370</a>    /// &lt;p&gt;&lt;code&gt;NonKeyAttributes&lt;/code&gt; - A list of one or more non-key attribute names that are projected into the secondary index. The total count of attributes provided in &lt;code&gt;NonKeyAttributes&lt;/code&gt;, summed across all of the secondary indexes, must not exceed 100. If you project the same attribute into two different indexes, this counts as two distinct attributes when determining the total. This limit only applies when you specify the ProjectionType of &lt;code&gt;INCLUDE&lt;/code&gt;. You still can specify the ProjectionType of &lt;code&gt;ALL&lt;/code&gt; to project all attributes from the source table, even if the table has more than 100 attributes.&lt;/p&gt;&lt;/li&gt;
<a href=#371 id=371 data-nosnippet>371</a>    /// &lt;/ul&gt;&lt;/li&gt;
<a href=#372 id=372 data-nosnippet>372</a>    /// &lt;li&gt;
<a href=#373 id=373 data-nosnippet>373</a>    /// &lt;p&gt;&lt;code&gt;ProvisionedThroughput&lt;/code&gt; - The provisioned throughput settings for the global secondary index, consisting of read and write capacity units.&lt;/p&gt;&lt;/li&gt;
<a href=#374 id=374 data-nosnippet>374</a>    /// &lt;/ul&gt;
<a href=#375 id=375 data-nosnippet>375</a>    </span><span class="kw">pub fn </span>set_global_secondary_indexes(<span class="kw-2">mut </span><span class="self">self</span>, input: ::std::option::Option&lt;::std::vec::Vec&lt;<span class="kw">crate</span>::types::GlobalSecondaryIndex&gt;&gt;) -&gt; <span class="self">Self </span>{
<a href=#376 id=376 data-nosnippet>376</a>        <span class="self">self</span>.inner = <span class="self">self</span>.inner.set_global_secondary_indexes(input);
<a href=#377 id=377 data-nosnippet>377</a>        <span class="self">self
<a href=#378 id=378 data-nosnippet>378</a>    </span>}
<a href=#379 id=379 data-nosnippet>379</a>    <span class="doccomment">/// &lt;p&gt;One or more global secondary indexes (the maximum is 20) to be created on the table. Each global secondary index in the array includes the following:&lt;/p&gt;
<a href=#380 id=380 data-nosnippet>380</a>    /// &lt;ul&gt;
<a href=#381 id=381 data-nosnippet>381</a>    /// &lt;li&gt;
<a href=#382 id=382 data-nosnippet>382</a>    /// &lt;p&gt;&lt;code&gt;IndexName&lt;/code&gt; - The name of the global secondary index. Must be unique only for this table.&lt;/p&gt;
<a href=#383 id=383 data-nosnippet>383</a>    /// &lt;p&gt;&lt;/p&gt;&lt;/li&gt;
<a href=#384 id=384 data-nosnippet>384</a>    /// &lt;li&gt;
<a href=#385 id=385 data-nosnippet>385</a>    /// &lt;p&gt;&lt;code&gt;KeySchema&lt;/code&gt; - Specifies the key schema for the global secondary index.&lt;/p&gt;&lt;/li&gt;
<a href=#386 id=386 data-nosnippet>386</a>    /// &lt;li&gt;
<a href=#387 id=387 data-nosnippet>387</a>    /// &lt;p&gt;&lt;code&gt;Projection&lt;/code&gt; - Specifies attributes that are copied (projected) from the table into the index. These are in addition to the primary key attributes and index key attributes, which are automatically projected. Each attribute specification is composed of:&lt;/p&gt;
<a href=#388 id=388 data-nosnippet>388</a>    /// &lt;ul&gt;
<a href=#389 id=389 data-nosnippet>389</a>    /// &lt;li&gt;
<a href=#390 id=390 data-nosnippet>390</a>    /// &lt;p&gt;&lt;code&gt;ProjectionType&lt;/code&gt; - One of the following:&lt;/p&gt;
<a href=#391 id=391 data-nosnippet>391</a>    /// &lt;ul&gt;
<a href=#392 id=392 data-nosnippet>392</a>    /// &lt;li&gt;
<a href=#393 id=393 data-nosnippet>393</a>    /// &lt;p&gt;&lt;code&gt;KEYS_ONLY&lt;/code&gt; - Only the index and primary keys are projected into the index.&lt;/p&gt;&lt;/li&gt;
<a href=#394 id=394 data-nosnippet>394</a>    /// &lt;li&gt;
<a href=#395 id=395 data-nosnippet>395</a>    /// &lt;p&gt;&lt;code&gt;INCLUDE&lt;/code&gt; - Only the specified table attributes are projected into the index. The list of projected attributes is in &lt;code&gt;NonKeyAttributes&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
<a href=#396 id=396 data-nosnippet>396</a>    /// &lt;li&gt;
<a href=#397 id=397 data-nosnippet>397</a>    /// &lt;p&gt;&lt;code&gt;ALL&lt;/code&gt; - All of the table attributes are projected into the index.&lt;/p&gt;&lt;/li&gt;
<a href=#398 id=398 data-nosnippet>398</a>    /// &lt;/ul&gt;&lt;/li&gt;
<a href=#399 id=399 data-nosnippet>399</a>    /// &lt;li&gt;
<a href=#400 id=400 data-nosnippet>400</a>    /// &lt;p&gt;&lt;code&gt;NonKeyAttributes&lt;/code&gt; - A list of one or more non-key attribute names that are projected into the secondary index. The total count of attributes provided in &lt;code&gt;NonKeyAttributes&lt;/code&gt;, summed across all of the secondary indexes, must not exceed 100. If you project the same attribute into two different indexes, this counts as two distinct attributes when determining the total. This limit only applies when you specify the ProjectionType of &lt;code&gt;INCLUDE&lt;/code&gt;. You still can specify the ProjectionType of &lt;code&gt;ALL&lt;/code&gt; to project all attributes from the source table, even if the table has more than 100 attributes.&lt;/p&gt;&lt;/li&gt;
<a href=#401 id=401 data-nosnippet>401</a>    /// &lt;/ul&gt;&lt;/li&gt;
<a href=#402 id=402 data-nosnippet>402</a>    /// &lt;li&gt;
<a href=#403 id=403 data-nosnippet>403</a>    /// &lt;p&gt;&lt;code&gt;ProvisionedThroughput&lt;/code&gt; - The provisioned throughput settings for the global secondary index, consisting of read and write capacity units.&lt;/p&gt;&lt;/li&gt;
<a href=#404 id=404 data-nosnippet>404</a>    /// &lt;/ul&gt;
<a href=#405 id=405 data-nosnippet>405</a>    </span><span class="kw">pub fn </span>get_global_secondary_indexes(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span>::std::option::Option&lt;::std::vec::Vec&lt;<span class="kw">crate</span>::types::GlobalSecondaryIndex&gt;&gt; {
<a href=#406 id=406 data-nosnippet>406</a>        <span class="self">self</span>.inner.get_global_secondary_indexes()
<a href=#407 id=407 data-nosnippet>407</a>    }
<a href=#408 id=408 data-nosnippet>408</a>    <span class="doccomment">/// &lt;p&gt;Controls how you are charged for read and write throughput and how you manage capacity. This setting can be changed later.&lt;/p&gt;
<a href=#409 id=409 data-nosnippet>409</a>    /// &lt;ul&gt;
<a href=#410 id=410 data-nosnippet>410</a>    /// &lt;li&gt;
<a href=#411 id=411 data-nosnippet>411</a>    /// &lt;p&gt;&lt;code&gt;PAY_PER_REQUEST&lt;/code&gt; - We recommend using &lt;code&gt;PAY_PER_REQUEST&lt;/code&gt; for most DynamoDB workloads. &lt;code&gt;PAY_PER_REQUEST&lt;/code&gt; sets the billing mode to &lt;a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/on-demand-capacity-mode.html"&gt;On-demand capacity mode&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
<a href=#412 id=412 data-nosnippet>412</a>    /// &lt;li&gt;
<a href=#413 id=413 data-nosnippet>413</a>    /// &lt;p&gt;&lt;code&gt;PROVISIONED&lt;/code&gt; - We recommend using &lt;code&gt;PROVISIONED&lt;/code&gt; for steady workloads with predictable growth where capacity requirements can be reliably forecasted. &lt;code&gt;PROVISIONED&lt;/code&gt; sets the billing mode to &lt;a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/provisioned-capacity-mode.html"&gt;Provisioned capacity mode&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
<a href=#414 id=414 data-nosnippet>414</a>    /// &lt;/ul&gt;
<a href=#415 id=415 data-nosnippet>415</a>    </span><span class="kw">pub fn </span>billing_mode(<span class="kw-2">mut </span><span class="self">self</span>, input: <span class="kw">crate</span>::types::BillingMode) -&gt; <span class="self">Self </span>{
<a href=#416 id=416 data-nosnippet>416</a>        <span class="self">self</span>.inner = <span class="self">self</span>.inner.billing_mode(input);
<a href=#417 id=417 data-nosnippet>417</a>        <span class="self">self
<a href=#418 id=418 data-nosnippet>418</a>    </span>}
<a href=#419 id=419 data-nosnippet>419</a>    <span class="doccomment">/// &lt;p&gt;Controls how you are charged for read and write throughput and how you manage capacity. This setting can be changed later.&lt;/p&gt;
<a href=#420 id=420 data-nosnippet>420</a>    /// &lt;ul&gt;
<a href=#421 id=421 data-nosnippet>421</a>    /// &lt;li&gt;
<a href=#422 id=422 data-nosnippet>422</a>    /// &lt;p&gt;&lt;code&gt;PAY_PER_REQUEST&lt;/code&gt; - We recommend using &lt;code&gt;PAY_PER_REQUEST&lt;/code&gt; for most DynamoDB workloads. &lt;code&gt;PAY_PER_REQUEST&lt;/code&gt; sets the billing mode to &lt;a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/on-demand-capacity-mode.html"&gt;On-demand capacity mode&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
<a href=#423 id=423 data-nosnippet>423</a>    /// &lt;li&gt;
<a href=#424 id=424 data-nosnippet>424</a>    /// &lt;p&gt;&lt;code&gt;PROVISIONED&lt;/code&gt; - We recommend using &lt;code&gt;PROVISIONED&lt;/code&gt; for steady workloads with predictable growth where capacity requirements can be reliably forecasted. &lt;code&gt;PROVISIONED&lt;/code&gt; sets the billing mode to &lt;a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/provisioned-capacity-mode.html"&gt;Provisioned capacity mode&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
<a href=#425 id=425 data-nosnippet>425</a>    /// &lt;/ul&gt;
<a href=#426 id=426 data-nosnippet>426</a>    </span><span class="kw">pub fn </span>set_billing_mode(<span class="kw-2">mut </span><span class="self">self</span>, input: ::std::option::Option&lt;<span class="kw">crate</span>::types::BillingMode&gt;) -&gt; <span class="self">Self </span>{
<a href=#427 id=427 data-nosnippet>427</a>        <span class="self">self</span>.inner = <span class="self">self</span>.inner.set_billing_mode(input);
<a href=#428 id=428 data-nosnippet>428</a>        <span class="self">self
<a href=#429 id=429 data-nosnippet>429</a>    </span>}
<a href=#430 id=430 data-nosnippet>430</a>    <span class="doccomment">/// &lt;p&gt;Controls how you are charged for read and write throughput and how you manage capacity. This setting can be changed later.&lt;/p&gt;
<a href=#431 id=431 data-nosnippet>431</a>    /// &lt;ul&gt;
<a href=#432 id=432 data-nosnippet>432</a>    /// &lt;li&gt;
<a href=#433 id=433 data-nosnippet>433</a>    /// &lt;p&gt;&lt;code&gt;PAY_PER_REQUEST&lt;/code&gt; - We recommend using &lt;code&gt;PAY_PER_REQUEST&lt;/code&gt; for most DynamoDB workloads. &lt;code&gt;PAY_PER_REQUEST&lt;/code&gt; sets the billing mode to &lt;a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/on-demand-capacity-mode.html"&gt;On-demand capacity mode&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
<a href=#434 id=434 data-nosnippet>434</a>    /// &lt;li&gt;
<a href=#435 id=435 data-nosnippet>435</a>    /// &lt;p&gt;&lt;code&gt;PROVISIONED&lt;/code&gt; - We recommend using &lt;code&gt;PROVISIONED&lt;/code&gt; for steady workloads with predictable growth where capacity requirements can be reliably forecasted. &lt;code&gt;PROVISIONED&lt;/code&gt; sets the billing mode to &lt;a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/provisioned-capacity-mode.html"&gt;Provisioned capacity mode&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
<a href=#436 id=436 data-nosnippet>436</a>    /// &lt;/ul&gt;
<a href=#437 id=437 data-nosnippet>437</a>    </span><span class="kw">pub fn </span>get_billing_mode(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span>::std::option::Option&lt;<span class="kw">crate</span>::types::BillingMode&gt; {
<a href=#438 id=438 data-nosnippet>438</a>        <span class="self">self</span>.inner.get_billing_mode()
<a href=#439 id=439 data-nosnippet>439</a>    }
<a href=#440 id=440 data-nosnippet>440</a>    <span class="doccomment">/// &lt;p&gt;Represents the provisioned throughput settings for a specified table or index. The settings can be modified using the &lt;code&gt;UpdateTable&lt;/code&gt; operation.&lt;/p&gt;
<a href=#441 id=441 data-nosnippet>441</a>    /// &lt;p&gt;If you set BillingMode as &lt;code&gt;PROVISIONED&lt;/code&gt;, you must specify this property. If you set BillingMode as &lt;code&gt;PAY_PER_REQUEST&lt;/code&gt;, you cannot specify this property.&lt;/p&gt;
<a href=#442 id=442 data-nosnippet>442</a>    /// &lt;p&gt;For current minimum and maximum provisioned throughput values, see &lt;a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html"&gt;Service, Account, and Table Quotas&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;.&lt;/p&gt;
<a href=#443 id=443 data-nosnippet>443</a>    </span><span class="kw">pub fn </span>provisioned_throughput(<span class="kw-2">mut </span><span class="self">self</span>, input: <span class="kw">crate</span>::types::ProvisionedThroughput) -&gt; <span class="self">Self </span>{
<a href=#444 id=444 data-nosnippet>444</a>        <span class="self">self</span>.inner = <span class="self">self</span>.inner.provisioned_throughput(input);
<a href=#445 id=445 data-nosnippet>445</a>        <span class="self">self
<a href=#446 id=446 data-nosnippet>446</a>    </span>}
<a href=#447 id=447 data-nosnippet>447</a>    <span class="doccomment">/// &lt;p&gt;Represents the provisioned throughput settings for a specified table or index. The settings can be modified using the &lt;code&gt;UpdateTable&lt;/code&gt; operation.&lt;/p&gt;
<a href=#448 id=448 data-nosnippet>448</a>    /// &lt;p&gt;If you set BillingMode as &lt;code&gt;PROVISIONED&lt;/code&gt;, you must specify this property. If you set BillingMode as &lt;code&gt;PAY_PER_REQUEST&lt;/code&gt;, you cannot specify this property.&lt;/p&gt;
<a href=#449 id=449 data-nosnippet>449</a>    /// &lt;p&gt;For current minimum and maximum provisioned throughput values, see &lt;a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html"&gt;Service, Account, and Table Quotas&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;.&lt;/p&gt;
<a href=#450 id=450 data-nosnippet>450</a>    </span><span class="kw">pub fn </span>set_provisioned_throughput(<span class="kw-2">mut </span><span class="self">self</span>, input: ::std::option::Option&lt;<span class="kw">crate</span>::types::ProvisionedThroughput&gt;) -&gt; <span class="self">Self </span>{
<a href=#451 id=451 data-nosnippet>451</a>        <span class="self">self</span>.inner = <span class="self">self</span>.inner.set_provisioned_throughput(input);
<a href=#452 id=452 data-nosnippet>452</a>        <span class="self">self
<a href=#453 id=453 data-nosnippet>453</a>    </span>}
<a href=#454 id=454 data-nosnippet>454</a>    <span class="doccomment">/// &lt;p&gt;Represents the provisioned throughput settings for a specified table or index. The settings can be modified using the &lt;code&gt;UpdateTable&lt;/code&gt; operation.&lt;/p&gt;
<a href=#455 id=455 data-nosnippet>455</a>    /// &lt;p&gt;If you set BillingMode as &lt;code&gt;PROVISIONED&lt;/code&gt;, you must specify this property. If you set BillingMode as &lt;code&gt;PAY_PER_REQUEST&lt;/code&gt;, you cannot specify this property.&lt;/p&gt;
<a href=#456 id=456 data-nosnippet>456</a>    /// &lt;p&gt;For current minimum and maximum provisioned throughput values, see &lt;a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html"&gt;Service, Account, and Table Quotas&lt;/a&gt; in the &lt;i&gt;Amazon DynamoDB Developer Guide&lt;/i&gt;.&lt;/p&gt;
<a href=#457 id=457 data-nosnippet>457</a>    </span><span class="kw">pub fn </span>get_provisioned_throughput(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span>::std::option::Option&lt;<span class="kw">crate</span>::types::ProvisionedThroughput&gt; {
<a href=#458 id=458 data-nosnippet>458</a>        <span class="self">self</span>.inner.get_provisioned_throughput()
<a href=#459 id=459 data-nosnippet>459</a>    }
<a href=#460 id=460 data-nosnippet>460</a>    <span class="doccomment">/// &lt;p&gt;The settings for DynamoDB Streams on the table. These settings consist of:&lt;/p&gt;
<a href=#461 id=461 data-nosnippet>461</a>    /// &lt;ul&gt;
<a href=#462 id=462 data-nosnippet>462</a>    /// &lt;li&gt;
<a href=#463 id=463 data-nosnippet>463</a>    /// &lt;p&gt;&lt;code&gt;StreamEnabled&lt;/code&gt; - Indicates whether DynamoDB Streams is to be enabled (true) or disabled (false).&lt;/p&gt;&lt;/li&gt;
<a href=#464 id=464 data-nosnippet>464</a>    /// &lt;li&gt;
<a href=#465 id=465 data-nosnippet>465</a>    /// &lt;p&gt;&lt;code&gt;StreamViewType&lt;/code&gt; - When an item in the table is modified, &lt;code&gt;StreamViewType&lt;/code&gt; determines what information is written to the table's stream. Valid values for &lt;code&gt;StreamViewType&lt;/code&gt; are:&lt;/p&gt;
<a href=#466 id=466 data-nosnippet>466</a>    /// &lt;ul&gt;
<a href=#467 id=467 data-nosnippet>467</a>    /// &lt;li&gt;
<a href=#468 id=468 data-nosnippet>468</a>    /// &lt;p&gt;&lt;code&gt;KEYS_ONLY&lt;/code&gt; - Only the key attributes of the modified item are written to the stream.&lt;/p&gt;&lt;/li&gt;
<a href=#469 id=469 data-nosnippet>469</a>    /// &lt;li&gt;
<a href=#470 id=470 data-nosnippet>470</a>    /// &lt;p&gt;&lt;code&gt;NEW_IMAGE&lt;/code&gt; - The entire item, as it appears after it was modified, is written to the stream.&lt;/p&gt;&lt;/li&gt;
<a href=#471 id=471 data-nosnippet>471</a>    /// &lt;li&gt;
<a href=#472 id=472 data-nosnippet>472</a>    /// &lt;p&gt;&lt;code&gt;OLD_IMAGE&lt;/code&gt; - The entire item, as it appeared before it was modified, is written to the stream.&lt;/p&gt;&lt;/li&gt;
<a href=#473 id=473 data-nosnippet>473</a>    /// &lt;li&gt;
<a href=#474 id=474 data-nosnippet>474</a>    /// &lt;p&gt;&lt;code&gt;NEW_AND_OLD_IMAGES&lt;/code&gt; - Both the new and the old item images of the item are written to the stream.&lt;/p&gt;&lt;/li&gt;
<a href=#475 id=475 data-nosnippet>475</a>    /// &lt;/ul&gt;&lt;/li&gt;
<a href=#476 id=476 data-nosnippet>476</a>    /// &lt;/ul&gt;
<a href=#477 id=477 data-nosnippet>477</a>    </span><span class="kw">pub fn </span>stream_specification(<span class="kw-2">mut </span><span class="self">self</span>, input: <span class="kw">crate</span>::types::StreamSpecification) -&gt; <span class="self">Self </span>{
<a href=#478 id=478 data-nosnippet>478</a>        <span class="self">self</span>.inner = <span class="self">self</span>.inner.stream_specification(input);
<a href=#479 id=479 data-nosnippet>479</a>        <span class="self">self
<a href=#480 id=480 data-nosnippet>480</a>    </span>}
<a href=#481 id=481 data-nosnippet>481</a>    <span class="doccomment">/// &lt;p&gt;The settings for DynamoDB Streams on the table. These settings consist of:&lt;/p&gt;
<a href=#482 id=482 data-nosnippet>482</a>    /// &lt;ul&gt;
<a href=#483 id=483 data-nosnippet>483</a>    /// &lt;li&gt;
<a href=#484 id=484 data-nosnippet>484</a>    /// &lt;p&gt;&lt;code&gt;StreamEnabled&lt;/code&gt; - Indicates whether DynamoDB Streams is to be enabled (true) or disabled (false).&lt;/p&gt;&lt;/li&gt;
<a href=#485 id=485 data-nosnippet>485</a>    /// &lt;li&gt;
<a href=#486 id=486 data-nosnippet>486</a>    /// &lt;p&gt;&lt;code&gt;StreamViewType&lt;/code&gt; - When an item in the table is modified, &lt;code&gt;StreamViewType&lt;/code&gt; determines what information is written to the table's stream. Valid values for &lt;code&gt;StreamViewType&lt;/code&gt; are:&lt;/p&gt;
<a href=#487 id=487 data-nosnippet>487</a>    /// &lt;ul&gt;
<a href=#488 id=488 data-nosnippet>488</a>    /// &lt;li&gt;
<a href=#489 id=489 data-nosnippet>489</a>    /// &lt;p&gt;&lt;code&gt;KEYS_ONLY&lt;/code&gt; - Only the key attributes of the modified item are written to the stream.&lt;/p&gt;&lt;/li&gt;
<a href=#490 id=490 data-nosnippet>490</a>    /// &lt;li&gt;
<a href=#491 id=491 data-nosnippet>491</a>    /// &lt;p&gt;&lt;code&gt;NEW_IMAGE&lt;/code&gt; - The entire item, as it appears after it was modified, is written to the stream.&lt;/p&gt;&lt;/li&gt;
<a href=#492 id=492 data-nosnippet>492</a>    /// &lt;li&gt;
<a href=#493 id=493 data-nosnippet>493</a>    /// &lt;p&gt;&lt;code&gt;OLD_IMAGE&lt;/code&gt; - The entire item, as it appeared before it was modified, is written to the stream.&lt;/p&gt;&lt;/li&gt;
<a href=#494 id=494 data-nosnippet>494</a>    /// &lt;li&gt;
<a href=#495 id=495 data-nosnippet>495</a>    /// &lt;p&gt;&lt;code&gt;NEW_AND_OLD_IMAGES&lt;/code&gt; - Both the new and the old item images of the item are written to the stream.&lt;/p&gt;&lt;/li&gt;
<a href=#496 id=496 data-nosnippet>496</a>    /// &lt;/ul&gt;&lt;/li&gt;
<a href=#497 id=497 data-nosnippet>497</a>    /// &lt;/ul&gt;
<a href=#498 id=498 data-nosnippet>498</a>    </span><span class="kw">pub fn </span>set_stream_specification(<span class="kw-2">mut </span><span class="self">self</span>, input: ::std::option::Option&lt;<span class="kw">crate</span>::types::StreamSpecification&gt;) -&gt; <span class="self">Self </span>{
<a href=#499 id=499 data-nosnippet>499</a>        <span class="self">self</span>.inner = <span class="self">self</span>.inner.set_stream_specification(input);
<a href=#500 id=500 data-nosnippet>500</a>        <span class="self">self
<a href=#501 id=501 data-nosnippet>501</a>    </span>}
<a href=#502 id=502 data-nosnippet>502</a>    <span class="doccomment">/// &lt;p&gt;The settings for DynamoDB Streams on the table. These settings consist of:&lt;/p&gt;
<a href=#503 id=503 data-nosnippet>503</a>    /// &lt;ul&gt;
<a href=#504 id=504 data-nosnippet>504</a>    /// &lt;li&gt;
<a href=#505 id=505 data-nosnippet>505</a>    /// &lt;p&gt;&lt;code&gt;StreamEnabled&lt;/code&gt; - Indicates whether DynamoDB Streams is to be enabled (true) or disabled (false).&lt;/p&gt;&lt;/li&gt;
<a href=#506 id=506 data-nosnippet>506</a>    /// &lt;li&gt;
<a href=#507 id=507 data-nosnippet>507</a>    /// &lt;p&gt;&lt;code&gt;StreamViewType&lt;/code&gt; - When an item in the table is modified, &lt;code&gt;StreamViewType&lt;/code&gt; determines what information is written to the table's stream. Valid values for &lt;code&gt;StreamViewType&lt;/code&gt; are:&lt;/p&gt;
<a href=#508 id=508 data-nosnippet>508</a>    /// &lt;ul&gt;
<a href=#509 id=509 data-nosnippet>509</a>    /// &lt;li&gt;
<a href=#510 id=510 data-nosnippet>510</a>    /// &lt;p&gt;&lt;code&gt;KEYS_ONLY&lt;/code&gt; - Only the key attributes of the modified item are written to the stream.&lt;/p&gt;&lt;/li&gt;
<a href=#511 id=511 data-nosnippet>511</a>    /// &lt;li&gt;
<a href=#512 id=512 data-nosnippet>512</a>    /// &lt;p&gt;&lt;code&gt;NEW_IMAGE&lt;/code&gt; - The entire item, as it appears after it was modified, is written to the stream.&lt;/p&gt;&lt;/li&gt;
<a href=#513 id=513 data-nosnippet>513</a>    /// &lt;li&gt;
<a href=#514 id=514 data-nosnippet>514</a>    /// &lt;p&gt;&lt;code&gt;OLD_IMAGE&lt;/code&gt; - The entire item, as it appeared before it was modified, is written to the stream.&lt;/p&gt;&lt;/li&gt;
<a href=#515 id=515 data-nosnippet>515</a>    /// &lt;li&gt;
<a href=#516 id=516 data-nosnippet>516</a>    /// &lt;p&gt;&lt;code&gt;NEW_AND_OLD_IMAGES&lt;/code&gt; - Both the new and the old item images of the item are written to the stream.&lt;/p&gt;&lt;/li&gt;
<a href=#517 id=517 data-nosnippet>517</a>    /// &lt;/ul&gt;&lt;/li&gt;
<a href=#518 id=518 data-nosnippet>518</a>    /// &lt;/ul&gt;
<a href=#519 id=519 data-nosnippet>519</a>    </span><span class="kw">pub fn </span>get_stream_specification(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span>::std::option::Option&lt;<span class="kw">crate</span>::types::StreamSpecification&gt; {
<a href=#520 id=520 data-nosnippet>520</a>        <span class="self">self</span>.inner.get_stream_specification()
<a href=#521 id=521 data-nosnippet>521</a>    }
<a href=#522 id=522 data-nosnippet>522</a>    <span class="doccomment">/// &lt;p&gt;Represents the settings used to enable server-side encryption.&lt;/p&gt;
<a href=#523 id=523 data-nosnippet>523</a>    </span><span class="kw">pub fn </span>sse_specification(<span class="kw-2">mut </span><span class="self">self</span>, input: <span class="kw">crate</span>::types::SseSpecification) -&gt; <span class="self">Self </span>{
<a href=#524 id=524 data-nosnippet>524</a>        <span class="self">self</span>.inner = <span class="self">self</span>.inner.sse_specification(input);
<a href=#525 id=525 data-nosnippet>525</a>        <span class="self">self
<a href=#526 id=526 data-nosnippet>526</a>    </span>}
<a href=#527 id=527 data-nosnippet>527</a>    <span class="doccomment">/// &lt;p&gt;Represents the settings used to enable server-side encryption.&lt;/p&gt;
<a href=#528 id=528 data-nosnippet>528</a>    </span><span class="kw">pub fn </span>set_sse_specification(<span class="kw-2">mut </span><span class="self">self</span>, input: ::std::option::Option&lt;<span class="kw">crate</span>::types::SseSpecification&gt;) -&gt; <span class="self">Self </span>{
<a href=#529 id=529 data-nosnippet>529</a>        <span class="self">self</span>.inner = <span class="self">self</span>.inner.set_sse_specification(input);
<a href=#530 id=530 data-nosnippet>530</a>        <span class="self">self
<a href=#531 id=531 data-nosnippet>531</a>    </span>}
<a href=#532 id=532 data-nosnippet>532</a>    <span class="doccomment">/// &lt;p&gt;Represents the settings used to enable server-side encryption.&lt;/p&gt;
<a href=#533 id=533 data-nosnippet>533</a>    </span><span class="kw">pub fn </span>get_sse_specification(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span>::std::option::Option&lt;<span class="kw">crate</span>::types::SseSpecification&gt; {
<a href=#534 id=534 data-nosnippet>534</a>        <span class="self">self</span>.inner.get_sse_specification()
<a href=#535 id=535 data-nosnippet>535</a>    }
<a href=#536 id=536 data-nosnippet>536</a>    <span class="doccomment">///
<a href=#537 id=537 data-nosnippet>537</a>    /// Appends an item to `Tags`.
<a href=#538 id=538 data-nosnippet>538</a>    ///
<a href=#539 id=539 data-nosnippet>539</a>    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
<a href=#540 id=540 data-nosnippet>540</a>    ///
<a href=#541 id=541 data-nosnippet>541</a>    /// &lt;p&gt;A list of key-value pairs to label the table. For more information, see &lt;a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Tagging.html"&gt;Tagging for DynamoDB&lt;/a&gt;.&lt;/p&gt;
<a href=#542 id=542 data-nosnippet>542</a>    </span><span class="kw">pub fn </span>tags(<span class="kw-2">mut </span><span class="self">self</span>, input: <span class="kw">crate</span>::types::Tag) -&gt; <span class="self">Self </span>{
<a href=#543 id=543 data-nosnippet>543</a>        <span class="self">self</span>.inner = <span class="self">self</span>.inner.tags(input);
<a href=#544 id=544 data-nosnippet>544</a>        <span class="self">self
<a href=#545 id=545 data-nosnippet>545</a>    </span>}
<a href=#546 id=546 data-nosnippet>546</a>    <span class="doccomment">/// &lt;p&gt;A list of key-value pairs to label the table. For more information, see &lt;a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Tagging.html"&gt;Tagging for DynamoDB&lt;/a&gt;.&lt;/p&gt;
<a href=#547 id=547 data-nosnippet>547</a>    </span><span class="kw">pub fn </span>set_tags(<span class="kw-2">mut </span><span class="self">self</span>, input: ::std::option::Option&lt;::std::vec::Vec&lt;<span class="kw">crate</span>::types::Tag&gt;&gt;) -&gt; <span class="self">Self </span>{
<a href=#548 id=548 data-nosnippet>548</a>        <span class="self">self</span>.inner = <span class="self">self</span>.inner.set_tags(input);
<a href=#549 id=549 data-nosnippet>549</a>        <span class="self">self
<a href=#550 id=550 data-nosnippet>550</a>    </span>}
<a href=#551 id=551 data-nosnippet>551</a>    <span class="doccomment">/// &lt;p&gt;A list of key-value pairs to label the table. For more information, see &lt;a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Tagging.html"&gt;Tagging for DynamoDB&lt;/a&gt;.&lt;/p&gt;
<a href=#552 id=552 data-nosnippet>552</a>    </span><span class="kw">pub fn </span>get_tags(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span>::std::option::Option&lt;::std::vec::Vec&lt;<span class="kw">crate</span>::types::Tag&gt;&gt; {
<a href=#553 id=553 data-nosnippet>553</a>        <span class="self">self</span>.inner.get_tags()
<a href=#554 id=554 data-nosnippet>554</a>    }
<a href=#555 id=555 data-nosnippet>555</a>    <span class="doccomment">/// &lt;p&gt;The table class of the new table. Valid values are &lt;code&gt;STANDARD&lt;/code&gt; and &lt;code&gt;STANDARD_INFREQUENT_ACCESS&lt;/code&gt;.&lt;/p&gt;
<a href=#556 id=556 data-nosnippet>556</a>    </span><span class="kw">pub fn </span>table_class(<span class="kw-2">mut </span><span class="self">self</span>, input: <span class="kw">crate</span>::types::TableClass) -&gt; <span class="self">Self </span>{
<a href=#557 id=557 data-nosnippet>557</a>        <span class="self">self</span>.inner = <span class="self">self</span>.inner.table_class(input);
<a href=#558 id=558 data-nosnippet>558</a>        <span class="self">self
<a href=#559 id=559 data-nosnippet>559</a>    </span>}
<a href=#560 id=560 data-nosnippet>560</a>    <span class="doccomment">/// &lt;p&gt;The table class of the new table. Valid values are &lt;code&gt;STANDARD&lt;/code&gt; and &lt;code&gt;STANDARD_INFREQUENT_ACCESS&lt;/code&gt;.&lt;/p&gt;
<a href=#561 id=561 data-nosnippet>561</a>    </span><span class="kw">pub fn </span>set_table_class(<span class="kw-2">mut </span><span class="self">self</span>, input: ::std::option::Option&lt;<span class="kw">crate</span>::types::TableClass&gt;) -&gt; <span class="self">Self </span>{
<a href=#562 id=562 data-nosnippet>562</a>        <span class="self">self</span>.inner = <span class="self">self</span>.inner.set_table_class(input);
<a href=#563 id=563 data-nosnippet>563</a>        <span class="self">self
<a href=#564 id=564 data-nosnippet>564</a>    </span>}
<a href=#565 id=565 data-nosnippet>565</a>    <span class="doccomment">/// &lt;p&gt;The table class of the new table. Valid values are &lt;code&gt;STANDARD&lt;/code&gt; and &lt;code&gt;STANDARD_INFREQUENT_ACCESS&lt;/code&gt;.&lt;/p&gt;
<a href=#566 id=566 data-nosnippet>566</a>    </span><span class="kw">pub fn </span>get_table_class(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span>::std::option::Option&lt;<span class="kw">crate</span>::types::TableClass&gt; {
<a href=#567 id=567 data-nosnippet>567</a>        <span class="self">self</span>.inner.get_table_class()
<a href=#568 id=568 data-nosnippet>568</a>    }
<a href=#569 id=569 data-nosnippet>569</a>    <span class="doccomment">/// &lt;p&gt;Indicates whether deletion protection is to be enabled (true) or disabled (false) on the table.&lt;/p&gt;
<a href=#570 id=570 data-nosnippet>570</a>    </span><span class="kw">pub fn </span>deletion_protection_enabled(<span class="kw-2">mut </span><span class="self">self</span>, input: bool) -&gt; <span class="self">Self </span>{
<a href=#571 id=571 data-nosnippet>571</a>        <span class="self">self</span>.inner = <span class="self">self</span>.inner.deletion_protection_enabled(input);
<a href=#572 id=572 data-nosnippet>572</a>        <span class="self">self
<a href=#573 id=573 data-nosnippet>573</a>    </span>}
<a href=#574 id=574 data-nosnippet>574</a>    <span class="doccomment">/// &lt;p&gt;Indicates whether deletion protection is to be enabled (true) or disabled (false) on the table.&lt;/p&gt;
<a href=#575 id=575 data-nosnippet>575</a>    </span><span class="kw">pub fn </span>set_deletion_protection_enabled(<span class="kw-2">mut </span><span class="self">self</span>, input: ::std::option::Option&lt;bool&gt;) -&gt; <span class="self">Self </span>{
<a href=#576 id=576 data-nosnippet>576</a>        <span class="self">self</span>.inner = <span class="self">self</span>.inner.set_deletion_protection_enabled(input);
<a href=#577 id=577 data-nosnippet>577</a>        <span class="self">self
<a href=#578 id=578 data-nosnippet>578</a>    </span>}
<a href=#579 id=579 data-nosnippet>579</a>    <span class="doccomment">/// &lt;p&gt;Indicates whether deletion protection is to be enabled (true) or disabled (false) on the table.&lt;/p&gt;
<a href=#580 id=580 data-nosnippet>580</a>    </span><span class="kw">pub fn </span>get_deletion_protection_enabled(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span>::std::option::Option&lt;bool&gt; {
<a href=#581 id=581 data-nosnippet>581</a>        <span class="self">self</span>.inner.get_deletion_protection_enabled()
<a href=#582 id=582 data-nosnippet>582</a>    }
<a href=#583 id=583 data-nosnippet>583</a>    <span class="doccomment">/// &lt;p&gt;Represents the warm throughput (in read units per second and write units per second) for creating a table.&lt;/p&gt;
<a href=#584 id=584 data-nosnippet>584</a>    </span><span class="kw">pub fn </span>warm_throughput(<span class="kw-2">mut </span><span class="self">self</span>, input: <span class="kw">crate</span>::types::WarmThroughput) -&gt; <span class="self">Self </span>{
<a href=#585 id=585 data-nosnippet>585</a>        <span class="self">self</span>.inner = <span class="self">self</span>.inner.warm_throughput(input);
<a href=#586 id=586 data-nosnippet>586</a>        <span class="self">self
<a href=#587 id=587 data-nosnippet>587</a>    </span>}
<a href=#588 id=588 data-nosnippet>588</a>    <span class="doccomment">/// &lt;p&gt;Represents the warm throughput (in read units per second and write units per second) for creating a table.&lt;/p&gt;
<a href=#589 id=589 data-nosnippet>589</a>    </span><span class="kw">pub fn </span>set_warm_throughput(<span class="kw-2">mut </span><span class="self">self</span>, input: ::std::option::Option&lt;<span class="kw">crate</span>::types::WarmThroughput&gt;) -&gt; <span class="self">Self </span>{
<a href=#590 id=590 data-nosnippet>590</a>        <span class="self">self</span>.inner = <span class="self">self</span>.inner.set_warm_throughput(input);
<a href=#591 id=591 data-nosnippet>591</a>        <span class="self">self
<a href=#592 id=592 data-nosnippet>592</a>    </span>}
<a href=#593 id=593 data-nosnippet>593</a>    <span class="doccomment">/// &lt;p&gt;Represents the warm throughput (in read units per second and write units per second) for creating a table.&lt;/p&gt;
<a href=#594 id=594 data-nosnippet>594</a>    </span><span class="kw">pub fn </span>get_warm_throughput(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span>::std::option::Option&lt;<span class="kw">crate</span>::types::WarmThroughput&gt; {
<a href=#595 id=595 data-nosnippet>595</a>        <span class="self">self</span>.inner.get_warm_throughput()
<a href=#596 id=596 data-nosnippet>596</a>    }
<a href=#597 id=597 data-nosnippet>597</a>    <span class="doccomment">/// &lt;p&gt;An Amazon Web Services resource-based policy document in JSON format that will be attached to the table.&lt;/p&gt;
<a href=#598 id=598 data-nosnippet>598</a>    /// &lt;p&gt;When you attach a resource-based policy while creating a table, the policy application is &lt;i&gt;strongly consistent&lt;/i&gt;.&lt;/p&gt;
<a href=#599 id=599 data-nosnippet>599</a>    /// &lt;p&gt;The maximum size supported for a resource-based policy document is 20 KB. DynamoDB counts whitespaces when calculating the size of a policy against this limit. For a full list of all considerations that apply for resource-based policies, see &lt;a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-considerations.html"&gt;Resource-based policy considerations&lt;/a&gt;.&lt;/p&gt;&lt;note&gt;
<a href=#600 id=600 data-nosnippet>600</a>    /// &lt;p&gt;You need to specify the &lt;code&gt;CreateTable&lt;/code&gt; and &lt;code&gt;PutResourcePolicy&lt;/code&gt; IAM actions for authorizing a user to create a table with a resource-based policy.&lt;/p&gt;
<a href=#601 id=601 data-nosnippet>601</a>    /// &lt;/note&gt;
<a href=#602 id=602 data-nosnippet>602</a>    </span><span class="kw">pub fn </span>resource_policy(<span class="kw-2">mut </span><span class="self">self</span>, input: <span class="kw">impl </span>::std::convert::Into&lt;::std::string::String&gt;) -&gt; <span class="self">Self </span>{
<a href=#603 id=603 data-nosnippet>603</a>        <span class="self">self</span>.inner = <span class="self">self</span>.inner.resource_policy(input.into());
<a href=#604 id=604 data-nosnippet>604</a>        <span class="self">self
<a href=#605 id=605 data-nosnippet>605</a>    </span>}
<a href=#606 id=606 data-nosnippet>606</a>    <span class="doccomment">/// &lt;p&gt;An Amazon Web Services resource-based policy document in JSON format that will be attached to the table.&lt;/p&gt;
<a href=#607 id=607 data-nosnippet>607</a>    /// &lt;p&gt;When you attach a resource-based policy while creating a table, the policy application is &lt;i&gt;strongly consistent&lt;/i&gt;.&lt;/p&gt;
<a href=#608 id=608 data-nosnippet>608</a>    /// &lt;p&gt;The maximum size supported for a resource-based policy document is 20 KB. DynamoDB counts whitespaces when calculating the size of a policy against this limit. For a full list of all considerations that apply for resource-based policies, see &lt;a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-considerations.html"&gt;Resource-based policy considerations&lt;/a&gt;.&lt;/p&gt;&lt;note&gt;
<a href=#609 id=609 data-nosnippet>609</a>    /// &lt;p&gt;You need to specify the &lt;code&gt;CreateTable&lt;/code&gt; and &lt;code&gt;PutResourcePolicy&lt;/code&gt; IAM actions for authorizing a user to create a table with a resource-based policy.&lt;/p&gt;
<a href=#610 id=610 data-nosnippet>610</a>    /// &lt;/note&gt;
<a href=#611 id=611 data-nosnippet>611</a>    </span><span class="kw">pub fn </span>set_resource_policy(<span class="kw-2">mut </span><span class="self">self</span>, input: ::std::option::Option&lt;::std::string::String&gt;) -&gt; <span class="self">Self </span>{
<a href=#612 id=612 data-nosnippet>612</a>        <span class="self">self</span>.inner = <span class="self">self</span>.inner.set_resource_policy(input);
<a href=#613 id=613 data-nosnippet>613</a>        <span class="self">self
<a href=#614 id=614 data-nosnippet>614</a>    </span>}
<a href=#615 id=615 data-nosnippet>615</a>    <span class="doccomment">/// &lt;p&gt;An Amazon Web Services resource-based policy document in JSON format that will be attached to the table.&lt;/p&gt;
<a href=#616 id=616 data-nosnippet>616</a>    /// &lt;p&gt;When you attach a resource-based policy while creating a table, the policy application is &lt;i&gt;strongly consistent&lt;/i&gt;.&lt;/p&gt;
<a href=#617 id=617 data-nosnippet>617</a>    /// &lt;p&gt;The maximum size supported for a resource-based policy document is 20 KB. DynamoDB counts whitespaces when calculating the size of a policy against this limit. For a full list of all considerations that apply for resource-based policies, see &lt;a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-considerations.html"&gt;Resource-based policy considerations&lt;/a&gt;.&lt;/p&gt;&lt;note&gt;
<a href=#618 id=618 data-nosnippet>618</a>    /// &lt;p&gt;You need to specify the &lt;code&gt;CreateTable&lt;/code&gt; and &lt;code&gt;PutResourcePolicy&lt;/code&gt; IAM actions for authorizing a user to create a table with a resource-based policy.&lt;/p&gt;
<a href=#619 id=619 data-nosnippet>619</a>    /// &lt;/note&gt;
<a href=#620 id=620 data-nosnippet>620</a>    </span><span class="kw">pub fn </span>get_resource_policy(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span>::std::option::Option&lt;::std::string::String&gt; {
<a href=#621 id=621 data-nosnippet>621</a>        <span class="self">self</span>.inner.get_resource_policy()
<a href=#622 id=622 data-nosnippet>622</a>    }
<a href=#623 id=623 data-nosnippet>623</a>    <span class="doccomment">/// &lt;p&gt;Sets the maximum number of read and write units for the specified table in on-demand capacity mode. If you use this parameter, you must specify &lt;code&gt;MaxReadRequestUnits&lt;/code&gt;, &lt;code&gt;MaxWriteRequestUnits&lt;/code&gt;, or both.&lt;/p&gt;
<a href=#624 id=624 data-nosnippet>624</a>    </span><span class="kw">pub fn </span>on_demand_throughput(<span class="kw-2">mut </span><span class="self">self</span>, input: <span class="kw">crate</span>::types::OnDemandThroughput) -&gt; <span class="self">Self </span>{
<a href=#625 id=625 data-nosnippet>625</a>        <span class="self">self</span>.inner = <span class="self">self</span>.inner.on_demand_throughput(input);
<a href=#626 id=626 data-nosnippet>626</a>        <span class="self">self
<a href=#627 id=627 data-nosnippet>627</a>    </span>}
<a href=#628 id=628 data-nosnippet>628</a>    <span class="doccomment">/// &lt;p&gt;Sets the maximum number of read and write units for the specified table in on-demand capacity mode. If you use this parameter, you must specify &lt;code&gt;MaxReadRequestUnits&lt;/code&gt;, &lt;code&gt;MaxWriteRequestUnits&lt;/code&gt;, or both.&lt;/p&gt;
<a href=#629 id=629 data-nosnippet>629</a>    </span><span class="kw">pub fn </span>set_on_demand_throughput(<span class="kw-2">mut </span><span class="self">self</span>, input: ::std::option::Option&lt;<span class="kw">crate</span>::types::OnDemandThroughput&gt;) -&gt; <span class="self">Self </span>{
<a href=#630 id=630 data-nosnippet>630</a>        <span class="self">self</span>.inner = <span class="self">self</span>.inner.set_on_demand_throughput(input);
<a href=#631 id=631 data-nosnippet>631</a>        <span class="self">self
<a href=#632 id=632 data-nosnippet>632</a>    </span>}
<a href=#633 id=633 data-nosnippet>633</a>    <span class="doccomment">/// &lt;p&gt;Sets the maximum number of read and write units for the specified table in on-demand capacity mode. If you use this parameter, you must specify &lt;code&gt;MaxReadRequestUnits&lt;/code&gt;, &lt;code&gt;MaxWriteRequestUnits&lt;/code&gt;, or both.&lt;/p&gt;
<a href=#634 id=634 data-nosnippet>634</a>    </span><span class="kw">pub fn </span>get_on_demand_throughput(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span>::std::option::Option&lt;<span class="kw">crate</span>::types::OnDemandThroughput&gt; {
<a href=#635 id=635 data-nosnippet>635</a>        <span class="self">self</span>.inner.get_on_demand_throughput()
<a href=#636 id=636 data-nosnippet>636</a>    }
<a href=#637 id=637 data-nosnippet>637</a>}</code></pre></div></section></main></body></html>
searchState.loadedDescShard("triomphe", 0, "Fork of Arc. This has the following advantages over …\nAn atomically reference counted shared pointer\nA “borrowed <code>Arc</code>”. This is a pointer to a T that is …\nA tagged union that can represent <code>Arc&lt;A&gt;</code> or <code>Arc&lt;B&gt;</code> while …\nThis represents a borrow of an <code>ArcUnion</code>.\nStructure to allow Arc-managing some fixed-sized data and …\nHeader data with an inline length. Consumers that use …\nAn <code>Arc</code>, except it holds a pointer to the T instead of to …\nA “thin” <code>Arc</code> containing dynamically sized data\nAn <code>Arc</code> that is known to be uniquely owned\nReturns a borrow of the first type if applicable, …\nObtain a mutable pointer to the stored <code>MaybeUninit&lt;T&gt;</code>.\nObtain a mutable pointer to the stored <code>MaybeUninit&lt;T&gt;</code>.\nObtain a mutable slice to the stored <code>[MaybeUninit&lt;T&gt;]</code>.\nReturns the raw pointer.\nProvides a raw pointer to the data. The counts are not …\nReturns a borrow of the second type if applicable, …\nSafety\nSafety\nConvert to an initialized Arc.\nSafety\nSafety\nReturns an enum representing a borrow of either A or B.\nProduce a pointer to the data that can be converted back …\nProduce a pointer to the data that can be converted back …\nClone this as an <code>Arc&lt;T&gt;</code>. This bumps the refcount.\nClone it as an <code>Arc</code>\nGets the number of <code>Arc</code> pointers to this allocation\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates an <code>ArcUnion</code> from an instance of the first type.\nCreates an Arc for a HeaderSlice using the given header …\nCreates a <code>ThinArc</code> for a HeaderSlice using the given header …\nCreates an Arc for a HeaderSlice using the given header …\nCreates a <code>ThinArc</code> for a HeaderSlice using the given header …\nCreates an Arc for a HeaderSlice using the given header …\nCreates an Arc for a HeaderSlice using the given header …\nCreates an Arc for a HeaderSlice using the given header …\nFor constructing from a pointer known to be Arc-backed, …\nReconstruct the <code>Arc&lt;T&gt;</code> from a raw pointer obtained from …\nSafety\nConverts a <code>OffsetArc</code> into an <code>Arc</code>. This consumes the …\nReconstruct the <code>Arc&lt;[T]&gt;</code> from a raw pointer obtained from …\nCreates an <code>ArcUnion</code> from an instance of the second type.\nConverts a <code>ThinArc</code> into an <code>Arc</code>. This consumes the <code>ThinArc</code>, …\nSimilar to deref, but uses the lifetime |a| rather than …\nProvides mutable access to the contents <em>if</em> the <code>Arc</code> is …\nProvides unique access to the arc <em>if</em> the <code>Arc</code> is uniquely …\nThe fixed-sized data.\nThe fixed-sized data.\nReturns the address on the heap of the Arc itself – not …\nReturns the address on the heap of the Arc itself – not …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGets the inner value of the unique arc\nConvert the <code>Arc&lt;T&gt;</code> to a raw pointer, suitable for use …\nConsume ThinArc and returned the wrapped pointer.\nConverts an <code>Arc</code> into a <code>OffsetArc</code>. This consumes the <code>Arc</code>, …\nConverts an <code>Arc</code> into a <code>ThinArc</code>. This consumes the <code>Arc</code>, so …\nReturns true if this <code>ArcUnion</code> contains the first type.\nReturns true if this <code>ArcUnion</code> contains the second type.\nWhether or not the <code>Arc</code> is uniquely owned (is the refcount …\nThe slice length.\nMakes a mutable reference to the <code>Arc</code>, cloning if necessary\nIf uniquely owned, provide a mutable reference Else create …\nMakes a <code>UniqueArc</code> from an <code>Arc</code>, cloning if necessary.\nConstruct an <code>Arc&lt;T&gt;</code>\nConstruct a new UniqueArc\nCreates a new HeaderWithLength.\nCreate an Arc contains an <code>MaybeUninit&lt;T&gt;</code>.\nConstruct an uninitialized arc\nCreate an Arc contains an array <code>[MaybeUninit&lt;T&gt;]</code> of <code>len</code>.\nCreate an Arc contains an array <code>[MaybeUninit&lt;T&gt;]</code> of <code>len</code>.\nReturns the address on the heap of the ThinArc itself – …\nReturns <code>true</code> if the two <code>Arc</code>s point to the same allocation …\nReturns true if the two values are pointer-equal.\nCompare two <code>ArcBorrow</code>s via pointer equality. Will only …\nConvert to a shareable <code>Arc&lt;T&gt;</code> once we’re done mutating it\nThe dynamically-sized data.\nThe reference count of this <code>Arc</code>.\nReference count.\nThe reference count of this <code>Arc</code>.\nThe reference count of the underlying <code>Arc</code>.\nThe reference count of this <code>Arc</code>.\nThe reference count of this <code>Arc</code>.\nReturns a <code>UniqueArc</code> if the <code>Arc</code> has exactly one strong …\nReturns the inner value, if the <code>Arc</code> has exactly one strong …\nIf we have the only reference to <code>T</code> then unwrap it. …\nTemporarily converts |self| into a bonafide Arc and …\nTemporarily converts |self| into a bonafide Arc and …\nTemporarily converts |self| into a bonafide Arc and …\nTemporarily converts |self| into a bonafide Arc and …\nTemporarily converts |self| into a bonafide OffsetArc and …\nCalls <code>MaybeUninit::write</code> on the value contained.\nCalls <code>MaybeUninit::write</code> on the contained value.")
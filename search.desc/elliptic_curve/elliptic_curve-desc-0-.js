searchState.loadedDescShard("elliptic_curve", 0, "RustCrypto: Elliptic Curve Traits\nAlgorithm <code>ObjectIdentifier</code> for elliptic curve public key …\nElliptic curve point in affine coordinates.\nHow many bits of information can be reliably stored in the …\nElliptic curve.\nElliptic curve with an arithmetic implementation.\nPrime order elliptic curve group.\nGenerator of the <code>t-order</code> multiplicative subgroup.\nContains the error value\nElliptic curve errors.\nThis trait represents an element of a field.\nByte representation of a base/scalar field element of a …\nTrait for decoding/encoding <code>Curve::Uint</code> from/to <code>FieldBytes</code> …\nSize of serialized field elements of this elliptic curve.\nSize of a serialized field element in bytes.\nThis trait represents an element of a cryptographic group.\nModulus of the field written as a string for debugging …\nA fixed multiplicative generator of <code>modulus - 1</code> order. …\nHow many bits are needed to represent an element of this …\nThe one element of the field, the multiplicative identity.\nOrder of this elliptic curve, i.e. number of elements in …\nContains the success value\nMarker trait for elliptic curves with prime order.\nPrime order elliptic curve with projective arithmetic …\nThis represents an element of a non-binary prime field.\nDerive the <code>PrimeField</code> trait.\nElliptic curve point in projective coordinates.\nElliptic curve public keys.\nThe <code>2^s</code> root of unity.\nInverse of <code>Self::ROOT_OF_UNITY</code>.\nThe prime field can be converted back and forth into this …\nResult type with the <code>elliptic-curve</code> crate’s <code>Error</code> type.\nAn integer <code>s</code> satisfying the equation <code>2^s * t = modulus - 1</code> …\nScalars modulo the order of this group’s scalar field.\nScalar field modulo this curve’s order.\nElliptic curve secret keys.\nInverse of $2$ in the field.\nInteger type used to represent field elements of this …\nThe zero element of the field, the additive identity.\nBorrow the inner <code>AffinePoint</code> from this <code>PublicKey</code>.\nBorrow the inner secret <code>ScalarPrimitive</code> value.\nCubes this element.\nDecode unsigned integer from serialized field element.\nDecode unsigned integer from serialized field element.\nDoubles this element.\nDoubles this element.\nEncode unsigned integer into serialized field element.\nEncode unsigned integer into serialized field element.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert an <code>AffinePoint</code> into a <code>PublicKey</code>\nDeserialize secret key from an encoded secret scalar.\nInitialize <code>PublicKey</code> from an <code>EncodedPoint</code>\nAttempts to convert a byte representation of a field …\nAttempts to convert a byte representation of a field …\nDecode <code>PublicKey</code> (compressed or uncompressed) from the …\nDeserialize secret key encoded in the SEC1 ASN.1 DER …\nParse <code>SecretKey</code> from PEM-encoded SEC1 <code>ECPrivateKey</code> format.\nCompute a <code>PublicKey</code> from a secret <code>NonZeroScalar</code> value …\nDeserialize secret key from an encoded secret scalar …\nInterpret a string of numbers as a (congruent) prime field …\nObtains a field element congruent to the integer <code>v</code>.\nReturns a fixed generator of the prime-order subgroup.\nReturns the additive identity, also known as the “…\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nComputes the multiplicative inverse of this element, …\nReturns true iff this element is even.\nDetermines if this point is the identity.\nReturns true iff this element is odd.\nReturns true iff this element is zero.\nReturns true iff this element is zero.\nCreate a new secret key from a scalar value.\nTraits for arithmetic operations on elliptic curve field …\nTraits for elliptic curve points.\nExponentiates <code>self</code> by <code>exp</code>, where <code>exp</code> is a little-endian …\nExponentiates <code>self</code> by <code>exp</code>, where <code>exp</code> is a little-endian …\nGet the <code>PublicKey</code> which corresponds to this secret key\nReturns an element chosen uniformly at random using a …\nReturns an element chosen uniformly at random from the …\nGenerate a random <code>SecretKey</code>.\nScalar types.\nSupport for SEC1 elliptic curve encoding formats.\nReturns the square root of the field element, if it is …\nEquivalent to <code>Self::sqrt_ratio(self, one())</code>.\nComputes:\nSquares this element.\nSerialize raw secret scalar as a big endian integer.\nSerialize this <code>PublicKey</code> as a SEC1 <code>EncodedPoint</code>, …\nConvert this <code>PublicKey</code> to a <code>NonIdentity</code> of the inner …\nGet the secret <code>NonZeroScalar</code> value for this key.\nConvert this <code>PublicKey</code> to a <code>ProjectivePoint</code> for the given …\nConverts an element of the prime field into the standard …\nConvert this <code>PublicKey</code> into the …\nSerialize secret key in the SEC1 ASN.1 DER <code>ECPrivateKey</code> …\nSerialize private key as self-zeroizing PEM-encoded SEC1 …\nComplete projective formulas for prime order elliptic …\nThe type-level bit 0.\nThe type-level bit 1.\nThe type-level signed integer 0.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInstantiates a singleton representing this bit.\nInstantiates a singleton representing this bit.\nInstantiates a singleton representing the integer 0.\nThe addition operator <code>+</code>.\nThe addition assignment operator <code>+=</code>.\nPerform a batched inversion on a sequence of field …\nBytes used as input to <code>Reduce::reduce_bytes</code>.\nPerform an inversion on a field element (i.e. base field …\nLinear combination.\nLinear combination (extended version).\nThe multiplication operator <code>*</code>.\nMultiplication by the generator.\nThe unary negation operator <code>-</code>.\nField element type\nThe output of batch inversion. A container of field …\nThe resulting type after applying the <code>+</code> operator.\nThe resulting type after applying the <code>-</code> operator.\nThe resulting type after applying the <code>-</code> operator.\nThe resulting type after applying the <code>*</code> operator.\nThe resulting type after applying the <code>&gt;&gt;</code> operator.\nModular reduction.\nModular reduction to a non-zero output.\nThe right shift operator <code>&gt;&gt;</code>. Note that because this trait …\nThe right shift assignment operator <code>&gt;&gt;=</code>.\nThe subtraction operator <code>-</code>.\nThe subtraction assignment operator <code>-=</code>.\nPerforms the <code>+</code> operation.\nPerforms the <code>+=</code> operation.\nInvert a batch of field elements.\nInvert a field element.\nInvert a field element in variable time.\nCalculates <code>x * k + y * l</code>.\nCalculates <code>x1 * k1 + ... + xn * kn</code>.\nPerforms the <code>*</code> operation.\nMultiply by the generator of the prime-order subgroup.\nPerforms the unary <code>-</code> operation.\nPerform a modular reduction, returning a field element.\nInterpret the given bytes as an integer and perform a …\nPerform a modular reduction, returning a field element.\nInterpret the given bytes as an integer and perform a …\nPerforms the <code>&gt;&gt;</code> operation.\nPerforms the <code>&gt;&gt;=</code> operation.\nPerforms the <code>-</code> operation.\nPerforms the <code>-=</code> operation.\nAccess to the affine coordinates of an elliptic curve …\nAffine point type for a given curve with a <code>CurveArithmetic</code> …\nNormalize point(s) in projective representation by …\nShould point compaction be applied by default?\nShould point compression be applied by default?\nDecompact an elliptic curve point from an x-coordinate.\nDecompress an elliptic curve point.\nDouble a point (i.e. add it to itself)\nField element representation.\nNon-identity point type.\nThe output of the batch normalization; a container of …\nPoint compaction settings.\nPoint compression settings.\nProjective point type for a given curve with a …\nPerform a batched conversion to affine representation on a …\nAttempt to decompact an elliptic curve point\nAttempt to decompress an elliptic curve point.\nDouble this point.\nReturns the argument unchanged.\nDecode a <code>NonIdentity</code> from its encoding.\nCalls <code>U::from(self)</code>.\nCreate a <code>NonIdentity</code> from a point.\nGenerate a random <code>NonIdentity&lt;ProjectivePoint&gt;</code>.\nConverts this element into its affine representation.\nConverts this element to its curve representation.\nReturn wrapped point.\nGet the affine x-coordinate as a serialized field element.\nIs the affine y-coordinate odd?\nScalar blinded with a randomly generated masking value.\nInstantiate a scalar from an unsigned integer without …\nIs this scalar greater than n / 2?\nScalar modulus.\nNon-zero scalar type.\nMultiplicative identity.\nScalar field element for a particular elliptic curve.\nGeneric scalar type with primitive functionality.\nUnsigned integer type (i.e. <code>Curve::Uint</code>)\nZero scalar.\nBorrow the inner limbs as a slice.\nBorrow the inner <code>C::Uint</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nDecode <code>ScalarPrimitive</code> from a serialized field element\nDecode a <code>NonZeroScalar</code> from a big endian-serialized field …\nDecode <code>ScalarPrimitive</code> from a big endian byte slice.\nCreate a <code>NonZeroScalar</code> from a <code>C::Uint</code>.\nInstantiate scalar from an unsigned integer without …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs this <code>ScalarPrimitive</code> value even?\nIs this scalar greater than or equal to n / 2?\nIs this <code>ScalarPrimitive</code> value odd?\nIs this <code>ScalarPrimitive</code> value equal to zero?\nCreate a new <code>BlindedScalar</code> from a scalar and a …\nCreate a <code>NonZeroScalar</code> from a scalar.\nCreate a new scalar from <code>Curve::Uint</code>.\nGenerate a random <code>NonZeroScalar</code>.\nGenerate a random <code>ScalarPrimitive</code>.\nEncode <code>ScalarPrimitive</code> as a serialized field element.\nConvert to a <code>C::Uint</code>.\nCompact curve point\nCompact point (<code>0x05</code>)\nCompressed curve point\nCompressed point with even y-coordinate (<code>0x02</code>)\nCompressed point with odd y-coordinate (<code>0x03</code>)\nEncoded elliptic curve point with point compression.\nSize of a compressed elliptic curve point.\nSize of a compressed point for the given elliptic curve …\nEnum representing the coordinates of either compressed or …\nEncoded elliptic curve point sized appropriately for a …\nTrait for deserializing a value from a SEC1 encoded curve …\nIdentity point (a.k.a. point at infinity)\nIdentity point (<code>0x00</code>)\nTrait for supported modulus sizes which precomputes the …\nTag byte used by the <code>Elliptic-Curve-Point-to-Octet-String</code> …\nTrait for serializing a value to a SEC1 encoded curve …\nTrait for serializing a value to a SEC1 encoded curve …\nUncompressed curve point\nUncompressed point (<code>0x04</code>)\nEncoded elliptic curve point <em>without</em> point compression.\nSize of an uncompressed elliptic curve point.\nSize of an uncompressed point for the given elliptic curve …\nSize of an untagged point for given elliptic curve, i.e. …\nValidate that the given <code>EncodedPoint</code> represents the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nDeserialize the type this trait is impl’d on from an …\nParse a tag value from a byte\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs this point compact?\nIs this point compressed?\nIs this point the identity point?\nCompute the expected total message length for a message …\nGet the tag octet needed to encode this set of <code>Coordinates</code>\nSerialize this value as a SEC1 <code>EncodedPoint</code>, optionally …\nSerialize this value as a SEC1 <code>EncodedPoint</code>, optionally …\nValidate that the given <code>EncodedPoint</code> is a valid public key …\nx-coordinate\nx-coordinate\nx-coordinate\ny-coordinate\nIs the y-coordinate odd?\nAffine point whose coordinates are represented by the …\nProjective point whose coordinates are represented by the …\nImplements the complete addition formula from …\nImplements the complete mixed addition formula from …\nImplements the exception-free point doubling formula from …")
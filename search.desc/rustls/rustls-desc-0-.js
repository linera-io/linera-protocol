searchState.loadedDescShard("rustls", 0, "Rustls - a modern TLS library\nA list of all the protocol versions supported by rustls.\nSecrets for the AES_128_GCM AEAD algorithm\nSecrets for the AES_256_GCM AEAD algorithm\nThe <code>AlertDescription</code> TLS protocol enum.  Values in this …\nWe received a fatal alert.  This means the peer is unhappy.\nThe certificate is valid, but the handshake is rejected …\nThe certificate is not correctly encoded.\nThe <code>max_fragment_size</code> value supplied in configuration was …\nA certificate is not correctly signed by the key of its …\nThe CRL had a bad signature from its issuer.\nThe ways in which a certificate revocation list (CRL) can …\nThe “TLS Certificate Compression Algorithm IDs” TLS …\nThe ways in which certificate validators can express …\nA certificate payload exceeded rustls’s 64KB limit\nSecrets for the CHACHA20_POLY1305 AEAD algorithm\nThe <code>CipherSuite</code> TLS protocol enum.  Values in this enum …\nCommon state for cipher suites (both for TLS 1.2 and TLS …\nA client initiates the connection.\nA client connection\nClient authentication\nConnection state common to both client and server …\nA builder for <code>ServerConfig</code> or <code>ClientConfig</code> values.\nHelper trait to abstract <code>ConfigBuilder</code> over building a …\nA client or server connection.\nInterface shared by client and server connections.\nSecrets used to encrypt/decrypt data in a TLS session.\nThe <code>ContentType</code> TLS protocol enum.  Values in this enum …\nThe version configuration that an application should use …\nWe couldn’t decrypt a message.  This is invariably fatal.\nThis type combines a <code>SignatureScheme</code> and a signature …\nA <code>DistinguishedName</code> is a <code>Vec&lt;u8&gt;</code> wrapped in internal types.\nA peer sent a message where a given extension type was …\nA server sent an empty ticket\nWe couldn’t encrypt a message because it was larger than …\nAn error that occurred while handling Encrypted Client …\nrustls reports protocol errors using this type.\nThe current time is after the <code>notAfter</code> time in the …\nThe current time is after the <code>notAfter</code> time in the …\nThe certificate’s revocation status could not be …\nThe certificate’s revocation status could not be …\nExtended Key Usage (EKU) purpose values.\nSecrets for transmitting/receiving data over a TLS session.\nWe failed to figure out what time it currently is.\nWe failed to acquire random bytes from the system.\nA full handshake.\nA full TLS1.3 handshake, with an extra round-trip for a …\nA catch-all error for unlikely errors.\nDescribes which sort of handshake happened.\nThis function doesn’t work until the TLS handshake is …\nAn advertised message was larger then expected.\nThe <code>HandshakeType</code> TLS protocol enum.  Values in this enum …\nA peer sent an empty list of items, but a non-empty list …\nA peer sent an empty value, but a non-empty value is …\nWe received a TLS handshake message that isn’t valid …\nWe received a TLS message that isn’t valid right now. …\nSpecific failure cases from <code>keys_match</code> or a …\nSpecific failure cases from <code>keys_match</code> or a …\nThe peer sent us a syntactically incorrect …\nContext was incorrectly attached to a certificate request …\nA provided certificate revocation list (CRL) was invalid.\nWe saw an invalid certificate.\nA peer sent an invalid certificate status type\nThe provided ECH configuration list was invalid.\nAn unknown content type was encountered during message …\nThe CRL contained an invalid CRL number.\nA peer’s DH params could not be decoded\nA message was zero-length when its record kind forbids it.\nAn error occurred while handling Encrypted Client Hello …\nA peer sent an unexpected key update request.\nA corrupt TLS message payload that resulted in an error.\nThe peer sent us a TLS message with invalid contents.\nThe OCSP response provided to the verifier was invalid.\nThe certificate is being used for a different purpose than …\nThe certificate is being used for a different purpose than …\nThe CRL contained a revoked certificate with an invalid …\nA peer’s server name could not be decoded\nValues of this structure are returned from …\nThe CRL issuer does not specify the cRLSign key usage.\nThis trait represents the ability to do something useful …\n<code>KeyLog</code> implementation that opens a file whose name is …\nThe public key returned by the <code>SigningKey</code> does not match …\nA TLS message payload was larger then allowed by the …\nMessage is shorter than the expected length\nMissing data for the named handshake payload value\nA peer did not advertise its supported key exchange groups.\nThe <code>NamedGroup</code> TLS protocol enum.  Values in this enum are …\nAn incoming connection did not support any known …\nThe peer didn’t give us any certificates.\nNo compatible ECH configuration.\nKeyLog that does exactly nothing.\nA peer sent an empty list of signature schemes\nThe subject names in an end-entity certificate do not …\nThe subject names in an end-entity certificate do not …\nThe current time is before the <code>notBefore</code> time in the …\nThe current time is before the <code>notBefore</code> time in the …\nAny other error.\nAny other error.\nOther EKU values\nThe CRL is invalid for some other reason.\nAny other error that cannot be expressed by a more …\nThe CRL is not correctly encoded.\nThe set of cases where we failed to make a connection …\nThe peer doesn’t support a protocol version/feature we …\nThe set of cases where we failed to make a connection …\nThe peer deviated from the standard TLS protocol. The …\nThe peer sent an oversized record/fragment.\nA peer sent a message with a PSK offer extension in wrong …\nThe <code>ProtocolVersion</code> TLS protocol enum.  Values in this …\nA structure that implements <code>std::io::Read</code> for reading …\nA resumed handshake.\nThe certificate has been revoked.\nA container for root certificates able to provide a …\nA server waits for a client to connect.\nA server connection\nServer authentication\nSide of the connection.\nData specific to the peer’s side (client or server).\nThe <code>SignatureAlgorithm</code> TLS protocol enum.  Values in this …\nThe <code>SignatureScheme</code> TLS protocol enum.  Values in this …\nThe client configuration has server name indication (SNI) …\nThis type implements <code>io::Read</code> and <code>io::Write</code>, encapsulating …\nThis type implements <code>io::Read</code> and <code>io::Write</code>, encapsulating …\nA cipher suite supported by rustls.\nA TLS protocol version supported by rustls.\nA TLS 1.2 cipher suite\nA TLS 1.2 cipher suite supported by rustls.\nA TLS 1.3 cipher suite\nA TLS 1.3 cipher suite supported by rustls.\nTrailing data found for the named handshake payload value\nA peer sent an unexpected message type.\nThe certificate contains an extension marked critical, but …\nThe <code>SigningKey</code> cannot produce its corresponding public key.\nThe peer sent a TLS1.3 Certificate with an unknown …\nA server sent a HelloRetryRequest with an unknown extension\nThe certificate chain is not issued by a known root …\nAn unknown TLS protocol was encountered during message …\nThe certificate’s revocation status could not be …\nA peer sent a non-null compression method.\nThe CRL, or a revoked certificate in the CRL, contained an …\nThe CRL is not a v2 X.509 CRL.\nA peer sent an unknown elliptic curve type.\nThe CRL is an unsupported delta CRL, containing only …\nThe CRL is an unsupported indirect CRL, containing revoked …\nA peer sent an unsupported key exchange algorithm.\nThe certificate verifier doesn’t support the given type …\nThe CRL contained a revoked certificate with an …\nA signature inside a certificate or on a handshake was …\nThe CRL had an unsupported signature from its issuer.\nA signature inside a certificate or on a handshake was …\nA signature inside a certificate or on a handshake was …\nA signature was made with an algorithm that doesn’t …\nA signature was made with an algorithm that doesn’t …\nConfig builder state where the caller must supply a …\nConfig builder state where the caller must supply TLS …\nA structure that implements <code>std::io::Write</code> for writing …\nAdd a single DER-encoded certificate to the store.\nParse the given DER-encoded certificates and add all that …\nHow to produce a <code>MessageDecrypter</code> or <code>MessageEncrypter</code> from …\nHow to produce a MessageDecrypter or MessageEncrypter from …\nRetrieves the protocol agreed with the peer via ALPN.\nCan a session using suite self resume from suite prev?\nItems for use in a client.\nCommon cipher suite fields.\nCommon cipher suite fields.\nThis function uses <code>io</code> to complete any outstanding IO for …\nThis function uses <code>io</code> to complete any outstanding IO for …\nCertificate compression and decompression support\nNumber of TCP-TLS messages that can be safely encrypted …\nOur TLS connection\nOur connection\nCrypto provider interface.\nReturn the crypto provider used to construct this builder.\nAccess configuration options whose use is dangerous and …\nExtract secrets, so they can be used when configuring …\nExtract secrets, so they can be used when configuring …\nMake a new, empty <code>RootCertStore</code>.\nDerives key material from the agreed connection secrets.\nDerives key material from the agreed connection secrets.\nThis module contains parameters for FFDHE named groups as …\nObtain a chunk of plaintext data received from the peer …\nReturn <code>true</code> if this is backed by a FIPS-approved …\nReturn <code>true</code> if this is backed by a FIPS-approved …\nReturn <code>true</code> if this is backed by a FIPS-approved …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet a mutable reference to the underlying socket\nGet a reference to the underlying socket\nWhich kind of handshake was performed.\nWhich hash function the suite uses.\nHow to complete HKDF with the suite’s hash function.\nCreate a <code>DistinguishedName</code> after prepending its outer …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nObtain a chunk of plaintext data received from the peer …\nExtract the <code>conn</code> and <code>sock</code> parts from the <code>StreamOwned</code>\nReturn true if there are no certificates.\nReturns true if the connection is currently performing the …\nKernel connection API.\nReturn the key exchange algorithm associated with this …\nHow to exchange/agree keys.\nSay how many certificates are in the container.\nAPIs abstracting over locking primitives.\nLog the given <code>secret</code>.  <code>client_random</code> is provided for …\nThis is the rustls manual.\nRetrieves the ciphersuite agreed with the peer.\nRetrieves the key exchange group agreed with the peer.\nMakes a new <code>KeyLogFile</code>.  The environment variable is …\nMake a new Stream using the Connection <code>conn</code> and …\nMake a new StreamOwned taking the Connection <code>conn</code> and …\nRetrieves the certificate chain or the raw public key used …\nTrue if the peer has sent us a close_notify alert.  This is\nRe-exports the contents of the rustls-pki-types crate for …\nHow many plaintext bytes could be obtained via …\nHow to compute the TLS1.2 PRF for the suite’s hash …\nProcesses any new packets read by a previous call to …\nProcesses any new packets read by a previous call to …\nRetrieves the protocol version agreed with the peer.\nAPIs for implementing QUIC TLS\nHow to create QUIC header and record protection algorithms …\nReturns a <code>quic::Suite</code> for the ciphersuite, if supported.\nObtain plaintext data received from the peer over this TLS …\nRead TLS content from <code>rd</code> into the internal buffer.\nRead TLS content from <code>rd</code>.\nReturns an object that allows reading plaintext.\nReturns an object that allows reading plaintext.\nSends a TLS1.3 <code>key_update</code> message to refresh a connection…\nSends a TLS1.3 <code>key_update</code> message to refresh a connection…\nResolve the set of supported <code>SignatureScheme</code>s from the …\nThe list of roots.\nsequence number and secrets for the “rx” (receive) …\nThe <code>SignatureScheme</code> used to produce the signature.\nQueues a <code>close_notify</code> warning alert to be sent in the next …\nItems for use in a server.\nSets a limit on the internal buffers used to buffer unsent …\nSets a limit on the internal buffers\nMessage signing interfaces.\nHow to sign messages for authentication.\nGet the signature.\nThe underlying transport, like a socket\nThe underlying transport, like a socket\nReturn the DER encoded <code>DistinguishedName</code> of each trust …\nThe cipher suite’s identifier\nThe TLS enumeration naming this cipher suite.\nAPIs for implementing TLS tickets\nThe library’s source of time.\nReturn the inner <code>Tls13CipherSuite</code> for this suite, if it is …\nHow many bytes could be written by <code>Connection::write_tls</code> …\nsequence number and secrets for the “tx” (transmit) …\nUnbuffered connection API\nReturn true if this suite is usable for a key only …\nAll defined protocol versions appear in this module.\nReturn supported protocol version for the cipher suite.\nThe TLS enumeration naming this version.\nReturns true if the caller should call <code>Connection::read_tls</code>…\nReturns true if the caller should call …\nIndicates whether the secret with label <code>label</code> will be …\nIndicates whether the secret with label <code>label</code> will be …\nSets a custom <code>ResolvesServerCert</code>.\nSets a single certificate chain and matching private key …\nSets a custom <code>ResolvesClientCert</code>.\nChoose how to verify client certificates.\nEnable Encrypted Client Hello (ECH) in the given mode.\nDisable client authentication.\nDo not support client auth.\nUse a specific set of protocol versions.\nChoose how to verify server certificates.\nAccept the default protocol versions: both TLS1.2 and …\nSets a single certificate chain and matching private key.  …\nSets a single certificate chain, matching private key and …\nChoose how to verify server certificates using a webpki …\nSend the plaintext <code>buf</code> to the peer, encrypting and …\nWrites TLS messages to <code>wr</code>.\nWrites TLS messages to <code>wr</code>.\nReturns an object that allows writing plaintext.\nReturns an object that allows writing plaintext.\nThe public key algorithm OID.\nThe signature algorithm OID that was unsupported.\nThe signature algorithm OID.\nSupported algorithms that were available for signature …\nExpected server name.\nThe nextUpdate time of the CRL.\nThe <code>notAfter</code> time of the certificate.\nThe <code>notBefore</code> time of the certificate.\nThe names presented in the end entity certificate.\nExtended key purposes that were presented in the peer’s …\nThe public key algorithm OID.\nExtended key purpose that was required by the application.\nThe signature algorithm OID that was unsupported.\nThe signature algorithm OID.\nSupported algorithms that were available for signature …\nThe validation time.\nThe validation time.\nThe validation time.\nInitialization vector\nInitialization vector\nInitialization vector\nAEAD Key\nAEAD Key\nAEAD Key\nWhich types we expected\nWhich handshake type we expected\nWhat type we received\nWhat handshake type we received\nECH was offered and the server accepted.\nAn exemplar <code>ResolvesClientCert</code> implementation that always …\nCommon configuration for (typically) all connections made …\nThis represents a single TLS client connection.\nState associated with a client connection.\nAn implementer of <code>ClientSessionStore</code> that stores everything\nA trait for the ability to store client session data, so …\nDisable 1.2 resumption.\nErrors that may arise when encrypting early (RTT-0) data\nConfiguration for performing encrypted client hello.\nConfiguration for GREASE Encrypted Client Hello.\nControls how Encrypted Client Hello (ECH) is used in a …\nAn enum representing ECH offer status.\nECH is enabled and the ClientHello will be encrypted based …\nEncryption error\nCannot encrypt more early data due to imposed limits\nNo ECH configuration is available but the client should …\nGREASE ECH was sent. This is not considered offering ECH.\nA provided CRL could not be parsed.\nNo root trust anchors were provided.\nECH was not offered - it is a normal TLS handshake.\nECH was offered but we do not yet know whether the offer …\nECH was offered and the server rejected.\nA trait for the ability to choose a certificate chain and …\nConfiguration for how/when a client is allowed to resume a …\nA builder for configuring a <code>webpki</code> server certificate …\nSupport 1.2 resumption using session ids only.\nSupport 1.2 resumption using session ids or RFC 5077 …\nWhat mechanisms to support for resuming a TLS 1.2 session.\nUnbuffered version of <code>ClientConnection</code>\nAn error that can occur when building a certificate …\nA config builder state where the caller needs to supply …\nDefault <code>ServerCertVerifier</code>, see the trait impl for more …\nStub that implements io::Write and dispatches to …\nAllow unknown certificate revocation status when using …\nWhich ALPN protocols we include in our client hello. If …\nBuild a server certificate verifier, allowing control over …\nCreate a builder for the <code>webpki</code> server certificate …\nCreate a builder for a client configuration with the …\nCreate a builder for a client configuration with no …\nCreate a builder for a client configuration with the …\nCreate a builder for the <code>webpki</code> server certificate …\nCreate a builder for a client configuration with a …\nHow many bytes you may send.  Writes will become short …\nCaching for compressed certificates.\nHow to compress the client’s certificate chain.\nHow to decompress the server’s certificate chain.\nHow to decide what client auth certificate/keys to use.\nReturn the crypto provider used to construct this client …\nDangerous configuration that should be audited and used …\nAccess configuration options whose use is dangerous and …\nExtract secrets, so they can be used when configuring …\nExtract secrets, so they can be used when configuring …\nExtract secrets and a <code>KernelConnection</code> object.\nCreate an in-memory session store resumption with up to …\nDisable all use of session resumption.\nReturns an <code>io::Write</code> implementer you can write bytes to to …\nReturn the connection’s Encrypted Client Hello (ECH) …\nWhether to send data on the first flight (“early data”…\nAllows traffic secrets to be extracted after the handshake,\nWhether to send the Server Name Indication (SNI) extension …\nEnforce the CRL nextUpdate field (i.e. expiration)\nReturn true if the connection was made with a <code>ClientConfig</code> …\nReturn true if connections made with this <code>ClientConfig</code> will\nReturns true if the ECH mode will use a FIPS approved HPKE …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn true if any certificates at all are available.\nReturns true if the resolver is ready to present an …\nCreate a new <code>Resumption</code> that stores data for the given …\nRemember a TLS1.3 ticket that might be retrieved later …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns True if the server signalled it will process early …\nHow to output key material for debugging.  The default …\nThis should return the value most recently passed to …\nThe maximum size of plaintext input to be emitted in a …\nMake a new ClientConnection.  <code>config</code> controls how we …\nMake a new ClientConnection. <code>config</code> controls how we behave …\nMake a new ClientSessionMemoryCache.  <code>size</code> is the maximum …\nConstruct an EchConfig by selecting a ECH config from the …\nConstruct a GREASE ECH configuration.\nCreate a new <code>AlwaysResolvesClientRawPublicKeys</code> instance.\nMake a new ClientConnection with custom ALPN protocols.\nMake a new UnbufferedClientConnection with custom ALPN …\nOnly check the end entity certificate revocation status …\nReturn true if the client only supports raw public keys.\nReturn true if the client only supports raw public keys.\nRemove and forget any saved TLS1.2 session for <code>server_name</code>.\nIf set to <code>true</code>, requires the server to support the extended\nResolve a client certificate chain/private key to use as …\nHow and when the client can resume a previous session.\nRemember what <code>NamedGroup</code> the given server chose.\nRemember a TLS1.2 session.\nUse a custom <code>ClientSessionStore</code> implementation to store …\nReturn a TLS1.3 ticket previously provided to …\nProvides the current system time\nConfigure whether TLS 1.2 sessions may be resumed, and by …\nGet the most recently saved TLS1.2 session for <code>server_name</code> …\nReturns the number of TLS1.3 tickets that have been …\nReturns the number of TLS1.3 tickets that have been …\nWill verify the certificate is valid in the following ways:\nVerify that the end-entity certificate <code>end_entity</code> is a …\nVerify that the <code>end_entity</code> has an alternative name …\nVerify the revocation state of presented client …\nAccessor for dangerous configuration options.\nAccessor for dangerous configuration options.\nZero-sized marker type representing verification of a …\nZero-sized marker type representing verification of a …\nSomething that can verify a server certificate chain, and …\nMake a <code>HandshakeSignatureValid</code>\nMake a <code>ServerCertVerified</code>\nThe underlying ClientConfigBuilder\nThe underlying ClientConfig\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns whether this verifier requires raw public keys as …\nReturns whether this verifier requires raw public keys as …\nReturn the <code>DistinguishedName</code>s of certificate authorities …\nReturn the <code>DistinguishedName</code>s of certificate authorities …\nOverrides the default <code>ServerCertVerifier</code> with something …\nReturn the list of SignatureSchemes that this verifier …\nVerify the end-entity certificate <code>end_entity</code> is valid for …\nVerify a signature allegedly by the given server …\nVerify a signature allegedly by the given server …\nSet a custom certificate verifier.\nThe compression may be amortized over many connections.\nAn available certificate compression algorithm.\nAn available certificate decompression algorithm.\nAn LRU cache for compressions.\nInnards of an enabled CompressionCache.\nA content-less error for when <code>CertCompressor::compress</code> …\nA hint for how many resources to dedicate to a compression.\nA content-less error for when <code>CertDecompressor::decompress</code> …\nNo caching happens, and compression happens each time using\nCompressions are stored in an LRU cache.\nThis compression is happening interactively during a …\nWhich algorithm this decompressor handles.\nWhich algorithm this compressor handles.\nCompress <code>input</code>, returning the result.\nDecompress <code>input</code>, writing the result to <code>output</code>.\nReturns the supported <code>CertCompressor</code> implementations …\nReturns the supported <code>CertDecompressor</code> implementations …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMake a <code>CompressionCache</code> that stores up to <code>size</code> compressed …\nAn in-progress key exchange originating from a …\nCommon state for cipher suites (both for TLS 1.2 and TLS …\nThe result from <code>SupportedKxGroup::start_and_complete()</code>.\nControls core cryptography used by rustls.\nDiffie-Hellman Key exchange (with only known parameters as …\nKey exchange performed via elliptic curve Diffie-Hellman.\nRandom material generation failed.\nDescribes supported key exchange mechanisms.\nA mechanism for loading private <code>SigningKey</code>s from …\nA source of cryptographically secure randomness.\nThe result from <code>ActiveKeyExchange::complete</code> or …\nA supported key exchange group.\nDescribes which <code>webpki</code> signature verification algorithms …\nA list of all supported signature verification algorithms.\nTLS message encryption/decryption interfaces.\nList of supported ciphersuites, in preference order – …\nCompletes the key exchange, given the peer’s public key.\nCompletes the key exchange for the given TLS version, …\nCompletes the classical component of the key exchange, …\nNumber of TCP-TLS messages that can be safely encrypted …\nFFDHE group the <code>SupportedKxGroup</code> operates in.\nFFDHE group the <code>ActiveKeyExchange</code> is operating in.\nFill the given buffer with random bytes.\nReturn <code>true</code> if this is backed by a FIPS-approved …\nReturn <code>true</code> if this is backed by a FIPS-approved …\nReturn <code>true</code> if this is backed by a FIPS-approved …\nReturn <code>true</code> if this is backed by a FIPS-approved …\nReturns <code>true</code> if this <code>CryptoProvider</code> is operating in FIPS …\nReturn <code>true</code> if all cryptography is FIPS-approved.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the default <code>CryptoProvider</code> for this process.\nReturn the group being used.\nWhich group was used.\nHashing interfaces.\nWhich hash function the suite uses.\nHMAC interfaces.\nHybrid public key encryption (RFC 9180).\nFor hybrid key exchanges, returns the <code>NamedGroup</code> and key …\nSets this <code>CryptoProvider</code> as the default for this process.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nProvider for loading private <code>SigningKey</code>s from <code>PrivateKeyDer</code>…\nList of supported key exchange groups, in preference order …\nDecode and validate a private signing key from <code>key_der</code>.\nA mapping from TLS <code>SignatureScheme</code>s to matching webpki …\nNamed group the SupportedKxGroup operates in.\nReturn the public key being used.\nOur key share (sometimes a public key).\n<em>ring</em> based CryptoProvider.\nThe computed shared secret.\nReturns the shared secret as a slice of bytes.\nSource of cryptographically secure random numbers.\nList of signature verification algorithms for use with …\nStart a key exchange.\nStart and complete a key exchange, in one operation.\nThe TLS enumeration naming this cipher suite.\nReturn all the <code>scheme</code> items in <code>mapping</code>, maintaining order.\nCryptography specific to TLS1.2.\nCryptography specific to TLS1.3.\nReturn <code>true</code> if this should be offered/selected with the …\nVerify a message signature using the <code>cert</code> public key and …\nVerify a message signature using the <code>cert</code> public key and …\nVerify a message signature using a raw public key and the …\nA key for an AEAD algorithm.\nA TLS frame, named TLSPlaintext in the standard.\nA TLS frame, named <code>TLSPlaintext</code> in the standard.\nA write or read IV.\nHow a TLS1.2 <code>key_block</code> is partitioned.\nObjects with this trait can decrypt TLS messages.\nObjects with this trait can encrypt TLS messages.\nA collection of chunks (byte slices) and cursors to single …\nSize of TLS nonces (incorrectly termed “IV” in …\nA nonce.  This is unique for all messages on a connection.\nA collection of borrowed plaintext slices.\nA TLS frame, named <code>TLSPlaintext</code> in the standard.\nA TLS frame, named <code>TLSPlaintext</code> in the standard.\nA decrypted TLS frame\nA single byte slice. Contrary to <code>Multiple</code>, this uses a …\nFactory trait for building <code>MessageEncrypter</code> and …\nFactory trait for building <code>MessageEncrypter</code> and …\nAn error indicating that the AEAD algorithm does not …\nCreate a new <code>Iv</code> from a byte slice, of precisely <code>NONCE_LEN</code> …\nAppend all bytes to a vector\nDecrypt the given TLS message <code>msg</code>, using the sequence …\nBuild a <code>MessageDecrypter</code> for the given key/iv.\nBuild a <code>MessageDecrypter</code> for the given key/iv.\nHow long keys are.\nEncrypt the given TLS message <code>msg</code>, using the sequence …\nReturn the length of the ciphertext that results from …\nBuild a <code>MessageEncrypter</code> for the given key/iv.\nBuild a <code>MessageEncrypter</code> for the given key/iv and extra …\nThis is a non-standard extension which extends the key …\nConvert the key material from <code>key</code>/<code>iv</code>, into a …\nConvert the key material from <code>key</code>/<code>iv</code>, into a …\nReturn <code>true</code> if this is backed by a FIPS-approved …\nReturn <code>true</code> if this is backed by a FIPS-approved …\nHow long the fixed part of the ‘IV’ is.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nForce conversion into a plaintext message.\nForce conversion into a plaintext message.\nForce conversion into a plaintext message.\nFor TLS1.3 (only), checks the length msg.payload is valid …\nReturns true if the payload is empty\nReturn a <code>KeyBlockShape</code> that defines how large the <code>key_block</code>…\nThe length of key in bytes required by <code>encrypter()</code> and …\nReturns the cumulative length of all chunks\nReturns a TLS1.2 <code>additional_data</code> encoding.\nReturns a TLS1.3 <code>additional_data</code> encoding.\nConstruct a new <code>InboundOpaqueMessage</code> from constituent …\nCombine an <code>Iv</code> and sequence number to produce a unique …\nCreate a payload from a slice of byte slices. If …\nConstruct a new <code>OpaqueMessage</code> from constituent fields.\nCreate a new <code>Iv</code> from a byte array, of precisely <code>NONCE_LEN</code> …\nCreate a payload with a single empty slice\nConstruct by decoding from a <code>Reader</code>.\nSplit self in two, around an index Works similarly to …\nFlatten the slice of byte slices to an owned vector of …\nHow to incrementally compute a hash.\nDescribes a single cryptographic hash function.\nThe <code>HashAlgorithm</code> TLS protocol enum.  Values in this enum …\nMaximum supported hash output size: supports up to SHA512.\nA hash output, stored as a value.\nWhich hash function this is, eg, <code>HashAlgorithm::SHA256</code>.\nTerminate and finish the computation, returning the …\nReturn <code>true</code> if this is backed by a FIPS-approved …\nFork the computation, producing another context that has …\nFinish the computation, returning the resulting output.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn the output of this hash function with input <code>data</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nBuild a <code>hash::Output</code> from a slice of no more than …\nThe length in bytes of this hash function’s output.\nStart an incremental hash computation.\nAdd <code>data</code> to computation.\nA concrete HMAC implementation, for a single cryptographic …\nA HMAC key that is ready for use.\nMaximum supported HMAC tag size: supports up to SHA512.\nA HMAC tag, stored as a value.\nReturn <code>true</code> if this is backed by a FIPS-approved …\nReturns the argument unchanged.\nGive the length of the underlying hash function.  In …\nCalls <code>U::from(self)</code>.\nBuild a tag by copying a byte slice.\nCalculates a tag over <code>data</code> – a slice of byte slices.\nCalculates a tag over the concatenation of <code>first</code>, the …\nReturns the length of the tag returned by a computation …\nPrepare to use <code>key</code> as a HMAC key.\nAn encapsulated secret returned from setting up a sender …\nAn HPKE instance that can be used for base-mode …\nAn HPKE key pair, made of a matching public and private …\nAn HPKE opener context.\nAn HPKE private key.\nAn HPKE public key.\nAn HPKE sealer context.\nAn HPKE suite, specifying a key encapsulation mechanism …\nReturn whether the HPKE instance is FIPS compatible.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate a new public key and private key pair compatible …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe choice of HPKE key encapsulation mechanism.\nOpen the provided <code>ciphertext</code> using the encapsulated secret …\nOpen the provided <code>ciphertext</code> with additional data <code>aad</code>, …\nA HPKE private key.\nA HPKE public key.\nSeal the provided <code>plaintext</code> to the recipient public key …\nSeal the provided <code>plaintext</code> with additional data <code>aad</code>, …\nReturn the private key bytes.\nSet up an opener context for the secret key <code>secret_key</code> …\nSet up a sealer context for the receiver public key <code>pub_key</code>…\nReturn the HpkeSuite that this HPKE instance supports.\nThe choice of HPKE symmetric cipher suite.\nA list of all the cipher suites supported by the rustls …\nA list of all the key exchange groups supported by this …\nThe cipher suite configuration that an application should …\nA list of the default key exchange groups supported by …\nA concrete, safe ticket creation mechanism.\nAll defined cipher suites supported by <em>ring</em> appear in this …\nA <code>CryptoProvider</code> backed by the <em>ring</em> crate.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAll defined key exchange groups supported by <em>ring</em> appear …\nMake the recommended <code>Ticketer</code>.  This produces tickets with …\nUsing software keys for authentication.\nThe TLS1.3 ciphersuite TLS_AES_128_GCM_SHA256\nThe TLS1.3 ciphersuite TLS_AES_256_GCM_SHA384\nThe TLS1.3 ciphersuite TLS_CHACHA20_POLY1305_SHA256\nThe TLS1.2 ciphersuite …\nThe TLS1.2 ciphersuite …\nThe TLS1.2 ciphersuite …\nThe TLS1.2 ciphersuite …\nThe TLS1.2 ciphersuite …\nThe TLS1.2 ciphersuite …\nEphemeral ECDH on secp256r1 (aka NIST-P256)\nEphemeral ECDH on secp384r1 (aka NIST-P384)\nEphemeral ECDH on curve25519 (see RFC7748)\nParse <code>der</code> as any ECDSA key type, returning the first which …\nParse <code>der</code> as any EdDSA key type, returning the first which …\nParse <code>der</code> as any supported key encoding/type, returning …\nAn instantiation of the TLS1.2 PRF with a specific, …\nImplements <code>Prf</code> using a <code>hmac::Hmac</code>.\nReturn <code>true</code> if this is backed by a FIPS-approved …\nComputes <code>PRF(secret, label, seed)</code> using the secret from a …\nComputes <code>PRF(secret, label, seed)</code>, writing the result into …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA HKDF implementation oriented to the needs of TLS1.3.\nImplementation of <code>HKDF-Expand</code> with an implicitly stored …\nImplementation of <code>HkdfExpander</code> via <code>hmac::Key</code>.\nImplementation of <code>Hkdf</code> (and thence <code>HkdfExpander</code>) via …\nMaximum supported HMAC tag size: supports up to SHA512.\nOutput key material from HKDF, as a value type.\nAn error type used for <code>HkdfExpander::expand_slice</code> when the …\n<code>HKDF-Expand(PRK, info, L)</code> to construct any type from a …\n<code>HKDF-Expand(PRK, info, L=HashLen)</code> returned as a value.\n<code>HKDF-Expand(PRK, info, L)</code> into a slice.\nBuild a <code>HkdfExpander</code> using <code>okm</code> as the secret PRK.\n<code>HKDF-Extract(salt, shared_secret)</code> where <code>shared_secret</code> is …\n<code>HKDF-Extract(salt, secret)</code>\n<code>HKDF-Extract(salt, 0_HashLen)</code>\nReturn <code>true</code> if this is backed by a FIPS-approved …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn what <code>HashLen</code> is for this instance.\nSigns <code>message</code> using <code>key</code> viewed as a HMAC key.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nBuild a single OKM block by copying a byte slice.\nFFDHE2048 group defined in RFC 7919 Appendix A.1\nFFDHE3072 group defined in RFC 7919 Appendix A.2\nFFDHE4096 group defined in RFC 7919 Appendix A.3\nFFDHE6144 group defined in RFC 7919 Appendix A.4\nFFDHE8192 group defined in RFC 7919 Appendix A.5\nParameters of an FFDHE group, with Big-endian byte order\nReturns the argument unchanged.\nReturn the <code>FfdheGroup</code> corresponding to the provided …\nConstruct an <code>FfdheGroup</code> from the given <code>p</code> and <code>g</code>, trimming …\nCalls <code>U::from(self)</code>.\nReturn the <code>NamedGroup</code> for the <code>FfdheGroup</code> if it represents …\nA kernel connection.\nReturns the argument unchanged.\nHandle a <code>new_session_ticket</code> message from the peer.\nCalls <code>U::from(self)</code>.\nRetrieves the ciphersuite agreed with the peer.\nRetrieves the protocol version agreed with the peer.\nUpdate the traffic secret used for decrypting messages …\nUpdate the traffic secret used for encrypting messages …\nA wrapper around <code>std::sync::Mutex</code>.\nAn RAII implementation of a “scoped lock” of a mutex. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAcquires the mutex, blocking the current thread until it …\nMakes a <code>MappedMutexGuard</code> for a component of the borrowed …\nCreates a new mutex in an unlocked state ready for use.\nMakes a <code>MappedMutexGuard</code> for a component of the borrowed …\nThis section discusses vulnerabilities in other TLS …\nThis section discusses vulnerabilities and design errors …\nThis section collects together goal-oriented documentation.\nThis section documents rustls itself: what protocol …\nThis section provides rationale for the defaults in rustls.\nThis section provides guidance on using rustls with …\nHow a <code>Tls13CipherSuite</code> generates <code>PacketKey</code>s and …\nA client connection\nA QUIC client connection.\nA QUIC client or server connection.\nA shared interface for QUIC connections.\nKeys used to communicate in a single direction\nKeys for the handshake space\nA QUIC header protection key\nKey material for use in QUIC packet spaces\nComplete set of keys used to communicate with the peer\nKeys for 1-RTT data\nKeys to encrypt or decrypt the payload of a packet\nPacket protection keys for bidirectional 1-RTT …\nSecrets used to encrypt/decrypt traffic\nA server connection\nA QUIC server connection.\nProduces QUIC initial keys from a TLS 1.3 ciphersuite and …\nAuthentication tag from an AEAD seal operation.\nFirst stable RFC\nDraft versions 29, 30, 31 and 32\nAnti-ossification variant of V1\nQUIC protocol version\nThe length in bytes of keys for this Algorithm.\nEmit the TLS description code of a fatal alert, if one has …\nEmit the TLS description code of a fatal alert, if one has …\nNumber of QUIC messages that can be safely encrypted with …\nRemoves QUIC Header Protection.\nDecrypt a QUIC packet\nAdds QUIC Header Protection.\nEncrypt a QUIC packet\nDerives key material from the agreed connection secrets.\nWhether this algorithm is FIPS-approved.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nEncrypts or decrypts a packet’s headers\nProduce a <code>HeaderProtectionKey</code> encrypter/decrypter for this …\nConstruct keys for use with initial packets\nNumber of QUIC messages that can be safely decrypted with …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns True if the server signalled it will process early …\nProduce a set of initial keys given the connection ID, …\nEncrypts outgoing packets\nEncrypts outgoing packets\nMake a new QUIC ClientConnection.\nMake a new QUIC ServerConnection.\nMake a new QUIC ClientConnection with custom ALPN …\nDerive the next set of packet keys\nEncrypts or decrypts the payload of a packet\nProduce a <code>PacketKey</code> encrypter/decrypter for this suite.\nThe QUIC key generation algorithm used to derive keys.\nReturn the TLS-encoded transport parameters for the session…\nReturn the TLS-encoded transport parameters for the session…\nConsume unencrypted TLS handshake data.\nConsume unencrypted TLS handshake data.\nExplicitly discard early data, notifying the client\nDecrypts incoming packets\nDecrypts incoming packets\nExpected sample length for the key’s algorithm\nRetrieves the server name, if any, used to select the …\nThe TLS 1.3 ciphersuite used to derive keys.\nTag length for the underlying AEAD algorithm\nReturns the number of TLS1.3 tickets that have been …\nEmit unencrypted TLS handshake data.\nEmit unencrypted TLS handshake data.\nCompute the keys for encrypting/decrypting 0-RTT packets, …\nCompute the keys for encrypting/decrypting 0-RTT packets, …\nHeader and packet keys for the handshake space\nHeader and packet keys for 1-RTT data\nSecrets to derive updated keys from\nRepresents a <code>ClientHello</code> message received through the …\nRepresents a TLS alert resulting from handling the client…\nHandle a server-side connection before configuration is …\nAn exemplar <code>ResolvesServerCert</code> implementation that always …\nThe <code>CertificateType</code> enum sent in the cert_type extensions. …\nA builder for configuring a <code>webpki</code> client certificate …\nA struct representing the received Client Hello\nA provided CRL could not be parsed.\nTurns off client authentication.\nNo root trust anchors were provided.\nSomething which never stores sessions.\nWrapper around internal representation of a parsed …\nA trait for the ability to encrypt and decrypt tickets.\nAllows reading of early data in resumed TLS1.3 connections.\nHow to choose a certificate chain and signing key for use …\nSomething that resolves do different cert chains/keys based\nCommon configuration for a set of server sessions.\nThis represents a single TLS server connection.\nState associated with a server connection.\nAn implementer of <code>StoresServerSessions</code> that stores …\nA trait for the ability to store server session data.\nUnbuffered version of <code>ServerConnection</code>\nAn error that can occur when building a certificate …\nA config builder state where the caller must supply how to …\nA client certificate verifier that uses the <code>webpki</code> crate …\nCheck if a <code>ClientHello</code> message has been received.\nAdd a new <code>sign::CertifiedKey</code> to be used for the given SNI …\nAdd additional <code>DistinguishedName</code>s to the list of trust …\nAllow unauthenticated clients to connect.\nAllow unknown certificate revocation status when using …\nGet the ALPN protocol identifiers submitted by the client.\nProtocol names we support, most preferred first. If empty …\nBuild a client certificate verifier. The built verifier …\nCreate a builder for the <code>webpki</code> client certificate …\nCreate a builder for a server configuration with the …\nCreate a builder for a server configuration with no …\nCreate a builder for a server configuration with the …\nCreate a builder for the <code>webpki</code> client certificate …\nCreate a builder for a server configuration with a …\nWhether the store can cache another session. This is used …\nCaching for compressed certificates.\nHow to compress the server’s certificate chain.\nHow to decompress the clients’s certificate chain.\nHow to choose a server cert and key. This is usually set by\nGet the certificate_authorities extension sent by the …\nGet cipher suites.\nClear the list of trust anchor hint subjects.\nGet the client certificate types offered in the …\nGet the <code>ClientHello</code> for this connection.\nReturn the crypto provider used to construct this client …\nDangerous configuration that should be audited and used …\nExtract secrets, so they can be used when configuring …\nExtract secrets, so they can be used when configuring …\nExtract secrets and an <code>KernelConnection</code> object.\nDecrypt <code>cipher</code>, validating its authenticity protection and …\nReturn an empty Acceptor, ready to receive bytes from a …\nReturns an <code>io::Read</code> implementer you can read bytes from …\nAllows traffic secrets to be extracted after the handshake,\nReturns true if this implementation will encrypt/decrypt …\nEncrypt and authenticate <code>plain</code>, returning the resulting …\nEnforce the CRL nextUpdate field (i.e. expiration)\nReturn true if the connection was made with a <code>ServerConfig</code> …\nReturn <code>true</code> if connections made with this <code>ServerConfig</code> will\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nFind a value with the given <code>key</code>.  Return it, or None if it …\nIgnore the client’s ciphersuite order. Instead, choose …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert the <code>Accepted</code> into a <code>ServerConnection</code>.\nHow to output key material for debugging.  The default …\nReturns the lifetime in seconds of tickets produced now. …\nAmount of early data to accept for sessions created by …\nThe maximum size of plaintext input to be emitted in a …\nGet the <code>named_groups</code> extension sent by the client.\nMake a new ServerSessionMemoryCache.  <code>size</code> is the maximum …\nMake a new ServerConnection.  <code>config</code> controls how we …\nMake a new ServerConnection. <code>config</code> controls how we behave …\nCreate a new <code>AlwaysResolvesServerRawPublicKeys</code> instance.\nCreate a new and empty (i.e., knows no certificates) …\nCreate a new <code>WebPkiClientVerifier</code> that disables client …\nOnly check the end entity certificate revocation status …\nReturn true when the server only supports raw public keys.\nReturn true when the server only supports raw public keys.\nStore session secrets encoded in <code>value</code> against <code>key</code>, …\nRead TLS content from <code>rd</code>.\nApplication-controlled portion of the resumption ticket …\nExplicitly discard early data, notifying the client\nIf set to <code>true</code>, requires the client to support the extended\nChoose a certificate chain and matching key given …\nWhether the server should send “0.5RTT” data.  This …\nHow many TLS1.3 tickets to send immediately after a …\nGet the server certificate types offered in the …\nRetrieves the server name, if any, used to select the …\nGet the server name indicator.\nHow to store client sessions.\nSet the resumption data to embed in future resumption …\nGet the compatible signature schemes.\nGet the parsed certificate’s SubjectPublicKeyInfo (SPKI)\nFind a value with the given <code>key</code>.  Return it and delete it; …\nHow to produce tickets.\nProvides the current system time\nVerify the revocation state of presented client …\nSend the alert to the client.\nSend the alert to the client.\nZero-sized marker type representing verification of a …\nSomething that can verify a client certificate chain\nMake a <code>ClientCertVerified</code>\nReturn <code>true</code> to require a client certificate and <code>false</code> to …\nReturn <code>true</code> to require a client certificate and <code>false</code> to …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> to enable the server to request a client …\nReturns <code>true</code> to enable the server to request a client …\nReturns whether this verifier requires raw public keys as …\nReturns whether this verifier requires raw public keys as …\nReturns the <code>DistinguishedName</code> subjects that the server …\nReturn the list of SignatureSchemes that this verifier …\nVerify the end-entity certificate <code>end_entity</code> is valid, …\nVerify a signature allegedly by the given client …\nVerify a signature allegedly by the given client …\nA packaged-together certificate chain, matching <code>SigningKey</code> …\nA thing that can sign a message.\nAn abstract signing key.\nServer certificate resolver which always resolves to the …\nWhat kind of key we have.\nThe certificate chain or raw public key.\nChoose a <code>SignatureScheme</code> from those offered.\nThe end-entity certificate.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new <code>CertifiedKey</code> from a certificate chain and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe certified key.\nVerify the consistency of this <code>CertifiedKey</code>’s public and …\nMake a new CertifiedKey, with the given chain and key.\nAn optional OCSP response from the certificate issuer, …\nGet the RFC 5280-compliant SubjectPublicKeyInfo (SPKI) of …\nGet the RFC 5280-compliant SubjectPublicKeyInfo (SPKI) of …\nConvert a public key and algorithm identifier into …\nReveals which scheme will be used when you call …\nSigns <code>message</code> using the selected scheme.\nA ticketer that has a ‘current’ sub-ticketer and a …\nA ticketer that has a ‘current’ sub-ticketer and a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new <code>TicketRotator</code>, which rotates through …\nCreates a new <code>TicketSwitcher</code>, which rotates through …\nDefault <code>TimeProvider</code> implementation that uses <code>std</code>\nAn object that provides the current time.\nReturns the current wall time.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe handshake record has already been encoded; do not call …\nA decrypted application-data record\nMore TLS data is needed to continue with the handshake\nConnection has been cleanly closed by both us and the peer.\nThe state of the <code>UnbufferedConnectionCommon</code> object\nErrors that may arise when encoding a handshake record\nA handshake record must be encoded\nA Handshake record is ready for encoding\nErrors that may arise when encrypting application data\nEncrypter has been exhausted\nProvided buffer was too small\nProvided buffer was too small\nProvided buffer was too small\nConnection has been cleanly closed by the peer.\nEarly application-data is available.\nOne, or more, early (RTT-0) data records are available\nApplication data is available\nOne, or more, application data records are available\nPreviously encoded TLS data must be transmitted\nPreviously encoded handshake records need to be transmitted\nInterface shared by unbuffered client and server …\nThe current status of the <code>UnbufferedConnection*</code>\nAllows encrypting app-data\nThe handshake process has been completed.\nExtract secrets, so they can be used when configuring …\nNumber of additional bytes to discard\nNumber of bytes to discard\nSignals that the previously encoded TLS data has been …\nEncodes a handshake record into the <code>outgoing_tls</code> buffer\nEncrypts <code>application_data</code> into the <code>outgoing_tls</code> buffer\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns an adapter that allows encrypting application data\nreturns an adapter that allows encrypting early (RTT-0) …\nDecrypts and returns the next available app-data record\ndecrypts and returns the next available app-data record\nThe payload of the app-data record\nReturns the payload size of the next app-data record …\nreturns the payload size of the next app-data record …\nProcesses the TLS records in <code>incoming_tls</code> buffer until a …\nProcesses the TLS records in <code>incoming_tls</code> buffer until a …\nEncrypts a close_notify warning alert in <code>outgoing_tls</code>\nArranges for a TLS1.3 <code>key_update</code> to be sent.\nbuffer must be at least this size\nThe current state of the handshake process\nTLS1.2\nTLS1.3")
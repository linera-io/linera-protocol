searchState.loadedDescShard("ark_ec", 0, "<code>ark-ec</code> defines traits and algorithms for working with …\nThe affine representation of this element.\nThe canonical representation of an elliptic curve group …\nThe field over which this curve is defined.\nThe finite field over which this curve is defined.\nWrapper trait representing a cycle of elliptic curves (E1, …\nAn opaque representation of an elliptic curve group …\nType representing an element of the full elliptic curve …\nThe projective representation of points on this curve.\nA cycle of curves where both curves are pairing-friendly.\nRepresents (elements of) a group of prime order <code>r</code>.\nThe scalar field <code>F_r</code>, where <code>r</code> is the order of this group.\nThe additive identity of the field.\nPerforms cofactor clearing. The default method is simply …\nDoubles <code>self</code>.\nDoubles <code>self</code> in place.\nReturns a group element if the set of bytes forms a valid …\nReturns a fixed generator of this group.\nReturns a fixed generator of unknown exponent.\nProvides a <code>HashToCurve</code> trait and implementations of this …\nConverts <code>self</code> into the affine representation.\nConverts self into the projective representation.\nIs <code>self</code> the point at infinity?\nPerforms scalar multiplication of this element.\nPerforms scalar multiplication of this element with mixed …\nComputes <code>other * self</code>, where <code>other</code> is a <em>big-endian</em> bit …\nMultiplies this element by the cofactor.\nMultiplies this element by the inverse of the cofactor in …\nMultiplies this element by the cofactor and output the …\nNegates <code>self</code> in place.\nNormalizes a slice of group elements into affine.\nReturns the x coordinate of this affine point.\nReturns the x and y coordinates of this affine point.\nReturns the y coordinate of this affine point.\nReturns the point at infinity.\nTrait for hashing arbitrary data to a group element on an …\nThis is an error that could occur during the hash to curve …\nError with map to curve\nCurve choice is unsupported by the given HashToCurve …\nReturns the argument unchanged.\nProduce a hash of the message, which also depends on the …\nCalls <code>U::from(self)</code>.\nCreate a new hash to curve instance, with a given domain.\n[[1]] https://datatracker.ietf.org/doc/html/rfc9380/\nThis must be equal to …\nTrait defining the necessary parameters for the Elligator2 …\nRepresents the Elligator2 hash-to-curve map defined by <code>P</code>.\nThis must be equal to 1/(MontCurveConfig::COEFF_B)^2;\nAn element of the base field that is not a square root see …\nChecks if <code>P</code> represents a valid Elligator2 map. Panics …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nMap an arbitrary base field element <code>element</code> to a curve …\nTrait defining the necessary parameters for the SWU …\nRepresents the SWU hash-to-curve map defined by <code>P</code>.\nAn element of the base field that is not a square root see …\nChecks if <code>P</code> represents a valid map.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nMap an arbitrary base field element to a curve point. …\n<code>IsogenyMap</code> defines an isogeny between curves of form …\nTrait defining the necessary parameters for the WB …\nChecks if <code>P</code> represents a valid map.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMap random field point to a random curve point inspired …\nTrait for mapping a random field element to a random curve …\nHelper struct that can be used to construct elements on …\nChecks whether supplied parameters represent a valid map.\nReturns the argument unchanged.\nProduce a hash of the message, using the hash to field and …\nCalls <code>U::from(self)</code>.\nMap an arbitrary field element to a corresponding curve …\nBase field that the curve is defined over.\nThe cofactor of this curve, represented as a sequence of …\nElliptic curves can be represented via different “models…\nFinite prime field corresponding to an appropriate …\nWhat kind of twist is this?\nA particular BLS12 group can have G2 being either a …\nParameterizes the BLS12 family.\nIs <code>Self::X</code> negative?\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<code>X / Z</code> projection of the affine <code>X</code>\n<code>Y / Z</code> projection of the affine <code>Y</code>\nProjective multiplicative inverse. Will be <code>0</code> only at …\nStores the coefficients of the line evaluations as …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>X / Z</code> projection of the affine <code>X</code>\n<code>Y / Z</code> projection of the affine <code>Y</code>\nProjective multiplicative inverse. Will be <code>0</code> only at …\nThe absolute value of <code>6X + 2</code>.\nThe absolute value of the BN curve parameter <code>X</code> (as in …\nWhether or not <code>X</code> is negative.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<code>X / Z</code> projection of the affine <code>X</code>\n<code>Y / Z</code> projection of the affine <code>Y</code>\nProjective multiplicative inverse. Will be <code>0</code> only at …\nStores the coefficients of the line evaluations as …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>X / Z</code> projection of the affine <code>X</code>\n<code>Y / Z</code> projection of the affine <code>Y</code>\nProjective multiplicative inverse. Will be <code>0</code> only at …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<code>X / Z</code> projection of the affine <code>X</code>\n<code>Y / Z</code> projection of the affine <code>Y</code>\nProjective multiplicative inverse. Will be <code>0</code> only at …\nStores the coefficients of the line evaluations as …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>X / Z</code> projection of the affine <code>X</code>\n<code>Y / Z</code> projection of the affine <code>Y</code>\nProjective multiplicative inverse. Will be <code>0</code> only at …\nCoefficient <code>c0</code> in the representation of the field element …\nCoefficient <code>c1</code> in the representation of the field element …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<code>X / Z</code> projection of the affine <code>X</code>\n<code>Y / Z</code> projection of the affine <code>Y</code>\nProjective multiplicative inverse. Will be <code>0</code> only at …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>X / Z</code> projection of the affine <code>X</code>\n<code>Y / Z</code> projection of the affine <code>Y</code>\nProjective multiplicative inverse. Will be <code>0</code> only at …\nCoefficient <code>c0</code> in the representation of the field element …\nCoefficient <code>c1</code> in the representation of the field element …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<code>X / Z</code> projection of the affine <code>X</code>\n<code>Y / Z</code> projection of the affine <code>Y</code>\nProjective multiplicative inverse. Will be <code>0</code> only at …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>X / Z</code> projection of the affine <code>X</code>\n<code>Y / Z</code> projection of the affine <code>Y</code>\nProjective multiplicative inverse. Will be <code>0</code> only at …\nAffine coordinates for a point on an elliptic curve in …\nCoefficient <code>a</code> of the curve equation.\nCoefficient <code>b</code> of the curve equation.\nGenerator of the prime-order subgroup.\nRepresents the point at infinity by setting the setting …\nJacobian coordinates for a point on an elliptic curve in …\nConstants and convenience functions that collectively …\nFlags to be encoded into the serialization. The default …\nRepresents a point with negative y-coordinate by setting …\nRepresents a point with positive y-coordinate by setting …\nUsing …\nHelper method for computing <code>elem + Self::COEFF_B</code>.\nPerforms cofactor clearing. The default method is simply …\nPerforms cofactor clearing. The default method is simply …\nIf <code>validate</code> is <code>Yes</code>, calls <code>check()</code> to make sure the element …\nSets <code>self = 2 * self</code>. Note that Jacobian formulae are …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAttempts to construct an affine point given an …\nReturns the two possible y-coordinates corresponding to …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if the provided curve point is in the prime-order …\nChecks if <code>self</code> is in the subgroup having order that …\nChecks if <code>self</code> is a valid point on the curve.\nChecks whether <code>self.z.is_zero()</code>.\nDefault implementation for multi scalar multiplication\nDefault implementation of group multiplication for affine …\nHelper method for computing <code>elem * Self::COEFF_A</code>.\nMultiplies this element by the cofactor and output the …\nDefault implementation of group multiplication for …\nIf <code>self.is_zero()</code>, returns <code>self</code> (<code>== Self::zero()</code>). Else, …\nConstructs a group element from x and y coordinates. …\nConstructs a new group element in a way while enforcing …\nConstructs a group element from x and y coordinates.\nConstructs a new group element without checking whether …\nNormalizes a slice of projective elements so that …\nIf uncompressed, serializes both x and y coordinates as …\n<code>X / Z</code> projection of the affine <code>X</code>\n<code>Y / Z</code> projection of the affine <code>Y</code>\nProjective multiplicative inverse. Will be <code>0</code> only at …\nReturns the point at infinity, which always has Z = 0.\nAffine coordinates for a point on a twisted Edwards curve, …\nCoefficient <code>a</code> of the curve equation.\nCoefficient <code>a</code> of the curve equation.\nCoefficient <code>b</code> of the curve equation.\nCoefficient <code>d</code> of the curve equation.\nGenerator of the prime-order subgroup.\nConstants and convenience functions that collectively …\nModel parameters for the Montgomery curve that is …\n<code>Projective</code> implements Extended Twisted Edwards Coordinates …\nConstants and convenience functions that collectively …\nModel parameters for the Twisted Edwards curve that is …\nFlags to be encoded into the serialization. The default …\nPerforms cofactor clearing. The default method is simply …\nPerforms cofactor clearing. The default method is simply …\nIf <code>validate</code> is <code>Yes</code>, calls <code>check()</code> to make sure the element …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAttempts to construct an affine point given an …\nAttempts to recover the x-coordinate given an …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks that the current point is in the prime order …\nChecks if <code>self</code> is in the subgroup having order equaling …\nChecks that the current point is on the elliptic curve.\nIs this point the identity?\nDefault implementation for multi scalar multiplication\nDefault implementation of group multiplication for affine …\nHelper method for computing <code>elem * Self::COEFF_A</code>.\nMultiplies this element by the cofactor and output the …\nDefault implementation of group multiplication for …\nConstruct a new group element in a way while enforcing …\nConstruct a new group element in a way while enforcing …\nConstruct a new group element without checking whether the …\nConstruct a new group element without checking whether the …\nIf uncompressed, serializes both x and y coordinates. If …\nX coordinate of the point represented as a field element\nY coordinate of the point represented as a field element\nConstruct the identity of the group\nThis is the base field of the G1 group and base prime …\nAn element in G1.\nA G1 element that has been preprocessed for use in a …\nAn element of G2.\nThe affine representation of an element in G2.\nA G2 element that has been preprocessed for use in a …\nRepresents the output of the Miller loop of the pairing.\nCollection of types (mainly fields and curves) that …\nRepresents the target group of a pairing. This struct is a …\nThis is the scalar field of the G1/G2 groups.\nThe extension field that hosts the target group of the …\nPerforms final exponentiation of the result of a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nComputes the Miller loop over <code>a</code> and <code>b</code>.\nComputes the product of Miller loops for some number of …\nComputes a “product” of pairings.\nPerforms multiple pairing operations\nPreprocesses a G1 element for use in a pairing.\nPreprocesses a G2 element for use in a pairing.\nThe identity element, or “zero”, of the group is the …\nPreprocessing used internally for batch scalar …\nCompute the vector v[0].G, v[1].G, …, v[n-1].G, given:\nCompute the vector v[0].G, v[1].G, …, v[n-1].G, given:\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nStandard double-and-add method for multiplication by a …\nStandard double-and-add method for multiplication by a …\nConstants that are used to calculate <code>phi(G) := lambda*G</code>. …\nThe GLV parameters for computing the endomorphism and …\nThe eigenvalue corresponding to the endomorphism.\nA 4-element vector representing a 2x2 matrix of …\nDecomposes a scalar s into k1, k2, s.t. s = k1 + lambda k2,\nPerforms multi-scalar multiplication.\nOptimized implementation of multi-scalar multiplication.\nStreaming multi-scalar multiplication algorithm with …\nComputes an inner product between the <code>PrimeField</code> elements …\nA space-efficient implementation of Pippenger’s …\nStruct for the chunked Pippenger algorithm.\nHash map struct for Pippenger algorithm.\nAdd a new (base, scalar) pair into the instance.\nAdd a new (base, scalar) pair into the hash map.\nOutput the final Pippenger algorithm result.\nUpdate the final result with (base, scalar) pairs in the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInitialize a chunked Pippenger instance with default …\nProduce a new hash map with the maximum msm buffer size.\nInitialize a chunked Pippenger instance with the given …\nA helper type that contains all the context required for …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nComputes scalar multiplication of a group element <code>g</code> by …\nComputes scalar multiplication of a group element by <code>scalar</code>…\nConstructs a new context for a window of size <code>window_size</code>.")
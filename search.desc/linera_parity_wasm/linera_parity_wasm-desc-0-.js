searchState.loadedDescShard("linera_parity_wasm", 0, "WebAssembly format library\nVarious builders to generate/alter wasm components\nElements of the WebAssembly binary format.\nLocation of the internal module function\nData segment builder\nExport entry builder\nInternal mapping builder for export entry\nFunction body (code) builder\nFunction definition builder\nFunction definition (extended structure to specify …\nGlobal builder\nIdentity chain element\nImport builder\nMemory and static regions builder\nModule builder\nSignature builder\nMultiple signatures builder\nTable builder\nTable definition\nTable elements entry definition\nType (signature) reference builder (for …\nBind signature list\nStart code (body) builder\nLocation (index in the ‘code’ section) of the body\nFinish current builder\nFinish current builder\nFinalize builder spawning element\nFinish current builder spawning resulting struct\nFinalize current builder spawning resulting struct in the …\nFinish current builder, spawning resulting struct\nFinalize export entry builder spawning the resulting struct\nFinalize current builder spawning resulting struct\nFinalize current builder spawning the resulting struct\nFinalize current builder, spawning resulting struct\nBuild module (final step)\nFinalize current builder spawning resulting struct\nFinish current builder returning intermediate <code>Signature</code> …\nBody (code) of the function\nData entry builder\nElement segments, if any\nNew builder for export entry\nExport entry builder\nStart new external mapping builder\nSet the field name of the export entry\nSet/override field name\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nStart builder to extend existing module\nMap to function by index\nNew builder of function (signature &amp; body)\nAdd new function using dedicated builder\nDefine functions section\nNew builder for export entry\nMap to global\nGlboal entry builder\nNew builder for import entry\nImport entry builder\nSet initialization expression instruction for this global (…\nStart the internal builder for this export entry\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs this function is start function\nSet that this function is main entry point\nMaximum length, if any\nMap to memory\nAdd new linear memory using dedicated builder\nMinimum length\nStart new module builder\nSet/override module name\nSet mutabilty to true\nNew signature builder\nNew empty functions section builder\nNew function builder\nNew data segment builder\nNew export builder\nNew global builder\nNew import builder\nNew memory builder\nNew empty module builder\nNew table builder\nSet offset initialization instruction. <code>End</code> instruction …\nOffset initialization expression\nStart build new argument\nStart build multiple arguments\nSet/override both module name and field name\nPush export entry to module.\nPush stand-alone function definition, creating sections, …\nPush global.\nPush import entry to module. Note that this does not …\nPush linear memory region\nPush one function signature, returning it’s calling …\nPush signatures in the module, returning corresponding …\nPush table\nStart building new result\nStart building multiple results\nNew signature builder\nStart building new signature with dedicated builder\nStart signature builder of the function\nSignature description\nLocation (index in ‘functions’ section) of the …\nNew builder of signature list\nMap to table\nAdd new table using dedicated builder\nStart building new signature with <code>TypeRefBuilder</code>\nSet/override of type reference\nSet the bytes value of the segment\nStart value type builder\nValues of initialization\nSet body (code) for this function\nNew builder with callback function specified\nNew builder chained with specified callback\nNew builder chained with specified callback\nNew body (code) builder given the chain callback\nNew function builder with chained callback\nNew data segment builder inside the chain context\nNew export entry builder in the specified chained context\nNew export entry internal mapping for the chained context\nNew global builder with callback (in chained context)\nNew import builder with callback (in chained context)\nNew memory builder with callback (in chained context)\nNew module builder with bound callback\nNew table builder with callback in chained context\nPush new static region with initialized offset expression …\nAdd data segment to the builder\nGenerate initialization expression and element values on …\nWith inserted export entry\nSet/override external mapping for this import\nSet/override entirely with FuncBody struct\nWith global variable\nWith inserted import entry\nSet code of the function\nSpecify the internal module mapping for this entry\nExtend function local list with new entries\nSet/override maximum size\nSet/override maximum length\nSet/override minimum size\nSet/override minimum length\nBuilder from raw module\nAdd argument to signature builder\nAdd multiple arguments to signature builder\nAdd result to signature builder\nAdd multiple results to signature builder\nAdd additional section\nFill module with sections from iterator\nPush new signature into the builder output\nOverride current signature entirely with new one from …\nBinds to the type section, creates additional types when …\nWith table\nSet/override resulting global type\nA reference to a function with any signature.\nBlock type which is basically <code>ValueType</code> + NoResult (to …\nFunction bodies section.\nSection with function bodies of the module.\nList for reading sequence of elements typed <code>T</code>, given they …\nHelper struct to write series of <code>T</code> preceded by the length …\nHelper struct to write payload which is preceded by it’s …\nCustom section (<code>id=0</code>).\nCustom section.\nData definition section.\nNumber of passive data entries in the data section\nData entries definitions.\nData segment definition.\nDeserialization from serial i/o.\nDuplicated name subsections.\nDuplicated sections.\nElements section.\nElement entries section.\nEntry in the element section.\nDeserialization/serialization error\nSerialization error produced by deserialization routine.\nSerialization error produced by serialization routine.\nExport definitions.\nExport entry.\nList of exports definition.\nExternal to local binding.\n32-bit float\n64-bit float\nFunction signature (type reference)\nFunction body definition.\nFunction reference.\nBinds to a function whose type is associated with the …\nCount functions\nFunction signatures section.\nFunction type.\nFunction index.\nThe names of the functions in this module.\nSection with function signatures definition.\nFunction signature type.\nGlobal reference.\nDescribes local global entry to be imported as.\nCount globals\nGlobal entries section.\nGlobal entry in the module.\nGlobal index.\nGlobals definition section.\nGlobal definition struct\nOther allocated error.\n32-bit signed integer\n64-bit signed integer\nImport section.\nType of the import entry to count\nImport entry.\nSection of the imports definition.\nNumber of function body entries and signatures does not …\nInconsistence between declared and actual length.\nInconsistent metadata.\nA map from non-contiguous <code>u32</code> keys to values of type <code>T</code>, …\nInitialization expression.\nInstruction.\nList of instructions (usually inside a block section).\nInternal reference of the exported entry.\nInvalid value used for flags in limits type.\nInvalid magic.\nInvalid memory reference (should be 0).\nInvalid section id.\nOnly flags 0, 1, and 2 are accepted on segments.\nInvalid VarInt32 value.\nInvalid VarInt64 value.\nInvalid varint7 (should be in -64..63 range).\nInvalid VarUint1 value.\nInvalid VarUint32 value.\nInvalid VarUint64 value.\nLocal definition inside the function body.\nThe names of the local variables in this module’s …\nMemory reference.\nDescribes local memory definition to be imported as.\nCount memories\nMemory definition section.\nLinear memory index.\nLinear memory index.\nLinear memory index.\nSection with table definition (currently only one entry is …\nMemory entry.\nWebAssembly module\nThe name of this module.\nName section.\nA map from indices to names.\nDebug name information.\nNo specified block type\nNon-utf8 string.\nOther static error.\nRelocation section.\nRelocation information.\nRelocation entry.\nMemory and table limits.\nSection in the WebAssembly module.\nSections are out of order.\nSerialization to serial i/o. Takes self by value to …\nEntry reference of the module.\nTable reference.\nDescribes local table definition to be imported as.\nCount tables\nTable definition section.\nTable element type.\nFunction table index.\nFunction table index.\nSection with table definition (currently only one is …\nTable entry\nSum of counts of locals is greater than 2^32.\nType definition in types section. Currently can be only of …\nTypes section.\nType table index.\nSection with type declarations.\n32-bit unsigned integer, encoded in little endian.\n64-bit unsigned integer, encoded in little endian.\n8-bit unsigned integer, NOT encoded in LEB128; it’s just …\nUnexpected end of input.\nInvalid block type declaration.\nUnknown external kind code.\nUnknown function form (should be 0x60).\nUnknown internal kind code.\nUnknown name subsection type.\nUnknown opcode encountered.\nInvalid/unknown table element type declaration.\nInvalid/unknown value type declaration.\nUnparsed part of the module/section.\nSection is unparsed.\nUnsupported version.\nInline value type.\nValue type.\n32-bit signed integer, encoded in LEB128 (can be 1-5 bytes …\n64-bit signed integer, encoded in LEB128 (can be 1-9 bytes …\n7-bit signed integer, encoded in LEB128 (always 1 byte …\nVarUint1, 1-bit value (0/1).\nUnsigned variable-length integer, limited to 32 bits, …\nUnsigned variable-length integer, limited to 64 bits, …\n7-bit unsigned integer, encoded in LEB128 (always 1 byte …\nAll function bodies in the section.\nAll function bodies in the section, mutable.\nClear the map.\nRemoves the given custom section, if it exists. Returns …\nRemoves the module’s start section.\nInstruction list of the function body. Minimal instruction …\nList of instructions used in the expression.\nInstruction list of the function body (mutable).\nList of instructions used in the expression.\nCode section reference, if any.\nCode section mutable reference, if any.\nDoes the map contain an entry for the specified index?\nType of the global entry\nNumber of locals with the shared type.\nReturns an iterator over the module’s custom sections\nData section reference, if any.\nData section mutable reference, if any.\nDeserialize type from serial i/o\nDeserialize a map containing simple values that support …\nDeserialize a name section.\nDeserialize names, making sure that all names correspond …\nDeserialize names, making sure that all names correspond …\nDeserialize a reloc section.\nDeserialize deserializable type from buffer.\nDeserialize module from the file.\nCustom deserialization routine.\nFinish counted writer routing, which writes accumulated …\nTable element type\nList of individual instructions.\nIndividual instructions, mutable.\nElement section reference, if any.\nElement section mutable reference, if any.\nList of individual instructions.\nEmpty expression with only <code>Instruction::End</code> instruction.\nEmpty expression with only <code>Instruction::End</code> instruction.\nList of relocation entries.\nList of import entries.\nList of all functions in the section.\nTable entries.\nList of all memory entries in the section\nList of all global entries in the section.\nList of all export entries in the section.\nNew elements entries in the section.\nList of all data entries in the section.\nList of relocation entries (mutable).\nList of import entries (mutable).\nList of all functions in the section, mutable.\nMutable table entries.\nMutable list of all memory entries in the section.\nList of all global entries in the section (mutable).\nList of all export entries in the section (mutable).\nList of all data entries in the section (mutable).\nList of all data entries in the section (mutable).\nExports section reference, if any.\nExports section mutable reference, if any.\nLocal binidng of the import entry.\nLocal binidng of the import entry (mutable)\nPublic name.\nField reference of the import entry.\nPublic name (mutable).\nField reference of the import entry (mutable)\nFunction form (currently only valid value is <code>0x60</code>)\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstruct a module from a slice.\nCreate an <code>IndexMap</code> from an iterator.\nFunctions signatures section reference, if any.\nFunctions signatures section mutable reference, if any.\nFunctions name subsection of this section.\nReturns number of functions.\nFunctions name subsection of this section (mutable).\nQuery functions space.\nReturn the name for the specified index, if it exists.\nGlobals section reference, if any.\nGlobals section mutable reference, if any.\nGlobal type.\nGlobal type (mutable).\nReturns number of globals\nQuery globals space.\nTrue if a name section is present.\nCount imports by provided type.\nImports section reference, if any.\nImports section mutable reference, if any.\nTable index (currently valid only value of <code>0</code>)\nLinear memory index (currently the only valid value is <code>0</code>).\nInitialization expression (instructions) for global.\nInitialization expression (instructions) for global …\nInitial size.\nInsert a name into our map, returning the existing value …\nInsert a section, in the correct section ordering. This …\nInternal reference of the export entry.\nInternal reference of the export entry (mutable).\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSerialize a module to a vector.\nDestroy counted list returing inner vector.\nDestructure the module, yielding sections\nIs this instruction starts the new block (which should end …\nIs this map empty?\nIs global entry is declared as mutable\nIs this instruction determines the termination of …\nCreate a non-consuming iterator over this <code>IndexMap</code>’s …\nThe number of items in this map.\nTable memory specification\nLimits of the memory entry.\nA map from function indices to a map from variables …\nA map from function indices to a map from variables …\nLocals declared in function body.\nLocal name subsection of this section.\nLocals declared in function body (mutable).\nLocal name subsection of this section (mutable).\nMaximum size.\nSequence of function indices.\nSequence of function indices (mutable)\nMemory section reference, if any.\nMemory section mutable reference, if any.\nQuery memory space.\nModule reference of the import entry.\nModule name subsection of this section.\nModule reference of the import entry (mutable).\nModule name subsection of this section (mutable).\nThe name of this module.\nName of this section.\nName of the custom section.\nThe name of this module (mutable).\nName of this section (mutable).\nName of the custom section (mutable).\nA map from function indices to names.\nA map from function indices to names (mutable).\nFunctions signatures section reference, if any.\nFunctions signatures section mutable reference, if any.\nNew export entry.\nNew function signature\nNew local with <code>count</code> and <code>value_type</code>.\nNew function body with given <code>locals</code> and <code>instructions</code>.\nNew global entry.\nNew global type\nNew table definition\nNew memory limits definition.\nNew memory definition\nNew import entry.\nNew module with sections\nCreates a new name section.\nCreate a new module name section with the specified name.\nNew list of instructions from vector of instructions.\nNew initialization expression from instruction list.\nNew counted writer on top of the given serial writer.\nCreates a new custom section with the given name and …\nNew element segment.\nNew data segments.\nNew function type given the params and results as vectors\nAn i32 initializer expression that computes the offset at …\nAn i32 initializer expression that computes the offset at …\nAn i32 initializer expression that computes the offset at …\nAn i32 initializer expression that computes the offset at …\nParameters in the function signature.\nMutable parameters in the function signature.\nTry to parse name section in place.\nTry to parse reloc section in place.\nPayload of the custom section.\nPayload of the custom section (mutable).\nReturns size of the module in the provided stream.\nName of the section containing the relocations described …\nName of the section containing the relocations described …\nRemove an item if present and return it.\nResults in the function signature, if any.\nMutable type in the function signature, if any.\nID of the section containing the relocations described in …\nID of the section containing the relocations described in …\nSections list.\nSections list (mutable).\nCreate buffer with serialized value.\nSerialize type to serial i/o\nSerialize module to the file\nSets the payload associated with the given custom section, …\nChanges the module’s start section.\nStart section, if any.\nTable section reference, if any.\nTable section mutable reference, if any.\nQuery table space.\nFunction signature type reference.\nFunction signature type reference (mutable).\nTypes section reference, if any.\nTypes section mutable reference, if any.\nList of type declarations.\nList of type declarations (mutable).\nInitial value of the data segment.\nInitial value of the data segment (mutable).\nType of the locals.\nVersion of module.\nNew code section with specified function bodies.\nCreate an empty <code>IndexMap</code>, preallocating enough space to …\nNew import section with provided types.\nNew function signatures section with provided entries.\nNew table section with provided table entries.\nNew memory section with memory types.\nNew global section from list of global entries.\nNew export section from list of export entries.\nNew elements section.\nNew data section.\nNew type section with provided types.\nActual length of the definition.\nExpected length of the definition.\nAddend to add to the address.\nAddend to add to the address.\nAddend to add to the address.\nIndex of the function symbol in the symbol table.\nIndex of the function symbol in the symbol table.\nIndex of the function symbol in the symbol table.\nIndex of the data symbol in the symbol table.\nIndex of the data symbol in the symbol table.\nIndex of the data symbol in the symbol table.\nIndex of the type used.\nIndex of the global symbol in the symbol table.\nOffset of the value to rewrite.\nOffset of the value to rewrite.\nOffset of the value to rewrite.\nOffset of the value to rewrite.\nOffset of the value to rewrite.\nOffset of the value to rewrite.\nOffset of the value to rewrite.\nOffset of the value to rewrite.\nid of the unparsed section.\nraw bytes of the unparsed section.")
searchState.loadedDescShard("alloy_sol_types", 0, "alloy-sol-types\nWhether the event is anonymous.\nThe ABI representation of this type.\nArray out of bounds access.\nUsed by the <code>assert()</code> builtin.\nTrailing bytes in deserialization buffer.\nThe number of variants in the enum.\nThe number of topics.\nThe number of variants.\nThe number of variants.\nA generic contract error.\nA detailed contract error, including a specific revert or …\nA detailed contract error, including a specific revert or …\nA contract’s custom error.\nA contract’s custom error.\nWhether the ABI-encoded size is dynamic.\nWhether the ABI-encoded size is dynamic.\nThe <code>TokenSeq</code> type corresponding to the tuple.\nThe underlying tuple type which represents this event’s …\nDivision or modulo by zero.\nThe statically-known ABI-encoded size of the type.\nEIP-712 domain attributes used in determining the domain …\nEmpty array pop.\nEnum conversion error.\nContains the error value\nABI Encoding and Decoding errors.\nA Solidity event topic.\nHex error.\nGeneric / unspecified error.\nA generic contract error.\nRepresents the reason for a revert in a generic contract …\nInvalid enum value.\nCalling invalid internal function.\nCould not decode an event from log topics.\nExtension trait for ABI representation.\nThe minimum length of the data for this type.\nThe name of this type.\nThe name of this type.\nThe struct name.\nThe name of the struct.\nContains the success value\nOther errors.\nOverran deserialization buffer.\nThe statically-known Non-standard Packed Mode ABI-encoded …\nA Solidity panic.\nA panic. See <code>Panic</code> for more information.\nA panic. See <code>Panic</code> for more information.\nRepresents a Solidity panic. Same as the Solidity …\nThe underlying tuple type which represents the error’s …\nThe underlying tuple type which represents this type’s …\nThe underlying tuple type which represents this type’s …\nRepresents a raw string message as the reason for the …\nRepresents a raw string message as the reason for the …\nABI Decoding recursion limit exceeded.\nValidation reserialization did not match input.\nAllocation failed.\nResource error (too large allocation or too large array).\nABI result type.\nThe function’s return struct.\nThe returns’ corresponding TokenSeq type.\nThe underlying tuple type which represents this type’s …\nRepresents a standard Solidity revert. These are thrown by …\nA generic revert. See <code>Revert</code> for more information.\nA generic revert. See <code>Revert</code> for more information.\nRepresents the reason for a revert in a smart contract.\nThe corresponding Rust type.\nThe error selector: <code>keccak256(SIGNATURE)[0..4]</code>\nThe function selector: <code>keccak256(SIGNATURE)[0..4]</code>\nThe error’s ABI signature.\nThe event’s ABI signature.\nThe function’s ABI signature.\nThe event’s ABI signature hash, or selector: …\nThe name of this type in Solidity.\nIterator over the function or error selectors of a …\nA Solidity function call.\nA Solidity constructor.\nA Solidity enum. This is always a wrapper around a <code>u8</code>.\nA Solidity custom error.\nSolidity event.\nA collection of <code>SolEvent</code>s.\nA collection of ABI-encodable call-like types. This …\nA Solidity struct.\nA Solidity type.\nThe Solidity type that this type corresponds to.\nA Solidity value.\nInvalid encoding in storage.\nThe corresponding <code>TokenSeq</code> type.\nThe arguments’ corresponding TokenSeq type.\nThe arguments’ corresponding TokenSeq type.\nThe corresponding ABI token type.\nA list of Solidity event topics.\nThe underlying tuple type which represents this event’s …\nA typecheck detected a word that does not match the data …\nArithmetic underflow or overflow.\nUnknown selector.\nThe ABI word type.\nEthereum ABI codec implementation.\nReturns the ABI representation of this type.\nABI decode the enum from the given buffer.\nABI decode the enum from the given buffer.\nABI decode this error’s arguments from the given slice, …\nABI decode this error’s arguments from the given slice, …\nABI decode this call’s arguments from the given slice, …\nABI decode this call’s arguments from the given slice, …\nABI-decodes the given data into one of the variants of <code>self</code>…\nABI-decodes the given data into one of the variants of <code>self</code>…\nABI-decode this type from the given data.\nABI-decode this type from the given data.\nDecodes this type’s value from an ABI blob by …\nDecodes this type’s value from an ABI blob by …\nABI-decodes the dynamic data of this event from the given …\nABI-decodes the dynamic data of this event from the given …\nABI-decodes the dynamic data of this event from the given …\nABI-decodes the dynamic data of this event from the given …\nABI-decode this type from the given data.\nABI-decode this type from the given data.\nDecodes this type’s value from an ABI blob by …\nDecodes this type’s value from an ABI blob by …\nABI-decode this type from the given data, with validation.\nABI-decode this type from the given data, with validation.\nDecodes this type’s value from an ABI blob by …\nDecodes this type’s value from an ABI blob by …\nABI-decodes the given data into one of the variants of <code>self</code>…\nABI decode this call’s arguments from the given slice, …\nABI decode this call’s arguments from the given slice, …\nABI decode this call’s arguments from the given slice, …\nABI decode this call’s arguments from the given slice, …\nABI-decodes the given data into one of the variants of <code>self</code>…\nABI decode this error’s arguments from the given slice, …\nABI decode this error’s arguments from the given slice, …\nABI decode this call’s arguments from the given slice, …\nABI decode this call’s arguments from the given slice, …\nABI decode this call’s return values from the given …\nABI decode this call’s return values from the given …\nABI-decode this type from the given data.\nABI-decode this type from the given data.\nDecodes this type’s value from an ABI blob by …\nDecodes this type’s value from an ABI blob by …\nABI-decode this type from the given data, with validation.\nABI-decode this type from the given data, with validation.\nDecodes this type’s value from an ABI blob by …\nDecodes this type’s value from an ABI blob by …\nABI decode the enum from the given buffer, with validation.\nABI decode the enum from the given buffer, with validation.\nABI decode this error’s arguments from the given slice, …\nABI decode this error’s arguments from the given slice, …\nABI decode this call’s arguments from the given slice, …\nABI decode this call’s arguments from the given slice, …\nABI-decodes the given data into one of the variants of <code>self</code>…\nABI-decodes the given data into one of the variants of <code>self</code>…\nABI-decode this type from the given data, with validation.\nABI-decode this type from the given data, with validation.\nDecodes this type’s value from an ABI blob by …\nDecodes this type’s value from an ABI blob by …\nABI encode the enum.\nABI encode the enum.\nABI encode the error to the given buffer <strong>with</strong> its selector.\nABI encode the error to the given buffer <strong>with</strong> its selector.\nABI encode the call to the given buffer <strong>with</strong> its selector.\nABI encode the call to the given buffer <strong>with</strong> its selector.\nABI encode the call to the given buffer.\nABI encode the call to the given buffer.\nABI-encodes <code>self</code> into the given buffer.\nABI-encodes <code>self</code> into the given buffer.\nABI-encodes the value.\nABI-encodes the value.\nTokenizes and ABI-encodes the given value by wrapping it …\nTokenizes and ABI-encodes the given value by wrapping it …\nNon-standard Packed Mode ABI encoding.\nNon-standard Packed Mode ABI encoding.\nNon-standard Packed Mode ABI encoding.\nNon-standard Packed Mode ABI encoding.\nNon-standard Packed Mode ABI encoding.\nNon-standard Packed Mode ABI encoding.\nNon-standard Packed Mode ABI encoding.\nNon-standard Packed Mode ABI encoding.\nEncodes an ABI sequence suitable for function parameters.\nEncodes an ABI sequence suitable for function parameters.\nTokenizes and ABI-encodes the given value as function …\nTokenizes and ABI-encodes the given value as function …\nABI-encodes <code>self</code> into the given buffer, <em>without</em> any …\nABI encode the enum into the given buffer.\nABI encode the enum into the given buffer.\nABI encode the error to the given buffer <strong>without</strong> its …\nABI encode the error to the given buffer <strong>without</strong> its …\nABI encode the call to the given buffer <strong>without</strong> its …\nABI encode the call to the given buffer <strong>without</strong> its …\nABI encode the call’s return value.\nABI encode the call’s return value.\nABI encode the call’s return values.\nABI encode the call’s return values.\nEncodes an ABI sequence.\nEncodes an ABI sequence.\nTokenizes and ABI-encodes the given value as a sequence.\nTokenizes and ABI-encodes the given value as a sequence.\nThe size of the encoded data, <em>without</em> any selectors.\nThe size of the error params when encoded in bytes, <strong>without</strong>…\nThe size of the error params when encoded in bytes, <strong>without</strong>…\nThe size of the ABI-encoded dynamic data in bytes.\nThe size of the ABI-encoded dynamic data in bytes.\nThe size of the encoded data in bytes, <strong>without</strong> its …\nThe size of the encoded data in bytes, <strong>without</strong> its …\nThe size of the encoded data in bytes.\nThe size of the encoded data in bytes.\nCalculate the ABI-encoded size of the data.\nCalculate the ABI-encoded size of the data.\nCalculate the ABI-encoded size of the data, counting both …\nCalculate the ABI-encoded size of the data, counting both …\nReturns the number of bytes that will be used to encode …\nReturns the length of this value when ABI-encoded in …\nReturns the length of this value when ABI-encoded in …\nReturns the <code>ContractError</code> if this type is a …\nReturns an immutable reference to the inner custom error …\nReturns a mutable reference to the inner custom error if …\nReturns an immutable reference to the inner <code>Panic</code> if <code>self</code> …\nReturns a mutable reference to the inner <code>Panic</code> if <code>self</code> …\nReturns the raw string error message if this type is a …\nReturns an immutable reference to the inner <code>Revert</code> if <code>self</code> …\nReturns a mutable reference to the inner <code>Revert</code> if <code>self</code> …\nReturns the panic code’s string representation.\nThe EIP-155 chain ID. The user-agent should refuse signing …\nCheck that the event’s signature matches the given …\nCheck that the event’s signature matches the given …\nThe Solidity panic code.\nInstantiates a new error with a static str.\nDecodes and retrieves the reason for a revert from the …\nDecode the event from the given log object.\nDecode the event from the given log object.\nDecode the events from the given log object.\nDecode the events from the given log object.\nDecode the event from the given log object.\nDecode the event from the given log object.\nDecode the event from the given log object with validation.\nDecode the event from the given log object with validation.\nDecode the event from the given log object with validation.\nDecode the event from the given log object with validation.\nDecode the events from the given log info.\nDecode the event from the given log info.\nDecode the event from the given log info.\nDecode the event from the given log info, with validation.\nDecode the event from the given log info, with validation.\nDecodes and retrieves the reason for a revert from the …\nDecode the topics of this event from the given data.\nDecode the topics of this event from the given data.\nDetokenize the topics into a tuple of rust types.\nDetokenize this type’s value from the given token.\nDetokenize a value from the given token.\nDetokenize a value from the given token.\nReturns component EIP-712 types. These types are used to …\nEncode this data according to EIP-712 <code>encodeData</code> rules, …\nEncode this data according to EIP-712 <code>encodeData</code> rules, …\nEncode this data according to EIP-712 <code>encodeData</code> rules, …\nEncode this data according to EIP-712 <code>encodeData</code> rules, …\nConvenience macro to instantiate an EIP-712 domain.\nEncodes this domain using EIP-712 <code>encodeData</code>.\nThe EIP-712-encoded type string.\nThe EIP-712-encoded type string.\nCalculates the EIP-712 <code>hashStruct</code> for this value.\nCalculates the EIP-712 <code>hashStruct</code> for this value.\nReturn the root EIP-712 type. This type is used to …\nCalculate the EIP-712 signing hash for this struct. Note …\nCalculate the EIP-712 signing hash for this struct. Note …\nCalculates the EIP-712 <code>typeHash</code> for this struct.\nCalculates the EIP-712 <code>typeHash</code> for this struct.\nABI-encode the dynamic data of this event.\nABI-encode the dynamic data of this event.\nEncodes this domain using EIP-712 <code>encodeData</code>.\nABI-encode the dynamic data of this event into the given …\nABI-encode the dynamic data of this event into the given …\nEncodes this domain using EIP-712 <code>encodeData</code> into the …\nTransform ca <code>Log</code> containing this event into a <code>Log</code> …\nTransform ca <code>Log</code> containing this event into a <code>Log</code> …\nEncode this event to a <code>LogData</code>.\nEncode this event to a <code>LogData</code>.\nIndexed event parameter encoding.\nEncodes this type as preimage bytes which are then hashed …\nEncode the topics of this event.\nEncode the topics of this event.\nEncode the topics of this event into a fixed-size array.\nEncode the topics of this event into a fixed-size array.\nEncode the topics of this event into the given buffer.\nThe EIP-712-encoded type string.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the panic code for the given number if it is a …\nHashes this domain according to EIP-712 <code>hashStruct</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if <code>self</code> matches <code>CustomError</code>.\nReturns <code>true</code> if <code>self</code> matches <code>CustomError</code>.\nReturns <code>true</code> if <code>self</code> matches <code>Panic</code>.\nReturns <code>true</code> if <code>self</code> matches <code>Panic</code>.\nReturns <code>true</code> if <code>self</code> matches <code>Revert</code>.\nReturns <code>true</code> if <code>self</code> matches <code>Revert</code>.\nReturns the PanicKind if this panic code is a known …\nThe user readable name of signing domain, i.e. the name of …\nConvert from the tuple type used for ABI encoding and …\nConvert decoded rust data to the event type.\nConvert from the tuple type used for ABI encoding and …\nConvert from the tuple type used for ABI encoding and …\nInstantiate a new EIP-712 domain.\nConvert decoded rust data to the event type.\nConvert decoded rust data to the event type.\nReturns the number of ABI words (32 bytes) that will be …\nReturns the revert reason string, or <code>&quot;&lt;empty&gt;&quot;</code> if empty.\nThe reason string, provided by the Solidity contract.\nA disambiguating salt for the protocol. This can be used …\nThe selector of this instance.\nThe selector of this type at the given index, used in …\nReturns an iterator over the selectors of this type.\nReturns an iterator over the selectors of this type.\nCalculate the domain separator for the domain object.\nSolidity types.\nThe name of the associated Solidity type.\nThe name of the associated Solidity type.\nThe name of the associated Solidity type.\nThe name of the associated Solidity type.\nReturns the name of this type in Solidity.\nReturns the name of this type in Solidity.\nReturns the reason for a revert as a string.\nConvert to the token type used for EIP-712 encoding and …\nTokenize the call’s arguments.\nTokenize the call’s arguments.\nTokenize the enum.\nTokenize the enum.\nTokenizes the given value into this type’s token.\nTokenizes the given value into this type’s token.\nTokenizes the given value into this type’s token.\nTokenizes the given value into this type’s token.\nTokenize the event’s non-indexed parameters.\nTokenize the call’s return values.\nThe number of bytes this type occupies in another topic’…\nThe event’s topics.\nReturns an error if the given selector is not known to …\nReturns an error if the given selector is not known to …\nReturns an error if the given token cannot be detokenized …\nReturns an error if the given token cannot be detokenized …\nInstantiates a new <code>Error::TypeCheckFail</code> with the provided …\nInstantiates a new <code>Error::TypeCheckFail</code> with the provided …\nInstantiates a new <code>Error::TypeCheckFail</code> with the provided …\nCalculates the EIP-712 <code>typeHash</code> for this domain.\nInstantiates a new <code>Error::UnknownSelector</code> with the …\nUtilities used by different modules.\nReturns <code>true</code> if the given selector is known to this type.\nReturns <code>true</code> if the given token can be detokenized with …\nThe address of the contract that will verify the signature.\nThe current major version of the signing domain. …\nHex-encoded data.\nThe Solidity type we failed to produce.\nThe invalid log.\nThe maximum valid value.\nThe name of the enum.\nThe name of the enum or event.\nThe type name.\nThe unknown selector.\nThe invalid value.\nThe <code>Decoder</code> wraps a byte slice with necessary info to …\nThe ABI encoding of an empty byte array (<code>bytes</code> or <code>string</code>).\nAn ABI encoder.\nThe decoder recursion limit. This is currently hardcoded, …\nShortcut for appending a token sequence.\nAppend a pointer to the current suffix offset.\nAppend a sequence of bytes as a packed sequence with a …\nAppend a sequence length.\nAppend a word to the encoder.\nBump the suffix offset by a given number of words.\nReturn a reference to the encoded bytes.\nCreate a child decoder, starting at <code>offset</code> bytes from the …\nABI-decodes a token by wrapping it in a single-element …\nDecodes a single token from the underlying buffer.\nABI-decodes top-level function args.\nDecodes ABI compliant vector of bytes into vector of …\nDecodes a sequence of tokens from the underlying buffer.\nABI-encodes a single token.\nABI-encodes a tuple as ABI function params, suitable for …\nABI-encodes a token sequence.\nFinish the encoding process, returning the encoded words.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nFinish the encoding process, returning the encoded bytes.\nReturns whether the remaining buffer is empty.\nInstantiate a new empty encoder.\nInstantiate a new decoder from a byte slice and a …\nReturns the current offset in the buffer.\nPeek into the buffer.\nPeek a slice of size <code>len</code> from the buffer without advancing …\nPeek a slice of size <code>len</code> from the buffer at a specific …\nPeek a <code>usize</code> from the buffer, without advancing the offset.\nPeek a <code>usize</code> from the buffer at a specific offset, without …\nPeek the next word from the buffer without advancing the …\nPeek a word from the buffer at a specific offset, without …\nRemoves the last offset and returns it.\nAppends a suffix offset.\nCreate a child decoder, starting at <code>offset</code> bytes from the …\nReturns the number of bytes in the remaining buffer.\nReturns a reference to the remaining bytes in the buffer.\nReturns the number of words in the remaining buffer.\nSets the current offset in the buffer.\nDetermine the current suffix offset.\nReturn a child decoder by consuming a word, interpreting …\nTakes a <code>usize</code> offset from the buffer by consuming a word.\nTakes the offset from the child decoder and sets it as the …\nTakes a slice of bytes of the given length.\nTake a word from the buffer, advancing the offset.\nEthereum ABI tokens.\nInstantiate a new encoder with a given capacity in words.\nReturn a reference to the encoded words.\nTrue if the token represents a dynamically-sized type.\nA Dynamic Sequence - <code>T[]</code>\nA Fixed Sequence - <code>T[N]</code>\nTrue for tuples only.\nA Packed Sequence - <code>bytes</code> or <code>string</code>\nEthereum ABI tokens.\nA token composed of a sequence of other tokens.\nA single EVM word - T for any value type.\nReturns a reference to the array.\nReturns a reference to the word as a slice.\nReturns a reference to the array as a slice.\nReturns a reference to the backing slice.\nReturns a reference to the slice.\nDecode a token from a decoder.\nABI-decode the token sequence from the encoder.\nABI-encode the token sequence into the encoder.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAppend head words to the encoder.\nCalculate the number of head words.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTake the backing array, consuming the token.\nInstantiate a new <code>Bytes</code> by copying the underlying slice.\nInstantiate a new <code>Vec</code> by copying the underlying slice.\nCreate a new word token from a word.\nAppend tail words to the encoder.\nCalculate the number of tail words.\nCalculate the total number of head and tail words.\nAddress - <code>address</code>\nArray - <code>T[]</code>\nThe number of bits in the integer: <code>BITS</code>\nThe number of bytes in the integer: <code>BITS / 8</code>\nThe number of bytes in the integer: <code>BITS / 8</code>\nBool - <code>bool</code>\nSpecifies the number of bytes in a <code>FixedBytes</code> array as a …\nBytes - <code>bytes</code>\nFixedArray - <code>T[M]</code>\nFixedBytes - <code>bytesX</code>\nFunction - <code>function</code>\nThe name of the <code>Int</code> type: <code>int&lt;N&gt;</code>\nInt - <code>intX</code>\nThe signed integer Rust representation.\nSpecifies the number of bits in an <code>Int</code> or <code>Uint</code> as a type.\nThe name of the <code>FixedBytes</code> type: <code>bytes&lt;N&gt;</code>\nThe difference between the representation’s and this …\nString - <code>string</code>\nStatically guarantees that a <code>FixedBytes</code> byte count is …\nStatically guarantees that a <code>Int</code> or <code>Uint</code> bit count is …\nThe name of the <code>Uint</code> type: <code>uint&lt;N&gt;</code>\nUint - <code>uintX</code>\nThe unsigned integer Rust representation.\nThe index of the most significant byte in the Word type.\nThe index of the most significant byte in the Word type.\nDetokenizes a signed integer.\nDetokenizes an unsigned integer.\nABI-encode a signed integer in packed mode.\nABI-encode an unsigned integer in packed mode.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTokenizes a signed integer.\nTokenizes an unsigned integer.\nSee <code>usize::next_multiple_of</code>.\nCalculates the padded length of a slice by rounding its …\nCalculates the padded length of a slice of a specific …")
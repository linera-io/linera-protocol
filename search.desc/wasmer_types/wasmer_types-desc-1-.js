searchState.loadedDescShard("wasmer_types", 1, "Returns a mutable reference to the output at this …\nReturns a pointer to the output at this location, without …\nReturns a mutable pointer to the output at this location, …\nReturns a shared reference to the output at this location, …\nReturns a mutable reference to the output at this …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the remainder of the original slice that is not …\nReturns the remainder of the original slice that is not …\nReturns the remainder of the original slice that is not …\nViews the underlying data as a subslice of the original …\nImplementation of <code>[T]::join</code>\nPerforms bounds checking of a range.\nReturns the remainder of the original slice that is not …\nReturns the remainder of the original slice that is not …\nReturns the remainder of the original slice that is not …\nPerforms bounds checking of a range without panicking.\nA draining iterator for <code>String</code>.\nA possible error value when converting a <code>String</code> from a …\nA possible error value when converting a <code>String</code> from a …\nAn iterator over the <code>char</code>s of a string.\nA type alias for <code>Infallible</code>.\nA UTF-8–encoded, growable string.\nA trait for converting a value to a <code>String</code>.\nReturns a byte slice of this <code>String</code>’s contents.\nReturns a slice of <code>u8</code>s bytes that were attempted to …\nConverts a <code>String</code> into a mutable string slice.\nReturns a mutable reference to the contents of this <code>String</code>.\nReturns the remaining (sub)string of this iterator as a …\nExtracts a string slice containing the entire <code>String</code>.\nViews the underlying data as a subslice of the original …\nReturns this <code>String</code>’s capacity, in bytes.\nTruncates this <code>String</code>, removing all contents.\nClones the contents of <code>source</code> into <code>self</code>.\nCreates an empty <code>String</code>.\nRemoves the specified range from the string in bulk, …\nCopies elements from <code>src</code> range to the end of the string.\nReturns the argument unchanged.\nConverts a <code>&amp;mut str</code> into a <code>String</code>.\nConverts a <code>&amp;String</code> into a <code>String</code>.\nConverts a clone-on-write string to an owned instance of …\nConverts a <code>&amp;str</code> into a <code>String</code>.\nAllocates an owned <code>String</code> from a single character.\nConverts the given boxed <code>str</code> slice to a <code>String</code>. It is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new <code>String</code> from a pointer, a length and a …\nDecode a native endian UTF-16–encoded vector <code>v</code> into a …\nDecode a native endian UTF-16–encoded slice <code>v</code> into a …\nDecode a UTF-16BE–encoded vector <code>v</code> into a <code>String</code>, …\nDecode a UTF-16BE–encoded slice <code>v</code> into a <code>String</code>, …\nDecode a UTF-16LE–encoded vector <code>v</code> into a <code>String</code>, …\nDecode a UTF-16LE–encoded slice <code>v</code> into a <code>String</code>, …\nConverts a vector of bytes to a <code>String</code>.\nConverts a slice of bytes to a string, including invalid …\nConverts a <code>Vec&lt;u8&gt;</code> to a <code>String</code>, substituting invalid UTF-8 …\nConverts a vector of bytes to a <code>String</code> without checking …\nInserts a character into this <code>String</code> at a byte position.\nInserts a string slice into this <code>String</code> at a byte position.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts this <code>String</code> into a Box&lt;str&gt;.\nConverts a <code>String</code> into a byte vector.\nReturns the bytes that were attempted to convert to a …\nConverts a <code>String</code> into an iterator over the <code>char</code>s of the …\nDecomposes a <code>String</code> into its raw components: …\nConsumes the <code>IntoChars</code>, returning the remaining string.\nConverts the bytes into a <code>String</code> lossily, substituting …\nReturns <code>true</code> if this <code>String</code> has a length of zero, and <code>false</code>…\nConsumes and leaks the <code>String</code>, returning a mutable …\nReturns the length of this <code>String</code>, in bytes, not <code>char</code>s or …\nCreates a new empty <code>String</code>.\nRemoves the last character from the string buffer and …\nAppends the given <code>char</code> to the end of this <code>String</code>.\nAppends a given string slice onto the end of this <code>String</code>.\nRemoves a <code>char</code> from this <code>String</code> at a byte position and …\nRemove all matches of pattern <code>pat</code> in the <code>String</code>.\nRemoves the specified range in the string, and replaces it …\nReserves capacity for at least <code>additional</code> bytes more than …\nReserves the minimum capacity for at least <code>additional</code> …\nRetains only the characters specified by the predicate.\nShrinks the capacity of this <code>String</code> with a lower bound.\nShrinks the capacity of this <code>String</code> to match its length.\nSplits the string into two at the given byte index.\nConverts the given value to a <code>String</code>.\nShortens this <code>String</code> to the specified length.\nConverts a <code>CString</code> into a <code>String</code> if it contains valid …\nTries to reserve capacity for at least <code>additional</code> bytes …\nTries to reserve the minimum capacity for at least …\nCreates a new empty <code>String</code> with at least the specified …\nFetch a <code>Utf8Error</code> to get more details about the conversion …\nCreates a new empty <code>String</code> with at least the specified …\nA thread-safe reference-counting pointer. ‘Arc’ stands …\nA barrier enables multiple threads to synchronize the …\nA <code>BarrierWaitResult</code> is returned by <code>Barrier::wait()</code> when …\nA Condition Variable\nContains the error value\nContains the error value\n<code>Exclusive</code> provides only <em>mutable</em> access, also referred to …\nA value which is initialized on the first access.\nA type alias for the result of a lock method which can be …\nAn RAII mutex guard returned by <code>MutexGuard::map</code>, which can …\nRAII structure used to release the shared read access of a …\nRAII structure used to release the exclusive write access …\nA mutual exclusion primitive useful for protecting shared …\nAn RAII implementation of a “scoped lock” of a mutex. …\nInitialization value for static <code>Once</code> values.\nContains the success value\nContains the success value\nA low-level synchronization primitive for one-time global …\nA synchronization primitive which can nominally be written …\nState yielded to <code>Once::call_once_force()</code>’s closure …\nA type of error which can be returned whenever a lock is …\nThe lock could not be acquired because another thread …\nA re-entrant mutual exclusion lock\nAn RAII implementation of a “scoped lock” of a …\nA reader-writer lock\nRAII structure used to release the shared read access of a …\nRAII structure used to release the exclusive write access …\nAn enumeration of possible errors associated with a …\nA type alias for the result of a nonblocking locking …\nA type indicating whether a timed wait on a condition …\n<code>Weak</code> is a version of <code>Arc</code> that holds a non-owning reference …\nThe lock could not be acquired at this time because the …\nReturns a reference to the underlying allocator.\nReturns a reference to the underlying allocator.\nProvides a raw pointer to the data.\nReturns a raw pointer to the object <code>T</code> pointed to by this …\nConverts to <code>Arc&lt;T&gt;</code>.\nConverts to <code>Arc&lt;[T]&gt;</code>.\nAtomic types\nPerforms an initialization routine once and only once. The …\nPerforms the same function as <code>call_once()</code> except ignores …\nClear the poisoned state from a mutex.\nClear the poisoned state from a lock.\nMakes a clone of the <code>Arc</code> pointer.\nMakes a clone of the <code>Weak</code> pointer that points to the same …\nComparison for two <code>Arc</code>s.\nDecrements the strong reference count on the <code>Arc&lt;T&gt;</code> …\nDecrements the strong reference count on the <code>Arc&lt;T&gt;</code> …\nCreates an empty <code>[T]</code> inside an Arc\nCreates an empty CStr inside an Arc\nCreates an empty str inside an Arc\nCreates a new <code>Arc&lt;T&gt;</code>, with the <code>Default</code> value for <code>T</code>.\nConstructs a new <code>Weak&lt;T&gt;</code>, without allocating memory. …\nCreates a <code>Condvar</code> which is ready to be waited on and …\nCreates a <code>Mutex&lt;T&gt;</code>, with the <code>Default</code> value for T.\nCreates a new <code>RwLock&lt;T&gt;</code>, with the <code>Default</code> value for T.\nCreates a new lazy value using <code>Default</code> as the initializing …\nCreates a new uninitialized cell.\nDereferences the value.\nAttempts to downcast the <code>Arc&lt;dyn Any + Send + Sync&gt;</code> to a …\nDowncasts the <code>Arc&lt;dyn Any + Send + Sync&gt;</code> to a concrete …\nCreates a new <code>Weak</code> pointer to this allocation.\nDowngrades a write-locked <code>RwLockWriteGuard</code> into a …\nDrops the <code>Arc</code>.\nDrops the <code>Weak</code> pointer.\nEquality for two <code>Arc</code>s.\nEquality for two <code>OnceLock</code>s.\nForces the evaluation of this lazy value and returns a …\nForces the evaluation of this lazy value and returns a …\nMove a boxed object to a new, reference-counted allocation.\nAllocates a reference-counted slice and fills it by …\nConverts a <code>CString</code> into an Arc&lt;CStr&gt; by moving the <code>CString</code> …\nConverts an atomically reference-counted string slice into …\nCreates an atomically reference-counted pointer from a …\nConverts a <code>Path</code> into an <code>Arc</code> by copying the <code>Path</code> data into …\nConverts a <code>&amp;CStr</code> into a <code>Arc&lt;CStr&gt;</code>, by copying the contents …\nConverts a <code>Path</code> into an <code>Arc</code> by copying the <code>Path</code> data into …\nConverts a <code>&amp;mut CStr</code> into a <code>Arc&lt;CStr&gt;</code>, by copying the …\nAllocates a reference-counted slice and moves <code>v</code>’s items …\nReturns the argument unchanged.\nConverts a <code>PathBuf</code> into an Arc&lt;Path&gt; by moving the <code>PathBuf</code> …\nCopies the string into a newly allocated Arc&lt;OsStr&gt;.\nConverts a <code>T</code> into an <code>Arc&lt;T&gt;</code>\nAllocates a reference-counted <code>str</code> and copies <code>v</code> into it.\nConverts a <code>[T; N]</code> into an <code>Arc&lt;[T]&gt;</code>.\nCopies the string into a newly allocated Arc&lt;OsStr&gt;.\nAllocates a reference-counted <code>str</code> and copies <code>v</code> into it.\nAllocates a reference-counted slice and fills it by …\nConverts an <code>OsString</code> into an Arc&lt;OsStr&gt; by moving the …\nAllocates a reference-counted <code>str</code> and copies <code>v</code> into it.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new mutex in an unlocked state ready for use. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new instance of an <code>RwLock&lt;T&gt;</code> which is unlocked. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new cell with its contents set to <code>value</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTakes each element in the <code>Iterator</code> and collects it into an …\nBuild a <em>mutable</em> reference to an <code>Exclusive&lt;T&gt;</code> from a <em>mutable</em>…\nBuild a <em>pinned mutable</em> reference to an <code>Exclusive&lt;T&gt;</code> from a …\nConstructs an <code>Arc&lt;T&gt;</code> from a raw pointer.\nConverts a raw pointer previously created by <code>into_raw</code> back …\nConstructs an <code>Arc&lt;T, A&gt;</code> from a raw pointer.\nConverts a raw pointer previously created by <code>into_raw</code> back …\n‘Greater than or equal to’ comparison for two <code>Arc</code>s.\nReturns a reference to the value if initialized, or <code>None</code> …\nGets the reference to the underlying value.\nReturns the contained value by cloning it.\nReturns the contained value by cloning it.\nReturns a mutable reference into the given <code>Arc</code>, if there …\nReturns a mutable reference to the underlying data.\nReturns a mutable reference to the underlying data.\nReaches into this error indicating that a lock is …\nReturns a mutable reference to the value if initialized, …\nGets the mutable reference to the underlying value.\nReturns a mutable reference to the underlying data.\nGets exclusive access to the underlying value.\nGets the mutable reference of the contents of the cell, …\nGets the mutable reference of the contents of the cell, …\nReturns a mutable reference into the given <code>Arc</code>, without …\nGets the contents of the cell, initializing it to <code>f()</code> if …\nGets the contents of the cell, initializing it to <code>f()</code> if …\nGets pinned exclusive access to the underlying value.\nReaches into this error indicating that a lock is …\nGreater-than comparison for two <code>Arc</code>s.\nIncrements the strong reference count on the <code>Arc&lt;T&gt;</code> …\nIncrements the strong reference count on the <code>Arc&lt;T&gt;</code> …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts the reference-counted slice into a …\nReturns the inner value, if the <code>Arc</code> has exactly one strong …\nConsumes this mutex, returning the underlying data.\nConsumes this <code>RwLock</code>, returning the underlying data.\nConsumes this error indicating that a lock is poisoned, …\nConsumes this <code>LazyLock</code> returning the stored value.\nConsumes the <code>OnceLock</code>, returning the wrapped value. Returns\nConsumes this lock, returning the underlying data.\nUnwrap the value contained in the <code>Exclusive</code>\nConsumes the <code>Arc</code>, returning the wrapped pointer.\nConsumes the <code>Weak&lt;T&gt;</code> and turns it into a raw pointer.\nConsumes the <code>Arc</code>, returning the wrapped pointer and …\nConsumes the <code>Weak&lt;T&gt;</code>, returning the wrapped pointer and …\nReturns <code>true</code> if some <code>call_once()</code> call has completed …\nReturns <code>true</code> if this thread is the “leader thread” for …\nDetermines whether the mutex is poisoned.\nReturns <code>true</code> if the associated <code>Once</code> was poisoned prior to …\nDetermines whether the lock is poisoned.\n‘Less than or equal to’ comparison for two <code>Arc</code>s.\nAcquires a mutex, blocking the current thread until it is …\nAcquires the lock, blocking the current thread until it is …\nLess-than comparison for two <code>Arc</code>s.\nMakes a mutable reference into the given <code>Arc</code>.\nMakes a <code>MappedMutexGuard</code> for a component of the borrowed …\nMakes a <code>MappedMutexGuard</code> for a component of the borrowed …\nMakes a <code>MappedRwLockReadGuard</code> for a component of the …\nMakes a <code>MappedRwLockWriteGuard</code> for a component of the …\nMakes a <code>MappedRwLockReadGuard</code> for a component of the …\nMakes a <code>MappedRwLockWriteGuard</code> for a component of the …\nMulti-producer, multi-consumer FIFO queue communication …\nMulti-producer, single-consumer FIFO queue communication …\nInequality for two <code>Arc</code>s.\nConstructs a new <code>Arc&lt;T&gt;</code>.\nConstructs a new <code>Weak&lt;T&gt;</code>, without allocating any memory. …\nCreates a new condition variable which is ready to be …\nCreates a new mutex in an unlocked state ready for use.\nCreates a new <code>Once</code> value.\nCreates a new instance of an <code>RwLock&lt;T&gt;</code> which is unlocked.\nCreates a <code>PoisonError</code>.\nCreates a new barrier that can block a given number of …\nCreates a new lazy value with the given initializing …\nCreates a new uninitialized cell.\nCreates a new re-entrant lock in an unlocked state ready …\nWrap a value in an <code>Exclusive</code>\nConstructs a new <code>Arc&lt;T&gt;</code> while giving you a <code>Weak&lt;T&gt;</code> to the …\nConstructs a new <code>Arc&lt;T, A&gt;</code> in the given allocator while …\nConstructs a new <code>Arc&lt;T&gt;</code> in the provided allocator.\nConstructs a new <code>Weak&lt;T, A&gt;</code>, without allocating any …\nConstructs a new <code>Arc</code> with uninitialized contents.\nConstructs a new <code>Arc</code> with uninitialized contents in the …\nConstructs a new atomically reference-counted slice with …\nConstructs a new atomically reference-counted slice with …\nConstructs a new <code>Arc</code> with uninitialized contents, with the …\nConstructs a new <code>Arc</code> with uninitialized contents, with the …\nConstructs a new atomically reference-counted slice with …\nConstructs a new atomically reference-counted slice with …\nWakes up all blocked threads on this condvar.\nWakes up one blocked thread on this condvar.\nPartial comparison for two <code>Arc</code>s.\nConstructs a new <code>Pin&lt;Arc&lt;T&gt;&gt;</code>. If <code>T</code> does not implement <code>Unpin</code>…\nConstructs a new <code>Pin&lt;Arc&lt;T, A&gt;&gt;</code> in the provided allocator. …\nSynchronization objects that employ poisoning.\nReturns <code>true</code> if the two <code>Arc</code>s point to the same allocation …\nReturns <code>true</code> if the two <code>Weak</code>s point to the same allocation …\nLocks this <code>RwLock</code> with shared read access, blocking the …\nReplaces the contained value with <code>value</code>, and returns the …\nReplaces the contained value with <code>value</code>, and returns the …\nSets the contained value.\nSets the contained value.\nInitializes the contents of the cell to <code>value</code>.\nGets the number of strong (<code>Arc</code>) pointers to this …\nGets the number of strong (<code>Arc</code>) pointers pointing to this …\nTakes the value out of this <code>OnceLock</code>, moving it back to an …\nReturns <code>true</code> if the wait was known to have timed out.\nInitializes the contents of the cell to <code>value</code> if the cell …\nAttempts to acquire this lock.\nMakes a <code>MappedMutexGuard</code> for a component of the borrowed …\nMakes a <code>MappedMutexGuard</code> for a component of the borrowed …\nMakes a <code>MappedRwLockReadGuard</code> for a component of the …\nMakes a <code>MappedRwLockWriteGuard</code> for a component of the …\nMakes a <code>MappedRwLockReadGuard</code> for a component of the …\nMakes a <code>MappedRwLockWriteGuard</code> for a component of the …\nConstructs a new <code>Arc&lt;T&gt;</code>, returning an error if allocation …\nConstructs a new <code>Arc&lt;T, A&gt;</code> in the provided allocator, …\nConstructs a new <code>Arc</code> with uninitialized contents, …\nConstructs a new <code>Arc</code> with uninitialized contents, in the …\nConstructs a new <code>Arc</code> with uninitialized contents, with the …\nConstructs a new <code>Arc</code> with uninitialized contents, with the …\nConstructs a new <code>Pin&lt;Arc&lt;T&gt;&gt;</code>, return an error if …\nConstructs a new <code>Pin&lt;Arc&lt;T, A&gt;&gt;</code> in the provided allocator, …\nAttempts to acquire this <code>RwLock</code> with shared read access.\nReturns the inner value, if the <code>Arc</code> has exactly one strong …\nAttempts to lock this <code>RwLock</code> with exclusive write access.\nIf we have the only reference to <code>T</code> then unwrap it. …\nAttempts to upgrade the <code>Weak</code> pointer to an <code>Arc</code>, delaying …\nBlocks the current thread until this condition variable …\nBlocks the current thread until initialization has …\nBlocks the current thread until all threads have …\nBlocks the current thread until the cell is initialized.\nBlocks the current thread until initialization has …\nWaits on this condition variable for a notification, …\nWaits on this condition variable for a notification, …\nWaits on this condition variable for a notification, …\nBlocks the current thread until the provided condition …\nGets the number of <code>Weak</code> pointers to this allocation.\nGets an approximation of the number of <code>Weak</code> pointers …\nLocks this <code>RwLock</code> with exclusive write access, blocking …\nAn <code>AtomicBool</code> initialized to <code>false</code>.\nAn <code>AtomicIsize</code> initialized to <code>0</code>.\nAn <code>AtomicUsize</code> initialized to <code>0</code>.\nHas the effects of both <code>Acquire</code> and <code>Release</code> together: For …\nWhen coupled with a load, if the loaded value was written …\nA boolean type which can be safely shared between threads.\nAn integer type which can be safely shared between threads.\nAn integer type which can be safely shared between threads.\nAn integer type which can be safely shared between threads.\nAn integer type which can be safely shared between threads.\nAn integer type which can be safely shared between threads.\nA raw pointer type which can be safely shared between …\nAn integer type which can be safely shared between threads.\nAn integer type which can be safely shared between threads.\nAn integer type which can be safely shared between threads.\nAn integer type which can be safely shared between threads.\nAn integer type which can be safely shared between threads.\nAtomic memory orderings\nNo ordering constraints, only atomic operations.\nWhen coupled with a store, all previous operations become …\nLike <code>Acquire</code>/<code>Release</code>/<code>AcqRel</code> (for load, store, and …\nReturns a mutable pointer to the underlying <code>bool</code>.\nReturns a mutable pointer to the underlying pointer.\nReturns a mutable pointer to the underlying integer.\nReturns a mutable pointer to the underlying integer.\nReturns a mutable pointer to the underlying integer.\nReturns a mutable pointer to the underlying integer.\nReturns a mutable pointer to the underlying integer.\nReturns a mutable pointer to the underlying integer.\nReturns a mutable pointer to the underlying integer.\nReturns a mutable pointer to the underlying integer.\nReturns a mutable pointer to the underlying integer.\nReturns a mutable pointer to the underlying integer.\nStores a value into the <code>bool</code> if the current value is the …\nStores a value into the pointer if the current value is …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the <code>bool</code> if the current value is the …\nStores a value into the pointer if the current value is …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the <code>bool</code> if the current value is the …\nStores a value into the pointer if the current value is …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nA “compiler-only” atomic fence.\nCreates an <code>AtomicBool</code> initialized to <code>false</code>.\nCreates a null <code>AtomicPtr&lt;T&gt;</code>.\nAn atomic fence.\nAdds to the current value, returning the previous value.\nAdds to the current value, returning the previous value.\nAdds to the current value, returning the previous value.\nAdds to the current value, returning the previous value.\nAdds to the current value, returning the previous value.\nAdds to the current value, returning the previous value.\nAdds to the current value, returning the previous value.\nAdds to the current value, returning the previous value.\nAdds to the current value, returning the previous value.\nAdds to the current value, returning the previous value.\nLogical “and” with a boolean value.\nPerforms a bitwise “and” operation on the address of …\nBitwise “and” with the current value.\nBitwise “and” with the current value.\nBitwise “and” with the current value.\nBitwise “and” with the current value.\nBitwise “and” with the current value.\nBitwise “and” with the current value.\nBitwise “and” with the current value.\nBitwise “and” with the current value.\nBitwise “and” with the current value.\nBitwise “and” with the current value.\nOffsets the pointer’s address by adding <code>val</code> <em>bytes</em>, …\nOffsets the pointer’s address by subtracting <code>val</code> <em>bytes</em>, …\nMaximum with the current value.\nMaximum with the current value.\nMaximum with the current value.\nMaximum with the current value.\nMaximum with the current value.\nMaximum with the current value.\nMaximum with the current value.\nMaximum with the current value.\nMaximum with the current value.\nMaximum with the current value.\nMinimum with the current value.\nMinimum with the current value.\nMinimum with the current value.\nMinimum with the current value.\nMinimum with the current value.\nMinimum with the current value.\nMinimum with the current value.\nMinimum with the current value.\nMinimum with the current value.\nMinimum with the current value.\nLogical “nand” with a boolean value.\nBitwise “nand” with the current value.\nBitwise “nand” with the current value.\nBitwise “nand” with the current value.\nBitwise “nand” with the current value.\nBitwise “nand” with the current value.\nBitwise “nand” with the current value.\nBitwise “nand” with the current value.\nBitwise “nand” with the current value.\nBitwise “nand” with the current value.\nBitwise “nand” with the current value.\nLogical “not” with a boolean value.\nLogical “or” with a boolean value.\nPerforms a bitwise “or” operation on the address of …\nBitwise “or” with the current value.\nBitwise “or” with the current value.\nBitwise “or” with the current value.\nBitwise “or” with the current value.\nBitwise “or” with the current value.\nBitwise “or” with the current value.\nBitwise “or” with the current value.\nBitwise “or” with the current value.\nBitwise “or” with the current value.\nBitwise “or” with the current value.\nOffsets the pointer’s address by adding <code>val</code> (in units of …\nOffsets the pointer’s address by subtracting <code>val</code> (in …\nSubtracts from the current value, returning the previous …\nSubtracts from the current value, returning the previous …\nSubtracts from the current value, returning the previous …\nSubtracts from the current value, returning the previous …\nSubtracts from the current value, returning the previous …\nSubtracts from the current value, returning the previous …\nSubtracts from the current value, returning the previous …\nSubtracts from the current value, returning the previous …\nSubtracts from the current value, returning the previous …\nSubtracts from the current value, returning the previous …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nLogical “xor” with a boolean value.\nPerforms a bitwise “xor” operation on the address of …\nBitwise “xor” with the current value.\nBitwise “xor” with the current value.\nBitwise “xor” with the current value.\nBitwise “xor” with the current value.\nBitwise “xor” with the current value.\nBitwise “xor” with the current value.\nBitwise “xor” with the current value.\nBitwise “xor” with the current value.\nBitwise “xor” with the current value.\nBitwise “xor” with the current value.\nConverts a <code>bool</code> into an <code>AtomicBool</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts a <code>*mut T</code> into an <code>AtomicPtr&lt;T&gt;</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts an <code>i8</code> into an <code>AtomicI8</code>.\nReturns the argument unchanged.\nConverts an <code>u8</code> into an <code>AtomicU8</code>.\nReturns the argument unchanged.\nConverts an <code>i16</code> into an <code>AtomicI16</code>.\nConverts an <code>u16</code> into an <code>AtomicU16</code>.\nReturns the argument unchanged.\nConverts an <code>i32</code> into an <code>AtomicI32</code>.\nReturns the argument unchanged.\nConverts an <code>u32</code> into an <code>AtomicU32</code>.\nReturns the argument unchanged.\nConverts an <code>i64</code> into an <code>AtomicI64</code>.\nReturns the argument unchanged.\nConverts an <code>u64</code> into an <code>AtomicU64</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts an <code>isize</code> into an <code>AtomicIsize</code>.\nConverts an <code>usize</code> into an <code>AtomicUsize</code>.\nReturns the argument unchanged.\nGets atomic access to a <code>&amp;mut bool</code>.\nGets atomic access to a pointer.\nGet atomic access to a <code>&amp;mut i8</code>.\nGet atomic access to a <code>&amp;mut u8</code>.\nGet atomic access to a <code>&amp;mut i16</code>.\nGet atomic access to a <code>&amp;mut u16</code>.\nGet atomic access to a <code>&amp;mut i32</code>.\nGet atomic access to a <code>&amp;mut u32</code>.\nGet atomic access to a <code>&amp;mut i64</code>.\nGet atomic access to a <code>&amp;mut u64</code>.\nGet atomic access to a <code>&amp;mut isize</code>.\nGet atomic access to a <code>&amp;mut usize</code>.\nGets atomic access to a <code>&amp;mut [bool]</code> slice.\nGets atomic access to a slice of pointers.\nGet atomic access to a <code>&amp;mut [i8]</code> slice.\nGet atomic access to a <code>&amp;mut [u8]</code> slice.\nGet atomic access to a <code>&amp;mut [i16]</code> slice.\nGet atomic access to a <code>&amp;mut [u16]</code> slice.\nGet atomic access to a <code>&amp;mut [i32]</code> slice.\nGet atomic access to a <code>&amp;mut [u32]</code> slice.\nGet atomic access to a <code>&amp;mut [i64]</code> slice.\nGet atomic access to a <code>&amp;mut [u64]</code> slice.\nGet atomic access to a <code>&amp;mut [isize]</code> slice.\nGet atomic access to a <code>&amp;mut [usize]</code> slice.\nCreates a new <code>AtomicBool</code> from a pointer.\nCreates a new <code>AtomicPtr</code> from a pointer.\nCreates a new reference to an atomic integer from a …\nCreates a new reference to an atomic integer from a …\nCreates a new reference to an atomic integer from a …\nCreates a new reference to an atomic integer from a …\nCreates a new reference to an atomic integer from a …\nCreates a new reference to an atomic integer from a …\nCreates a new reference to an atomic integer from a …\nCreates a new reference to an atomic integer from a …\nCreates a new reference to an atomic integer from a …\nCreates a new reference to an atomic integer from a …\nReturns a mutable reference to the underlying <code>bool</code>.\nReturns a mutable reference to the underlying pointer.\nReturns a mutable reference to the underlying integer.\nReturns a mutable reference to the underlying integer.\nReturns a mutable reference to the underlying integer.\nReturns a mutable reference to the underlying integer.\nReturns a mutable reference to the underlying integer.\nReturns a mutable reference to the underlying integer.\nReturns a mutable reference to the underlying integer.\nReturns a mutable reference to the underlying integer.\nReturns a mutable reference to the underlying integer.\nReturns a mutable reference to the underlying integer.\nGets non-atomic access to a <code>&amp;mut [AtomicBool]</code> slice.\nGets non-atomic access to a <code>&amp;mut [AtomicPtr]</code> slice.\nGet non-atomic access to a <code>&amp;mut [AtomicI8]</code> slice\nGet non-atomic access to a <code>&amp;mut [AtomicU8]</code> slice\nGet non-atomic access to a <code>&amp;mut [AtomicI16]</code> slice\nGet non-atomic access to a <code>&amp;mut [AtomicU16]</code> slice\nGet non-atomic access to a <code>&amp;mut [AtomicI32]</code> slice\nGet non-atomic access to a <code>&amp;mut [AtomicU32]</code> slice\nGet non-atomic access to a <code>&amp;mut [AtomicI64]</code> slice\nGet non-atomic access to a <code>&amp;mut [AtomicU64]</code> slice\nGet non-atomic access to a <code>&amp;mut [AtomicIsize]</code> slice\nGet non-atomic access to a <code>&amp;mut [AtomicUsize]</code> slice\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsumes the atomic and returns the contained value.\nConsumes the atomic and returns the contained value.\nConsumes the atomic and returns the contained value.\nConsumes the atomic and returns the contained value.\nConsumes the atomic and returns the contained value.\nConsumes the atomic and returns the contained value.\nConsumes the atomic and returns the contained value.\nConsumes the atomic and returns the contained value.\nConsumes the atomic and returns the contained value.\nConsumes the atomic and returns the contained value.\nConsumes the atomic and returns the contained value.\nConsumes the atomic and returns the contained value.\nLoads a value from the bool.\nLoads a value from the pointer.\nLoads a value from the atomic integer.\nLoads a value from the atomic integer.\nLoads a value from the atomic integer.\nLoads a value from the atomic integer.\nLoads a value from the atomic integer.\nLoads a value from the atomic integer.\nLoads a value from the atomic integer.\nLoads a value from the atomic integer.\nLoads a value from the atomic integer.\nLoads a value from the atomic integer.\nCreates a new <code>AtomicBool</code>.\nCreates a new <code>AtomicPtr</code>.\nCreates a new atomic integer.\nCreates a new atomic integer.\nCreates a new atomic integer.\nCreates a new atomic integer.\nCreates a new atomic integer.\nCreates a new atomic integer.\nCreates a new atomic integer.\nCreates a new atomic integer.\nCreates a new atomic integer.\nCreates a new atomic integer.\nSignals the processor that it is inside a busy-wait …\nStores a value into the bool.\nStores a value into the pointer.\nStores a value into the atomic integer.\nStores a value into the atomic integer.\nStores a value into the atomic integer.\nStores a value into the atomic integer.\nStores a value into the atomic integer.\nStores a value into the atomic integer.\nStores a value into the atomic integer.\nStores a value into the atomic integer.\nStores a value into the atomic integer.\nStores a value into the atomic integer.\nStores a value into the bool, returning the previous value.\nStores a value into the pointer, returning the previous …\nStores a value into the atomic integer, returning the …\nStores a value into the atomic integer, returning the …\nStores a value into the atomic integer, returning the …\nStores a value into the atomic integer, returning the …\nStores a value into the atomic integer, returning the …\nStores a value into the atomic integer, returning the …\nStores a value into the atomic integer, returning the …\nStores a value into the atomic integer, returning the …\nStores a value into the atomic integer, returning the …\nStores a value into the atomic integer, returning the …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, applies a function to it that it return …\nFetches the value, applies a function to it that it return …\nFetches the value, applies a function to it that it return …\nFetches the value, applies a function to it that it return …\nFetches the value, applies a function to it that it return …\nFetches the value, applies a function to it that it return …\nFetches the value, applies a function to it that it return …\nFetches the value, applies a function to it that it return …\nFetches the value, applies a function to it that it return …\nFetches the value, applies a function to it that it return …\nFetches the value, applies a function to it that it return …\nFetches the value, applies a function to it that it return …\nThe message could not be sent because the channel is …\nThe <strong>channel</strong>’s sending half has become disconnected, and …\nThe <strong>channel</strong>’s sending half has become disconnected, and …\nThis <code>sync_channel</code>’s receiving half has disconnected, so …\nThis <strong>channel</strong> is currently empty, but the <strong>Sender</strong>(s) have …\nThe data could not be sent on the <code>sync_channel</code> because it …\nAn owning iterator over messages on a <code>Receiver</code>, created by …\nAn iterator over messages on a <code>Receiver</code>, created by <code>iter</code>.\nThe receiving half of Rust’s <code>channel</code> (or <code>sync_channel</code>) …\nAn error returned from the <code>recv</code> function on a <code>Receiver</code>.\nThis enumeration is the list of possible errors that made …\nAn error returned from the <code>Sender::send</code> or <code>SyncSender::send</code>\nAn error returned from the <code>send_timeout</code> method.\nThe sending-half of Rust’s synchronous <code>channel</code> type.\nThe message could not be sent because the channel is full …\nThis <strong>channel</strong> is currently empty, but the <strong>Sender</strong>(s) have …\nAn iterator that attempts to yield all pending values for …\nThis enumeration is the list of the possible reasons that …\nThis enumeration is the list of the possible error …\nIf the channel is bounded, returns its capacity.\nIf the channel is bounded, returns its capacity.\nCreates a new asynchronous channel, returning the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts a <code>RecvError</code> into a <code>TryRecvError</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts a <code>RecvError</code> into a <code>RecvTimeoutError</code>.\nReturns the argument unchanged.\nConverts a <code>SendError&lt;T&gt;</code> into a <code>TrySendError&lt;T&gt;</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the channel is empty.\nReturns <code>true</code> if the channel is empty.\nReturns <code>true</code> if the channel is full.\nReturns <code>true</code> if the channel is full.\nReturns an iterator that will block waiting for messages, …\nReturns the number of messages in the channel.\nReturns the number of messages in the channel.\nAttempts to wait for a value on this receiver, returning …\nAttempts to wait for a value on this receiver, returning …\nAttempts to wait for a value on this receiver, returning …\nReturns <code>true</code> if senders belong to the same channel.\nReturns <code>true</code> if receivers belong to the same channel.\nAttempts to send a value on this channel, returning it …\nWaits for a message to be sent into the channel, but only …\nWaits for a message to be sent into the channel, but only …\nCreates a new synchronous, bounded channel.\nReturns an iterator that will attempt to yield all pending …\nAttempts to receive a message from the channel without …\nAttempts to send a message into the channel without …\nThe <strong>channel</strong>’s sending half has become disconnected, and …\nThe <strong>channel</strong>’s sending half has become disconnected, and …\nThis <code>sync_channel</code>’s receiving half has disconnected, so …\nThis <strong>channel</strong> is currently empty, but the <strong>Sender</strong>(s) have …\nThe data could not be sent on the <code>sync_channel</code> because it …\nAn owning iterator over messages on a <code>Receiver</code>, created by …\nAn iterator over messages on a <code>Receiver</code>, created by <code>iter</code>.\nThe receiving half of Rust’s <code>channel</code> (or <code>sync_channel</code>) …\nAn error returned from the <code>recv</code> function on a <code>Receiver</code>.\nThis enumeration is the list of possible errors that made …\nAn error returned from the <code>Sender::send</code> or <code>SyncSender::send</code>\nThe sending-half of Rust’s asynchronous <code>channel</code> type.\nThe sending-half of Rust’s synchronous <code>sync_channel</code> type.\nThis <strong>channel</strong> is currently empty, but the <strong>Sender</strong>(s) have …\nAn iterator that attempts to yield all pending values for …\nThis enumeration is the list of the possible reasons that …\nThis enumeration is the list of the possible error …\nCreates a new asynchronous channel, returning the …\nClone a sender to send to other threads.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns an iterator that will block waiting for messages, …\nAttempts to wait for a value on this receiver, returning …\nAttempts to wait for a value on this receiver, returning …\nAttempts to wait for a value on this receiver, returning …\nAttempts to send a value on this channel, returning it …\nSends a value on this synchronous channel.\nCreates a new synchronous, bounded channel.\nReturns an iterator that will attempt to yield all pending …\nAttempts to return a pending value on this receiver …\nAttempts to send a value on this channel without blocking.\nA Condition Variable\nContains the error value\nContains the error value\nA type alias for the result of a lock method which can be …\nAn RAII mutex guard returned by <code>MutexGuard::map</code>, which can …\nRAII structure used to release the shared read access of a …\nRAII structure used to release the exclusive write access …\nA mutual exclusion primitive useful for protecting shared …\nAn RAII implementation of a “scoped lock” of a mutex. …\nInitialization value for static <code>Once</code> values.\nContains the success value\nContains the success value\nA low-level synchronization primitive for one-time global …\nState yielded to <code>Once::call_once_force()</code>’s closure …\nA type of error which can be returned whenever a lock is …\nThe lock could not be acquired because another thread …\nA reader-writer lock\nRAII structure used to release the shared read access of a …\nRAII structure used to release the exclusive write access …\nAn enumeration of possible errors associated with a …\nA type alias for the result of a nonblocking locking …\nA type indicating whether a timed wait on a condition …\nThe lock could not be acquired at this time because the …\nThe largest value that can be represented by this integer …\nThe smallest value that can be represented by this integer …\nA draining iterator for <code>Vec&lt;T&gt;</code>.\nAn iterator which uses a closure to determine if an …\nAn iterator that moves out of a vector.\nA splicing iterator for <code>Vec</code>.\nA contiguous growable array type, written as <code>Vec&lt;T&gt;</code>, short …\nReturns a reference to the underlying allocator.\nReturns a reference to the underlying allocator.\nReturns a reference to the underlying allocator.\nReturns a reference to the underlying allocator.\nMoves all the elements of <code>other</code> into <code>self</code>, leaving <code>other</code> …\nReturns a raw mutable pointer to the vector’s buffer, or …\nReturns the remaining items of this iterator as a mutable …\nExtracts a mutable slice of the entire vector.\nReturns a <code>NonNull</code> pointer to the vector’s buffer, or a …\nReturns a raw pointer to the vector’s buffer, or a …\nReturns the remaining items of this iterator as a slice.\nReturns the remaining items of this iterator as a slice.\nExtracts a slice containing the entire vector.\nReturns the total number of elements the vector can hold …\nClears the vector, removing all values.\nOverwrites the contents of <code>self</code> with a clone of the …\nRemoves consecutive repeated elements in the vector …\nRemoves all but the first of consecutive elements in the …\nRemoves all but the first of consecutive elements in the …\nCreates an empty <code>vec::IntoIter</code>.\nCreates an empty <code>Vec&lt;T&gt;</code>.\nRemoves the subslice indicated by the given range from the …\nClones and appends all elements in a slice to the <code>Vec</code>.\nGiven a range <code>src</code>, clones a slice of elements in that …\nCreates an iterator which uses a closure to determine if …\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts the given <code>String</code> to a vector <code>Vec</code> that holds …\nReturns the argument unchanged.\nConverts a <code>CString</code> into a Vec&lt;u8&gt;.\nConverts a <code>BinaryHeap&lt;T&gt;</code> into a <code>Vec&lt;T&gt;</code>.\nTurn a <code>VecDeque&lt;T&gt;</code> into a <code>Vec&lt;T&gt;</code>.\nAllocates a <code>Vec&lt;T&gt;</code> and fills it by cloning <code>s</code>’s items.\nAllocates a <code>Vec&lt;T&gt;</code> and fills it by cloning <code>s</code>’s items.\nAllocates a <code>Vec&lt;u8&gt;</code> and fills it with a UTF-8 string.\nConverts a boxed slice into a vector by transferring …\nAllocates a <code>Vec&lt;T&gt;</code> and fills it by cloning <code>s</code>’s items.\nConverts a clone-on-write slice into a vector.\nAllocates a <code>Vec&lt;T&gt;</code> and fills it by cloning <code>s</code>’s items.\nAllocates a <code>Vec&lt;T&gt;</code> and moves <code>s</code>’s items into it.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a <code>Vec&lt;T&gt;</code> directly from a <code>NonNull</code> pointer, a …\nCreates a <code>Vec&lt;T, A&gt;</code> directly from a <code>NonNull</code> pointer, a …\nCreates a <code>Vec&lt;T&gt;</code> directly from a pointer, a length, and a …\nCreates a <code>Vec&lt;T, A&gt;</code> directly from a pointer, a length, a …\nInserts an element at position <code>index</code> within the vector, …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts the vector into <code>Box&lt;[T]&gt;</code>.\nTakes a <code>Vec&lt;[T; N]&gt;</code> and flattens it into a <code>Vec&lt;T&gt;</code>.\nCreates a consuming iterator, that is, one that moves each …\nDecomposes a <code>Vec&lt;T&gt;</code> into its raw components: …\nDecomposes a <code>Vec&lt;T&gt;</code> into its raw components: …\nDecomposes a <code>Vec&lt;T&gt;</code> into its raw components: …\nDecomposes a <code>Vec&lt;T&gt;</code> into its raw components: …\nReturns <code>true</code> if the vector contains no elements.\nKeep unyielded elements in the source <code>Vec</code>.\nConsumes and leaks the <code>Vec</code>, returning a mutable reference …\nReturns the number of elements in the vector, also …\nConstructs a new, empty <code>Vec&lt;T&gt;</code>.\nConstructs a new, empty <code>Vec&lt;T, A&gt;</code>.\nRemoves the last element from a vector and returns it, or …\nRemoves and returns the last element from a vector if the …\nAppends an element to the back of a collection.\nAppends an element if there is sufficient spare capacity, …\nRemoves and returns the element at position <code>index</code> within …\nReserves capacity for at least <code>additional</code> more elements to …\nReserves the minimum capacity for at least <code>additional</code> more …\nResizes the <code>Vec</code> in-place so that <code>len</code> is equal to <code>new_len</code>.\nResizes the <code>Vec</code> in-place so that <code>len</code> is equal to <code>new_len</code>.\nRetains only the elements specified by the predicate.\nRetains only the elements specified by the predicate, …\nForces the length of the vector to <code>new_len</code>.\nShrinks the capacity of the vector with a lower bound.\nShrinks the capacity of the vector as much as possible.\nReturns the remaining spare capacity of the vector as a …\nCreates a splicing iterator that replaces the specified …\nReturns vector content as a slice of <code>T</code>, along with the …\nSplits the collection into two at the given index.\nRemoves an element from the vector and returns it.\nShortens the vector, keeping the first <code>len</code> elements and …\nTries to reserve capacity for at least <code>additional</code> more …\nTries to reserve the minimum capacity for at least …\nConstructs a new, empty <code>Vec&lt;T&gt;</code> with at least the specified …\nConstructs a new, empty <code>Vec&lt;T, A&gt;</code> with at least the …\nConstructs a new, empty <code>Vec&lt;T&gt;</code> with at least the specified …\nConstructs a new, empty <code>Vec&lt;T, A&gt;</code> with at least the …\n“Best effort” zeroization for <code>Vec</code>.")
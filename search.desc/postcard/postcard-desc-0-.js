searchState.loadedDescShard("postcard", 0, "Postcard\nError while processing <code>collect_str</code> during serialization\nFound a bool that wasn’t 0 or 1\nFound an invalid unicode char\nBad CRC while deserializing\nThe original data was not well encoded\nFound an enum discriminant that was &gt; <code>u32::MAX</code>\nFound an Option discriminant that wasn’t 0 or 1\nTried to parse invalid utf-8\nFound a varint that didn’t terminate. Is the usize too …\nHit the end of buffer, expected more data\nA <code>serde</code> compatible deserializer, generic over …\nContains the error value\nThis is the error type used by Postcard\nThis is a feature that postcard intends to support, but …\nContains the success value\nThis is the Result type used by Postcard.\nSerde Deserialization Error\nSerde Serialization Error\nThe serialize buffer is full\nThe length of a sequence must be known\nA <code>serde</code> compatible serializer, generic over “Flavors” …\nThis is a feature that postcard will never implement\nAn accumulator used to collect chunked COBS data and …\nDeserialization Flavors\nExperimental Postcard Features\nReturn the remaining (unused) bytes in the Deserializer …\nFixed Size Integers\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nDeserialize a message of type <code>T</code> from a byte slice. The …\nObtain a Deserializer from a slice of bytes\nDeserialize a message of type <code>T</code> from a cobs-encoded byte …\nObtain a Deserializer from a slice of bytes\nDeserialize a message of type <code>T</code> from a <code>std::io::Read</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis is the Flavor(s) that will be used to modify or store …\nSerialization Flavors\n<code>serialize_with_flavor()</code> has three generic parameters, …\nDeserialize a message of type <code>T</code> from a byte slice. The …\nDeserialize a message of type <code>T</code> from a cobs-encoded byte …\nSerialize a <code>T</code> to an <code>alloc::vec::Vec&lt;u8&gt;</code>.\nSerialize and COBS encode a <code>T</code> to an <code>alloc::vec::Vec&lt;u8&gt;</code>.\nSerialize a <code>T</code> to a <code>core::iter::Extend</code>,\nSerialize a <code>T</code> to a <code>std::io::Write</code>,\nSerialize a <code>T</code> to the given slice, with the resulting slice …\nSerialize a <code>T</code> to the given slice, with the resulting slice …\nSerialize a <code>T</code> to a <code>std::vec::Vec&lt;u8&gt;</code>.\nSerialize and COBS encode a <code>T</code> to a <code>std::vec::Vec&lt;u8&gt;</code>.\nAn accumulator used to collect chunked COBS data and …\nConsumed all data, still pending.\nReached end of chunk, but deserialization failed. Contains …\nThe result of feeding the accumulator.\nBuffer was filled. Contains remaining section of input, if …\nDeserialization complete. Contains deserialized data and …\nAppends data to the internal buffer and attempts to …\nAppends data to the internal buffer and attempts to …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new accumulator.\nDeserialize data.\nRemaining data left in the buffer after deserializing.\nThe deserialization Flavor trait\nThe remaining data of this flavor after deserializing has …\nA simple <code>Flavor</code> representing the deserialization from a …\nThe source of data retrieved for deserialization.\nComplete the deserialization process.\nReturn the remaining (unused) bytes in the Deserializer\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSupport for <code>std::io</code> or <code>embedded-io</code> traits\nCreate a new Slice from the given buffer\nObtain the next byte for deserialization\nReturns the number of bytes remaining in the message, if …\nReturns the number of bytes remaining in the message, if …\nAttempt to take the next <code>ct</code> bytes from the serialized …\nAttempt to take the next <code>ct</code> bytes from the serialized …\nAttempt to take the next <code>ct</code> bytes from the serialized …\nSupport for <code>std::io</code> traits\nWrapper over a <code>std::io::Read</code> and a sliding buffer to …\nReturn the remaining (unused) bytes in the Deserializer\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new <code>IOReader</code> from a reader and a buffer.\nCompute the size of the postcard serialization of <code>T</code>.\nDisables varint serialization/deserialization for the …\nUse with the <code>#[serde(with = &quot;postcard::fixint::le&quot;)]</code> field …\nDeserialize the integer value from a big-endian fixed-size …\nSerialize the integer value as a big-endian fixed-size …\nDeserialize the integer value from a little-endian …\nSerialize the integer value as a little-endian fixed-size …\nThe <code>AllocVec</code> flavor is a wrapper type around an …\nThe <code>Cobs</code> flavor implements Consistent Overhead Byte …\nWrapper over a <code>core::iter::Extend&lt;u8&gt;</code> that implements the …\nThe serialization Flavor trait\nThe <code>Output</code> type is what this storage “resolves” to …\nThe <code>Size</code> flavor is a measurement flavor, which accumulates …\nThe <code>Slice</code> flavor is a storage flavor, storing the …\nThe <code>StdVec</code> flavor is a wrapper type around a <code>std::vec::Vec</code>.\nFinalize the serialization process.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSupport for the <code>std::io</code> traits\nCreate a new <code>Slice</code> flavor from a given backing buffer\nCreate a new <code>Self</code> flavor from a given …\nCreate a new, currently empty, <code>alloc::vec::Vec</code> to be used …\nOverride this method when you want to customize processing …\nOverride this method when you want to customize processing …\nCreate a new Cobs modifier Flavor. If there is …\nPush a single byte to be modified and/or stored.\nWrapper over a <code>std::io::Write</code> that implements the flavor …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new <code>Self</code> flavor from a given <code>std::io::Write</code>")
searchState.loadedDescShard("alloy_primitives", 0, "alloy-primitives\nAn Ethereum address, 20 bytes in length.\nStack-allocated buffer for efficiently computing address …\nError type for address checksum validation.\n20-byte fixed byte-array type.\nNumber of bits.\nNumber of bits to set per input in Ethereum bloom filter.\nSize of the bloom filter in bits\nSize of the bloom filter in bytes.\nThe size of this integer type in bytes. Note that some …\nThe error type that is returned when conversion to or from …\nEthereum 256 byte bloom filter.\nInput to the <code>Bloom::accrue</code> method.\nWrapper type around <code>bytes::Bytes</code> to support “0x” …\nA transaction that calls a contract or transfer.\nA transaction that creates a contract.\nA byte array of fixed length (<code>[u8; N]</code>).\nError converting from bytes.\nError converting hex to bytes.\nAn Ethereum ABI function pointer, 24 bytes in length.\nAlready hashed input.\nError while decoding hex.\nError that occurs when the number is too large or too …\nTrait for an object that can be converted into a log data …\nInvalid ERC-55 checksum.\nInvalid parity.\nk256 error\nA log consists of an address, and some log data.\nAn Ethereum event log object.\nThe maximum value.\nThe minimum value.\nMinus one (multiplicative inverse) of this type.\nLess than zero.\nOne (multiplicative identity) of this type.\nThe error type that is returned when parsing a signed …\nGreater than or equal to zero.\nDeprecated alias for <code>Signature</code>.\nRaw input to be hashed.\nError that occurs when an invalid digit is encountered …\nSealeable objects.\nA consensus hashable item, with its memoized hash.\nEnum to represent the sign of a 256-bit signed integer.\nAn Ethereum ECDSA signature.\nErrors in signature parsing or verification.\nSigned integer wrapping a <code>ruint::Uint</code>.\nThe <code>to</code> field of a transaction. Either a target address, or …\nArray of Zero bytes.\nArray of Zero bytes.\nArray of Zero bytes.\nArray of Zero bytes.\nZero (additive identity) of this type.\nComputes the absolute value of <code>self</code>.\nAccrues the input into the bloom filter.\nAccrues the input into the bloom filter.\nIngests a log into the bloom filter.\nIngests a raw log into the bloom filter.\nThe address which emitted this log.\nConverts a sequence of string literals containing …\nType aliases for common primitive types.\nReturns references to the address and selector of the …\nReturns the byte-array representation of this signature.\nReturns the sign character.\nReturns the ERC-2098 compact representation of this …\nConversion to i16 with overflow checking.\nConversion to i32 with overflow checking.\nConversion to i64 with overflow checking.\nConversion to i8 with overflow checking.\nConversion to isize with overflow checking.\nView the array of limbs.\nReturns a mutable slice containing the entire array. …\nReturns the checksum of a formatted address.\nConverts from <code>&amp;Sealed&lt;T&gt;</code> to <code>Sealed&lt;&amp;T&gt;</code>.\nReturns a slice containing the entire array. Equivalent to …\nReturns the checksum of a formatted address.\nConversion to u16 with overflow checking.\nConversion to u32 with overflow checking.\nConversion to u64 with overflow checking.\nConversion to u8 with overflow checking.\nConversion to usize with overflow checking.\nArithmetic shift left operation. Computes <code>self &lt;&lt; rhs</code>, …\nArithmetic shift right operation. Computes <code>self &gt;&gt; rhs</code> …\nConverts a sequence of string literals containing …\nConverts a sequence of string literals containing …\nConverts a sequence of string literals containing …\nConverts a sequence of string literals containing …\nReturns whether a specific bit is set.\nComputes the bitwise AND of two <code>FixedBytes</code>.\nComputes the bitwise AND of two <code>FixedBytes</code>.\nComputes the bitwise AND of two <code>FixedBytes</code>.\nComputes the bitwise AND of two <code>FixedBytes</code>.\nComputes the bitwise OR of two <code>FixedBytes</code>.\nComputes the bitwise OR of two <code>FixedBytes</code>.\nComputes the bitwise OR of two <code>FixedBytes</code>.\nComputes the bitwise OR of two <code>FixedBytes</code>.\nComputes the bitwise XOR of two <code>FixedBytes</code>.\nComputes the bitwise XOR of two <code>FixedBytes</code>.\nComputes the bitwise XOR of two <code>FixedBytes</code>.\nComputes the bitwise XOR of two <code>FixedBytes</code>.\nReturn the least number of bits needed to represent the …\nConverts a sequence of string literals containing …\nReturns a specific byte. The byte at index <code>0</code> is the least …\nConverts a sequence of string literals containing …\nChecked absolute value. Computes <code>self.abs()</code>, returning <code>None</code>…\nChecked integer addition. Computes <code>self + rhs</code>, returning …\nChecked integer division. Computes <code>self / rhs</code>, returning …\nChecked Euclidean division. Computes <code>self.div_euclid(rhs)</code>, …\nCreates a <code>Signed</code> from an absolute value and a negative …\nChecked integer multiplication. Computes <code>self * rhs</code>, …\nChecked negation. Computes <code>-self</code>, returning <code>None</code> if …\nChecked exponentiation. Computes <code>self.pow(exp)</code>, returning …\nChecked integer remainder. Computes <code>self % rhs</code>, returning …\nChecked Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>…\nChecked shift left. Computes <code>self &lt;&lt; rhs</code>, returning <code>None</code> …\nChecked shift right. Computes <code>self &gt;&gt; rhs</code>, returning <code>None</code> …\nChecked integer subtraction. Computes <code>self - rhs</code>, …\nClone the inner item.\nMaps a <code>Sealed&lt;&amp;T&gt;</code> to a <code>Sealed&lt;T&gt;</code> by cloning the inner …\nConcatenate two <code>FixedBytes</code>.\nCompile-time version of <code>contains</code>.\nReturns <code>true</code> if all bits set in <code>self</code> are also set in <code>b</code>.\nCompile-time equality. NOT constant-time equality.\nCompile-time equality. NOT constant-time equality.\nCompile-time equality. NOT constant-time equality.\nCompile-time equality. NOT constant-time equality.\nCompile-time equality. NOT constant-time equality.\nEquality at compile-time.\nReturns <code>true</code> if no bits are set.\nReturns true if this bloom filter is a possible superset …\nReturns true if this bloom filter is a possible superset …\nTrue if the bloom filter contains a log with given address …\nTrue if the bloom filter contains a log with given address …\nCreates a new <code>Bytes</code> instance from a slice by copying it.\nReturns the number of ones in the binary representation of …\nReturns the number of zeros in the binary representation …\nReturns <code>true</code> if all bits set in <code>b</code> are also set in <code>self</code>.\nReturns <code>true</code> if all bits set in <code>b</code> are also set in <code>self</code>.\nReturns <code>true</code> if all bits set in <code>self</code> are also set in <code>b</code>.\nReturns <code>true</code> if all bits set in <code>b</code> are also set in <code>self</code>.\nComputes the <code>create</code> address for this address and nonce:\nComputes the <code>CREATE2</code> address of a smart contract as …\nComputes the <code>CREATE2</code> address of a smart contract as …\nComputes the address created by the <code>EOFCREATE</code> opcode, …\nReturns a reference to the underlying data.\nThe plain data.\nThe log data.\nReturns a mutable reference to the underlying data.\nDecode an RLP-encoded VRS signature. Accepts <code>decode_parity</code> …\nCalculates the quotient of Euclidean division of <code>self</code> by …\nCreates a new empty log.\nCreates a new empty log.\nCreate <code>10**n</code> as this type.\nConverts a sequence of string literals containing …\nCalculates the checksum of an address into the buffer.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a <code>TxKind::Call</code> with the <code>Some</code> address, <code>None</code> …\nCreates a <code>TxKind::Call</code> with the given address.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstruct a new <code>Signed</code> from the value.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates an Ethereum function from an address and selector.\nConstructs the <code>Signed</code> from digits in the base <code>base</code> in …\nConverts a big-endian byte array of size exactly …\nParses a signature from a byte slice, with a v value\nConvert from a decimal string.\nDecode the signature from the ERC-2098 compact …\nConvert from a hex string.\nConvert from an array in LE format\nConstruct a new integer from little-endian a array of …\nConverts an ECDSA signing key to its corresponding …\nConverts an ECDSA verifying key to its corresponding …\nCoerces an unsigned integer into a signed one. If the …\nParses a 65-byte long raw signature.\nParses a 65-byte long raw signature.\nInstantiate by hashing public key bytes.\nCreates a <code>Signature</code> from the serialized <code>r</code> and <code>s</code> scalar …\nInstantiate from a signature and recovery id\nCreate a new byte array from the given slice <code>src</code>.\nCreate a new byte array from the given slice <code>src</code>.\nCreate a new <code>FixedBytes</code> from the given slice <code>src</code>.\nCreate a new byte array from the given slice <code>src</code>.\nCreates a new <code>Bytes</code> from a static slice.\nCreates an Ethereum address from an EVM word’s upper 20 …\nCreates an Ethereum function from an EVM word’s lower 24 …\nGet the hash.\nGet the hash.\nCalculate the seal hash, this may be slow.\nMacro for converting sequence of string literals …\nGet the inner item.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the inner bytes array.\nReturns the inner bytes array.\nReturns the inner bytes array.\nConsume the input, converting it to the hash.\nReturns the backing buffer.\nUnseal the inner item, discarding the hash.\nReturns the inner ECDSA signature.\nConvert to a array of limbs.\nConsume and convert into a <code>LogData</code> object.\nDecompose into parts.\nReturns the signed integer as a unsigned integer. If the …\nSplits a Signed into its absolute value and negative flag.\nConsumes the type and returns the address of the contract …\nLeft-pads the address to 32 bytes (EVM word size).\nRight-pads the function to 32 bytes (EVM word size).\nReturns true if the transaction is a contract call.\nReturns true if the transaction is a contract creation.\nReturns <code>true</code> if <code>self</code> is negative and <code>false</code> if the number …\nReturns whether the sign is negative.\nDetermines if the integer is odd.\nReturns <code>true</code> if <code>self</code> is positive and <code>false</code> if the number …\nReturns whether the sign is positive.\nTrue if valid, false otherwise.\nReturns <code>true</code> if no bits are set.\nReturns <code>true</code> if <code>self</code> is zero and <code>false</code> if the number is …\nReturns the number of leading zeros in the binary …\nCreate a new byte array from the given slice <code>src</code>, …\nCreate a new byte array from the given slice <code>src</code>, …\nCreate a new <code>FixedBytes</code> from the given slice <code>src</code>, …\nCreate a new byte array from the given slice <code>src</code>, …\nReturns the size of this array in bytes.\nReturns the size of this array in bytes.\nReturns the size of this byte array (<code>N</code>).\nReturns the size of this array in bytes.\nCompute the logs bloom filter for the given logs.\nLow word.\nLow word.\nLow word.\nLow word.\nLow word.\nLow word.\nLow word.\nLow word.\nLow word.\nLow word.\nSpecialised Bloom filter that sets three bits out of 2048, …\n<code>m3_2048</code> but with a pre-hashed input.\nRe-exports of map types and utilities.\nWraps the given byte array in this type.\nCreates a new buffer.\nWraps the given byte array in this type.\nWraps the given byte array in <code>FixedBytes</code>.\nWraps the given byte array in this type.\nCreates a new empty <code>Bytes</code>.\nCreates a new log.\nCreates a new log.\nSeal the inner item.\nInstantiate a new signature from <code>r</code>, <code>s</code>, and <code>v</code> values.\nCreates a new log from an deserialized event.\nCreates a new log.\nSeal the inner item, by reference.\nSeal a reference to the inner item with some function.\nCreates a new log, without length-checking. This allows …\nCreates a new log.\nInstantiate without performing the hash. This should be …\nSeal the inner item with some function.\nNormalizes the signature into “low S” form as …\nAttempts to normalize the v value to a boolean parity …\nNormalizes the signature into “low S” form as …\nComputes the absolute value of <code>self</code>.\nCalculates <code>self</code> + <code>rhs</code>\nCalculates <code>self</code> / <code>rhs</code>\nCalculates the quotient of Euclidean division …\nCreates a <code>Signed</code> from a sign and an absolute value. …\nCalculates <code>self</code> * <code>rhs</code>\nNegates self, overflowing if this is equal to the minimum …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nCalculates <code>self</code> % <code>rhs</code>\nOverflowing Euclidean remainder. Calculates …\nShifts self left by <code>rhs</code> bits.\nShifts self right by <code>rhs</code> bits.\nCalculates <code>self</code> - <code>rhs</code>\nParse an Ethereum address, verifying its EIP-55 checksum.\nRaises self to the power of <code>exp</code>, using exponentiation by …\nReturns the <code>r</code> component of this signature.\nReturns the recovery ID.\nRecovers an <code>Address</code> from this signature and the given …\nRecovers an <code>Address</code> from this signature and the given …\nRecovers a <code>VerifyingKey</code> from this signature and the given …\nRecovers a <code>VerifyingKey</code> from this signature and the given …\nCalculates the least nonnegative remainder of …\nCreates a new byte array where all bytes are set to <code>byte</code>.\nCreates a new byte array where all bytes are set to <code>byte</code>.\nCreates a new <code>FixedBytes</code> where all bytes are set to <code>byte</code>.\nCreates a new byte array where all bytes are set to <code>byte</code>.\nReserialize the data.\nCreate a new byte array from the given slice <code>src</code>, …\nCreate a new byte array from the given slice <code>src</code>, …\nCreate a new <code>FixedBytes</code> from the given slice <code>src</code>, …\nCreate a new byte array from the given slice <code>src</code>, …\nLength of RLP RS field encoding\nReturns the <code>s</code> component of this signature.\nSaturating absolute value. Computes <code>self.abs()</code>, returning …\nSaturating integer addition. Computes <code>self + rhs</code>, …\nSaturating integer division. Computes <code>self / rhs</code>, …\nSaturating integer multiplication. Computes <code>self * rhs</code>, …\nSaturating negation. Computes <code>-self</code>, returning <code>MAX</code> if …\nSaturating integer exponentiation. Computes <code>self.pow(exp)</code>, …\nSaturating integer subtraction. Computes <code>self - rhs</code>, …\nGet the hash.\nSeal a borrowed object by calculating the hash. This may …\nSeal a borrowed object by calculating the hash. This may …\nInstantiate an unchecked seal. This should be used with …\nInstantiate an unchecked seal. This should be used with …\nSeal the object by calculating the hash. This may be slow.\nSeal the object by calculating the hash. This may be slow.\nInstantiate an unchecked seal. This should be used with …\nInstantiate an unchecked seal. This should be used with …\nSet the topic list, truncating to 4 topics.\nSet the topic list, without length-checking. This allows …\nReturns the sign of self.\nCalculates a heuristic for the in-memory size of this …\nReturns a slice of self for the provided range.\nReturns a slice of self that is equivalent to the given …\nConsumes the log data, returning the topic list and the …\nDecompose into parts. Alias for <code>Self::into_parts</code>.\nSplits the bytes into two at the given index.\nSplits the bytes into two at the given index.\nReturns the address of the contract that will be called or …\nPanics\nReturns the address and selector of the function.\nConverts <code>self</code> to a big-endian byte array of size exactly …\nEncodes an Ethereum address to its EIP-55 checksum into a …\nEncodes an Ethereum address to its EIP-55 checksum into a …\nEncodes an Ethereum address to its EIP-55 checksum into …\nConvert to a decimal string.\nApplies EIP-155.\nConvert to a hex string.\nReturns the inner ECDSA signature.\nConverts <code>self</code> to a little-endian byte array of size exactly\nConvert into a <code>LogData</code> object.\nReturns the checksum of a formatted address.\nGet the topic list.\nGet the topic list, mutably. This gives access to the …\nGet a mutable reference to the topic list. This allows …\nReturns the number of leading ones in the binary …\nReturns the number of leading zeros in the binary …\nParses a 65-byte long raw signature.\nCreates a new integer from a big endian slice of bytes.\nCreates a new integer from a little endian slice of bytes.\nTries to create a <code>Vec</code> containing the arguments.\nCompute the two’s complement of this number.\nShortcut for <code>val.try_into().unwrap()</code>.\nShortcut for <code>self.try_into().unwrap()</code>.\nUnseal the inner item, discarding the hash. Alias for …\nComputes the absolute value of <code>self</code> without any wrapping …\nCommon Ethereum utilities.\nReturns the recovery ID as a <code>bool</code>.\nCreates a new byte array with the last byte set to <code>x</code>.\nCreates a new byte array with the last byte set to <code>x</code>.\nCreates a new <code>FixedBytes</code> with the last byte set to <code>x</code>.\nCreates a new byte array with the last byte set to <code>x</code>.\nSets the recovery ID by normalizing a <code>v</code> value.\nWrap a fixed-size byte array in a newtype, delegating all …\nWrapping absolute value. Computes <code>self.abs()</code>, wrapping …\nWrapping (modular) addition. Computes <code>self + rhs</code>, wrapping …\nWrapping (modular) division. Computes <code>self / rhs</code>, wrapping …\nWrapping Euclidean division. Computes <code>self.div_euclid(rhs)</code>,\nWrapping (modular) multiplication. Computes <code>self * rhs</code>, …\nWrapping (modular) negation. Computes <code>-self</code>, wrapping …\nRaises self to the power of <code>exp</code>, wrapping around at the …\nWrapping (modular) remainder. Computes <code>self % rhs</code>, …\nWrapping Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>…\nWrapping shift left. Computes <code>self &lt;&lt; rhs</code>, returning 0 if …\nWrapping shift right. Computes <code>self &gt;&gt; rhs</code>, returning 0 if …\nWrapping (modular) subtraction. Computes <code>self - rhs</code>, …\nWrite R and S to an RLP buffer in progress.\nWrite the VRS to the output.\n128-byte fixed byte-array type.\n16-byte fixed byte-array type.\n2-byte fixed byte-array type.\n24-byte fixed byte-array type.\n256-byte fixed byte-array type.\n28-byte fixed byte-array type.\n32-byte fixed byte-array type.\n4-byte fixed byte-array type.\n64-byte fixed byte-array type.\n8-byte fixed byte-array type.\n1-byte fixed byte-array type.\n12-byte fixed byte-array type.\nA block hash.\nA block number.\nA block timestamp.\nChain identifier type (introduced in EIP-155).\nThe 0-bit signed integer type, capable of representing 0.\nThe 1-bit signed integer type, capable of representing 0 …\n104-bit signed integer type, consisting of 2, 64-bit limbs.\n112-bit signed integer type, consisting of 2, 64-bit limbs.\n120-bit signed integer type, consisting of 2, 64-bit limbs.\n128-bit signed integer type, consisting of 2, 64-bit limbs.\n136-bit signed integer type, consisting of 3, 64-bit limbs.\n144-bit signed integer type, consisting of 3, 64-bit limbs.\n152-bit signed integer type, consisting of 3, 64-bit limbs.\n16-bit signed integer type, consisting of 1, 64-bit limbs.\n160-bit signed integer type, consisting of 3, 64-bit limbs.\n168-bit signed integer type, consisting of 3, 64-bit limbs.\n176-bit signed integer type, consisting of 3, 64-bit limbs.\n184-bit signed integer type, consisting of 3, 64-bit limbs.\n192-bit signed integer type, consisting of 3, 64-bit limbs.\n200-bit signed integer type, consisting of 4, 64-bit limbs.\n208-bit signed integer type, consisting of 4, 64-bit limbs.\n216-bit signed integer type, consisting of 4, 64-bit limbs.\n224-bit signed integer type, consisting of 4, 64-bit limbs.\n232-bit signed integer type, consisting of 4, 64-bit limbs.\n24-bit signed integer type, consisting of 1, 64-bit limbs.\n240-bit signed integer type, consisting of 4, 64-bit limbs.\n248-bit signed integer type, consisting of 4, 64-bit limbs.\n256-bit signed integer type, consisting of 4, 64-bit limbs.\n32-bit signed integer type, consisting of 1, 64-bit limbs.\n40-bit signed integer type, consisting of 1, 64-bit limbs.\n48-bit signed integer type, consisting of 1, 64-bit limbs.\n512-bit signed integer type, consisting of 8, 64-bit limbs.\n56-bit signed integer type, consisting of 1, 64-bit limbs.\n64-bit signed integer type, consisting of 1, 64-bit limbs.\n72-bit signed integer type, consisting of 2, 64-bit limbs.\n8-bit signed integer type, consisting of 1, 64-bit limbs.\n80-bit signed integer type, consisting of 2, 64-bit limbs.\n88-bit signed integer type, consisting of 2, 64-bit limbs.\n96-bit signed integer type, consisting of 2, 64-bit limbs.\nSolidity contract functions are addressed using the first …\nAn account storage key.\nAn account storage value.\nA transaction hash is a keccak hash of an RLP encoded …\nThe index of transaction in a block.\nThe nonce of a transaction.\nThe sequence number of all existing transactions.\n<code>Uint</code> for <code>0</code> bits. Always zero. Similar to <code>()</code>.\n<code>Uint</code> for <code>1</code> bit. Similar to <code>bool</code>.\n<code>Uint</code> for <code>1024</code> bits.\n104-bit unsigned integer type, consisting of 2, 64-bit …\n112-bit unsigned integer type, consisting of 2, 64-bit …\n120-bit unsigned integer type, consisting of 2, 64-bit …\n128-bit unsigned integer type, consisting of 2, 64-bit …\n136-bit unsigned integer type, consisting of 3, 64-bit …\n144-bit unsigned integer type, consisting of 3, 64-bit …\n152-bit unsigned integer type, consisting of 3, 64-bit …\n16-bit unsigned integer type, consisting of 1, 64-bit …\n160-bit unsigned integer type, consisting of 3, 64-bit …\n168-bit unsigned integer type, consisting of 3, 64-bit …\n176-bit unsigned integer type, consisting of 3, 64-bit …\n184-bit unsigned integer type, consisting of 3, 64-bit …\n192-bit unsigned integer type, consisting of 3, 64-bit …\n200-bit unsigned integer type, consisting of 4, 64-bit …\n<code>Uint</code> for <code>2048</code> bits.\n208-bit unsigned integer type, consisting of 4, 64-bit …\n216-bit unsigned integer type, consisting of 4, 64-bit …\n224-bit unsigned integer type, consisting of 4, 64-bit …\n232-bit unsigned integer type, consisting of 4, 64-bit …\n24-bit unsigned integer type, consisting of 1, 64-bit …\n240-bit unsigned integer type, consisting of 4, 64-bit …\n248-bit unsigned integer type, consisting of 4, 64-bit …\n256-bit unsigned integer type, consisting of 4, 64-bit …\n32-bit unsigned integer type, consisting of 1, 64-bit …\n<code>Uint</code> for <code>320</code> bits.\n<code>Uint</code> for <code>384</code> bits.\n40-bit unsigned integer type, consisting of 1, 64-bit …\n<code>Uint</code> for <code>4096</code> bits.\n<code>Uint</code> for <code>448</code> bits.\n48-bit unsigned integer type, consisting of 1, 64-bit …\n512-bit unsigned integer type, consisting of 8, 64-bit …\n56-bit unsigned integer type, consisting of 1, 64-bit …\n64-bit unsigned integer type, consisting of 1, 64-bit …\n72-bit unsigned integer type, consisting of 2, 64-bit …\n8-bit unsigned integer type, consisting of 1, 64-bit limbs.\n80-bit unsigned integer type, consisting of 2, 64-bit …\n88-bit unsigned integer type, consisting of 2, 64-bit …\n96-bit unsigned integer type, consisting of 2, 64-bit …\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\n<code>HashMap</code> optimized for hashing <code>Address</code>.\n<code>HashSet</code> optimized for hashing <code>Address</code>.\n<code>HashMap</code> optimized for hashing <code>B256</code>.\n<code>HashSet</code> optimized for hashing <code>B256</code>.\nThe default <code>BuildHasher</code> used by <code>HashMap</code> and <code>HashSet</code>.\nThe default <code>Hasher</code> used by <code>HashMap</code> and <code>HashSet</code>.\n<code>BuildHasher</code> optimized for hashing fixed-size byte arrays.\n<code>Hasher</code> optimized for hashing fixed-size byte arrays.\n<code>HashMap</code> optimized for hashing fixed-size byte arrays.\n<code>HashSet</code> optimized for hashing fixed-size byte arrays.\nA <code>HashMap</code> using the default hasher.\nA <code>HashSet</code> using the default hasher.\n<code>HashMap</code> optimized for hashing <code>Selector</code>.\n<code>HashSet</code> optimized for hashing <code>Selector</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nUse comma as decimal separator\nDecimal separator for number formatting\nThe prefix used for hashing messages according to EIP-191.\nEther is equivalent to 1e18 wei.\nGwei is equivalent to 1e9 wei.\nSigned 256-bit integer.\nThe provided units are not recognized.\nThe Keccak-256 hash of the empty string <code>&quot;&quot;</code>.\nKwei is equivalent to 1e3 wei.\nSimple <code>Keccak-256</code> hasher.\nThe largest unit.\nThe smallest unit.\nMwei is equivalent to 1e6 wei.\nPwei is equivalent to 1e15 wei.\nOverflow when parsing a signed number.\nThis enum holds the numeric types that a possible to be …\nUse period as decimal separator\nTwei is equivalent to 1e12 wei.\nUnsigned 256-bit integer.\nEthereum unit. Always less than <code>77</code>.\nError type for <code>Unit</code>-related operations.\nWei is equivalent to 1 wei.\nAllocates memory on the heap then places <code>x</code> into it, …\nConstructs a new box with uninitialized contents on the …\nHash a message according to EIP-191 (version <code>0x01</code>).\nConstructs a message according to EIP-191 (version <code>0x01</code>).\nPad and squeeze the state.\nPad and squeeze the state into <code>output</code>.\nPad and squeeze the state into <code>output</code>.\nPad and squeeze the state into <code>output</code>.\nFormats the given number of Wei as an Ether amount.\nFormats the given number of Wei as the given unit.\nFormats the given number of Wei as the given unit.\nFormats the given number of Wei as the given unit with a …\nFormats the given number of Wei as the given unit.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the numeric value of the unit.\nReturns the absolute value of the number.\nReturns the signed value of the number.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the number is negative.\nReturns <code>true</code> if the number is positive.\nReturns <code>true</code> if the number is signed.\nReturns <code>true</code> if the number is unsigned.\nReturns <code>true</code> if the number is zero.\nSimple interface to the <code>Keccak-256</code> hash function.\nCreates a new <code>Unit</code> instance, checking for overflow.\nCreates a new <code>Keccak256</code> hasher.\nCreates a new <code>Unit</code> instance.\nConverts the input to a U256 and converts from Ether to …\nParses a decimal number and multiplies it with 10^units.\nParses a decimal number and multiplies it with 10^units.\nReturns the character used as decimal separator\nTries to collect the elements of an iterator into a <code>Vec</code>.\nAbsorbs additional input. Can be called multiple times.\nTries to create a <code>Vec</code> with the given capacity.\nReturns <code>10^self</code>, which is the number of Wei in this unit.\nReturns <code>10^self</code>, which is the number of Wei in this unit.")
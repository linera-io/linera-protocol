searchState.loadedDescShard("ark_ff", 0, "This crate defines Finite Field traits and useful …\nConstruct a <code>BigInt&lt;N&gt;</code> element from a literal string.\nIterates over a slice of <code>u64</code> in <em>big-endian</em> order.\nIterates over a slice of <code>u64</code> in <em>little-endian</em> order.\nConstruct a <code>Fp&lt;MontBackend&lt;T, N&gt;, N&gt;</code> element from a …\nTypes that can be converted to a vector of <code>F</code> elements. …\nA helper macro for emulating <code>for</code> loops in a <code>const</code> context.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstruct an iterator that automatically skips any leading …\nConstruct an iterator that automatically skips any …\nThis defines a <code>BigInteger</code>, a smart wrapper around a …\nNumber of 64-bit limbs representing <code>Self</code>.\nAdd another <code>BigInteger</code> to <code>self</code>. This method stores the …\nPerforms a rightwise bitshift of this number, effectively …\nPerforms a rightwise bitshift of this number by some …\nReturns the windowed non-adjacent form of <code>self</code>, for a …\nReturns the argument unchanged.\nReturns the big integer representation of a given big …\nReturns the big integer representation of a given little …\nCompute the <code>i</code>-th bit of <code>self</code>.\nCalls <code>U::from(self)</code>.\nReturns true iff this number is even.\nReturns true iff this number is odd.\nReturns true iff this number is zero.\nMultiplies this <code>BigInteger</code> by another <code>BigInteger</code>, …\nPerforms a leftwise bitshift of this number, effectively …\nMultiplies this <code>BigInteger</code> by another <code>BigInteger</code>, …\nMultiplies this <code>BigInteger</code> by another <code>BigInteger</code>, storing …\nPerforms a leftwise bitshift of this number by n bits, …\nCompute the minimum number of bits needed to encode this …\nComputes the bitwise shift left operation in place.\nComputes the bitwise shift left operation in place.\nComputes bitwise shift right operation.\nComputes the bitwise shift right operation in place.\nCompute the signed modulo operation on a u64 …\nSubtract another <code>BigInteger</code> from this one. This method …\nReturns the bit representation in a big endian boolean …\nReturns the bit representation in a little endian boolean …\nReturns the byte representation in a big endian byte array,\nReturns the byte representation in a little endian byte …\nReturns <code>Err(())</code> if the bit size of <code>val</code> is more than <code>N * 64</code>.\nCompute the NAF (non-adjacent form) of num\nWe define relaxed NAF as a variant of NAF with a very …\nA <code>BigInteger</code> type that can represent elements of this …\nTo be used when the modulus is 3 mod 4.\nFields that have a cyclotomic multiplicative subgroup, and …\nThe interface for fields that are able to be used in FFTs.\nThe interface for a generic field. Types implementing <code>Field</code>…\nThe generator of the multiplicative group of the field\nIs the inverse fast to compute? For example, in quadratic …\nIs the inverse fast to compute? For example, in quadratic …\nGENERATOR^((MODULUS-1) / (2^s * …\nGENERATOR^((MODULUS-1) / (2^s * …\nIndication of the field element’s quadratic residuosity\nThe modulus <code>p</code>.\nThe size of the modulus in bits.\nThe value <code>(p - 1)/ 2</code>.\nThe multiplicative identity of the field.\nDefines a multiplicative identity element for <code>Self</code>.\nThe interface for a prime field, i.e. the field of …\nAn integer <code>b</code> such that there exists a multiplicative …\nAn integer <code>b</code> such that there exists a multiplicative …\nThe integer <code>k</code> such that there exists a multiplicative …\nThe integer <code>k</code> such that there exists a multiplicative …\nDetermines the algorithm for computing square roots.\nPrecomputation that makes computing square roots faster A …\nThe trace of the field is defined as the smallest integer <code>t</code>…\nThe value <code>(t - 1)/ 2</code>.\nLet <code>N</code> be the size of the multiplicative group defined by …\n2^s root of unity computed by GENERATOR^t\nThe additive identity of the field.\nDefines an additive identity element for <code>Self</code>.\nReturns the characteristic of the field, in little-endian …\nCompute a cyclotomic exponentiation of <code>self</code> with respect …\nCompute a cyclotomic exponentiation of <code>self</code> with respect …\nSet <code>self</code> to be the result of exponentiating <code>self</code> by <code>e</code>, …\nSet <code>self</code> to be the result of exponentiating <code>self</code> by <code>e</code>, …\nCompute the inverse of <code>self</code>. See <code>Self::INVERSE_IS_FAST</code> for …\nCompute the inverse of <code>self</code>. See <code>Self::INVERSE_IS_FAST</code> for …\nCompute the inverse of <code>self</code>. See <code>Self::INVERSE_IS_FAST</code> for …\nCompute the inverse of <code>self</code>. See <code>Self::INVERSE_IS_FAST</code> for …\nCompute a square in the cyclotomic subgroup. By default …\nCompute a square in the cyclotomic subgroup. By default …\nSquare <code>self</code> in place. By default this is computed using …\nSquare <code>self</code> in place. By default this is computed using …\nDoubles <code>self</code>.\nDoubles <code>self</code> in place.\nReturns the extension degree of this field with respect to …\nReturns <code>self^s</code>, where …\nSets <code>self</code> to <code>self^s</code>, where …\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstructs a field element from a single base prime field …\nConvert a slice of base prime field elements into a field …\nReads bytes in big-endian, and converts them to a field …\nReads bytes in big-endian, and converts them to a field …\nConstruct a prime field element from an integer in the …\nReads bytes in little-endian, and converts them to a field …\nReads bytes in little-endian, and converts them to a field …\nAttempt to deserialize a field element. Returns <code>None</code> if the\nAttempt to deserialize a field element, splitting the …\nReturns the root of unity of order n, if one exists. If no …\nReturns the root of unity of order n, if one exists. If no …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts an element of the prime field into an integer in …\nComputes the multiplicative inverse of <code>self</code> if <code>self</code> is …\nIf <code>self.inverse().is_none()</code>, this just returns <code>None</code>. …\nReturns <code>true</code> if <code>self</code> is equal to the multiplicative …\nReturns <code>true</code> if <code>self</code> is equal to the multiplicative …\nReturns true if <code>self</code> is a quadratic non-residue.\nReturns true if <code>self</code> is a quadratic residue.\nReturns <code>true</code> if <code>self</code> is equal to the additive identity.\nReturns true if <code>self.is_zero()</code>.\nReturns a <code>LegendreSymbol</code>, which indicates whether this …\nNegates <code>self</code> in place.\nReturns the multiplicative identity element of <code>Self</code>, <code>1</code>.\nReturns <code>self^exp</code>, where <code>exp</code> is an integer represented with …\nExponentiates a field element <code>f</code> by a number represented …\nSets <code>self</code> to the multiplicative identity element of <code>Self</code>, <code>1</code>…\nSets <code>self</code> to the multiplicative identity element of <code>Self</code>, <code>1</code>…\nSets <code>self</code> to the additive identity element of <code>Self</code>, <code>0</code>.\nSets <code>self</code> to the additive identity element of <code>Self</code>, <code>0</code>.\nReturns the square root of self, if it exists.\nSets <code>self</code> to be the square root of <code>self</code>, if it exists.\nReturns <code>self * self</code>.\nSquares <code>self</code> in place.\nReturns <code>sum([a_i * b_i])</code>.\nReturns the additive identity element of <code>Self</code>, <code>0</code>.\nThis field hasher constructs a Hash-To-Field based on a …\nTrait for hashing messages to field elements.\nReturns the argument unchanged.\nHash an arbitrary <code>msg</code> to <code>N</code> elements of the field <code>F</code>.\nCalls <code>U::from(self)</code>.\nInitialises a new hash-to-field helper struct.\nThe base field that this field is a cubic extension of.\nThe prime field that this cubic extension is eventually an …\nDefines a Cubic extension field from a cubic non-residue.\nAn element of a cubic extension field F_p[X]/(X^3 - …\nThe degree of the extension over the base prime field.\nCoefficients for the Frobenius automorphism.\nThe type of the coefficients for an efficient …\nThe cubic non-residue used to construct the extension.\nDetermines the algorithm for computing square roots.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the Legendre symbol.\nIn-place multiply all coefficients <code>c0</code>, <code>c1</code>, and <code>c2</code> of <code>self</code> …\nA specializable method for multiplying an element of the …\nA defaulted method for multiplying an element of the base …\nA specializable method for multiplying an element of the …\nCreate a new field element from coefficients <code>c0</code>, <code>c1</code> and <code>c2</code> …\nCalculate the norm of an element with respect to the base …\nRepresents an element of the prime field F_p, where …\nA trait that specifies the configuration of a prime field. …\nA multiplicative generator of the field. <code>Self::GENERATOR</code> …\nA multiplicative generator of the field. <code>Self::GENERATOR</code> …\nINV = -MODULUS^{-1} mod 2^64\nINV = -MODULUS^{-1} mod 2^64\nGENERATOR^((MODULUS-1) / (2^s * …\nGENERATOR^((MODULUS-1) / (2^s * …\nGENERATOR^((MODULUS-1) / (2^s * …\nThe modulus of the field.\nThe modulus of the field.\nA trait that specifies the constants and arithmetic …\nDerive the <code>MontConfig</code> trait.\nConstruct a <code>Fp&lt;MontBackend&lt;T, N&gt;, N&gt;</code> element from a …\nConstruct a <code>Fp&lt;MontBackend&lt;T, N&gt;, N&gt;</code> element from a …\nMultiplicative identity of the field, i.e. the element <code>e</code> …\nLet <code>M</code> be the power of 2^64 nearest to <code>Self::MODULUS_BITS</code>. …\nLet <code>M</code> be the power of 2^64 nearest to <code>Self::MODULUS_BITS</code>. …\nR2 = R^2 % Self::MODULUS\nR2 = R^2 % Self::MODULUS\nAn integer <code>b</code> such that there exists a multiplicative …\nAn integer <code>b</code> such that there exists a multiplicative …\nAn integer <code>b</code> such that there exists a multiplicative …\nThe integer <code>k</code> such that there exists a multiplicative …\nThe integer <code>k</code> such that there exists a multiplicative …\nThe integer <code>k</code> such that there exists a multiplicative …\nPrecomputed material for use when computing square roots. …\nPrecomputed material for use when computing square roots. …\nPrecomputed material for use when computing square roots. …\nLet <code>N</code> be the size of the multiplicative group defined by …\n2^s root of unity computed by GENERATOR^t\n2^s root of unity computed by GENERATOR^t\nAdditive identity of the field, i.e. the element <code>e</code> such …\nSet a += b.\nSets <code>a = a + b</code>.\nSets <code>a = a + b</code>.\nReturns <code>self * other.inverse()</code> if <code>other.inverse()</code> is <code>Some</code>, …\nSet a = a + a.\nSets <code>a = 2 * a</code>.\nSets <code>a = 2 * a</code>.\nThe Frobenius map has no effect in a prime field.\nReturns the argument unchanged.\nConverts <code>Self::BigInteger</code> into <code>Self</code>\nReturns the argument unchanged.\nConstruct a field element from an integer in the range …\nInterpret a string of numbers as a (congruent) prime field …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert a field element to an integer in the range …\nCompute -M^{-1} mod 2^64.\nCompute a^{-1} if <code>a</code> is not zero.\nSet a *= b.\nThis modular multiplication algorithm uses Montgomery …\nThis modular multiplication algorithm uses Montgomery …\nThis modular multiplication algorithm uses Montgomery …\nFp is already a “BasePrimeField”, so it’s just mul …\nSet a = -a;\nSets <code>a = -a</code>.\nSets <code>a = -a</code>.\nConstruct a new field element from its underlying <code>BigInt</code> …\nConstruct a new field element from its underlying <code>BigInt</code> …\nSet a *= a.\nSet a -= b.\nSets <code>a = a - b</code>.\nSets <code>a = a - b</code>.\nCompute the inner product <code>&lt;a, b&gt;</code>.\nCoefficients for the Frobenius automorphism.\nThis <em>must</em> equal (0, 1, 0); see [DESD06, Section 6.1].\nCoefficient <code>c0</code> in the representation of the field element …\nCoefficient <code>c1</code> in the representation of the field element …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nMultiply by quadratic nonresidue v.\nCoefficients for the Frobenius automorphism.\nBase prime field underlying this extension.\nAlias for instances of quadratic extension fields. Helpful …\nTrait that specifies constants and methods for defining …\nWrapper for <code>Fp2Config</code>, allowing combination of the …\nQuadratic non-residue in <code>Self::Fp</code> used to construct the …\nCoefficient <code>c0</code> in the representation of the field element …\nCoefficient <code>c1</code> in the representation of the field element …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIn-place multiply both coefficients <code>c0</code> and <code>c1</code> of <code>self</code> by …\nA specializable method for setting <code>y = x + NONRESIDUE * y</code>. …\nReturn <code>fe * Self::NONRESIDUE</code>. Intended for specialization …\nA specializable method for computing x + …\nA specializable method for computing x - …\nBase prime field underlying this extension.\nTrait that specifies constants and methods for defining …\nWrapper for <code>Fp3Config</code>, allowing combination of the …\nCubic non-residue in <code>Self::Fp</code> used to construct the …\nt-th power of a quadratic nonresidue in Fp3.\np^3 - 1 = 2^s * t, where t is odd.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIn-place multiply all coefficients <code>c0</code>, <code>c1</code>, and <code>c2</code> of <code>self</code> …\nReturn <code>fe * Self::NONRESIDUE</code>. The default implementation …\nCoefficients for the Frobenius automorphism. …\nThis <em>must</em> equal (0, 1); see [DESD06, Section 5.1].\nCoefficient <code>c0</code> in the representation of the field element …\nCoefficient <code>c1</code> in the representation of the field element …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCoefficients for the Frobenius automorphism.\nCoefficient <code>c0</code> in the representation of the field element …\nCoefficient <code>c1</code> in the representation of the field element …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCoefficients for the Frobenius automorphism.\nDetermines the algorithm for computing square roots.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe base field that this field is a quadratic extension of.\nThe prime field that this quadratic extension is …\nThe degree of the extension over the base prime field.\nCoefficients for the Frobenius automorphism.\nThe type of the coefficients for an efficient …\nThe quadratic non-residue used to construct the extension.\nDefines a Quadratic extension field from a quadratic …\nAn element of a quadratic extension field F_p[X]/(X^2 - …\nCoefficient <code>c0</code> in the representation of the field element …\nCoefficient <code>c1</code> in the representation of the field element …\nThis is only to be used when the element is <em>known</em> to be in …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIn-place multiply both coefficients <code>c0</code> &amp; <code>c1</code> of the …\nIn-place multiply both coefficients <code>c0</code> and <code>c1</code> of <code>self</code> by …\nA specializable method for multiplying an element of the …\nA specializable method for setting <code>y = x + NONRESIDUE * y</code>. …\nA specializable method for multiplying an element of the …\nA specializable method for computing x + …\nCreate a new field element from coefficients <code>c0</code> and <code>c1</code>, so …\nNorm of QuadExtField over <code>P::BaseField</code>:…\nA specializable method for computing x - …\nCalculates the k-adicity of n, i.e., the number of …\nDefines a multiplicative identity element for <code>Self</code>.\nDefines an additive identity element for <code>Self</code>.\nReturns <code>true</code> if <code>self</code> is equal to the additive identity.\nReturns the multiplicative identity element of <code>Self</code>, <code>1</code>.\nReturns the additive identity element of <code>Self</code>, <code>0</code>.")
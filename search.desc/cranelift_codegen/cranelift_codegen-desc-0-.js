searchState.loadedDescShard("cranelift_codegen", 0, "Cranelift code generation library.\nThe ABI machine spec for this <code>MachInst</code>.\nOffset from the Canonical Frame Address (aka CFA).\nOut-of-line data for calls, to keep the size of <code>Inst</code> down.\nThe code size for the function is too large.\nA compilation error.\nA convenient alias for a <code>Result</code> that uses <code>CodegenError</code> as …\nCompilation error, with the accompanying function to help …\n<code>CompiledCode</code> in its final form (i.e. after …\nPersistent data structures and compilation pipeline.\nContains the error value\nPoints to an ExternalName outside the current function.\nTarget of relocation could be anywhere in the address …\nStatus of a compiled artifact ready to use.\nA relocation resulting from a compilation.\nA Relocation target\nPoints to a CodeOffset from the start of the current …\nA constant value generated during lowering; the value may …\nAn implementation limit was exceeded.\nConstant information used in <code>emit</code> invocations.\nA label-use kind: a type that describes the types of label …\nThe particular location for a value.\nA buffer of output to be produced, fixed up, and then …\nA <code>MachBuffer</code> once emission is completed: holds generated …\nA call site record resulting from a compilation.\nA machine instruction.\nA trait describing the ability to encode a MachInst into …\nA trait describing the emission state carried between …\nA label refers to some offset in a <code>MachBuffer</code>. It may not …\nA source-location mapping resulting from a compilation.\nImplementation of the <code>TextSectionBuilder</code> trait backed by …\nA trap record resulting from a compilation.\nTarget of relocation is “nearby”. The threshold for …\nContains the success value\nRepresents the beginning of an editable region in the …\nA region in the <code>MachBuffer</code> code buffer that can be edited …\nProof-carrying-code validation error.\nA constant already present in the Cranelift IR ConstantPool…\nA real (physical) register. This corresponds to one of the …\nA register named in an instruction. This register can be …\nRegister.\nRegister allocator internal error discovered by the …\nA failure to map Cranelift register representation to a …\nNotion of “relocation distance”. This gives an …\nPersistent state carried across <code>emit</code> invocations.\nByte representation of a trap opcode which is inserted by …\nAn object that can be used to create the text section of …\nA constant of at most 64 bits. These are deduplicated as …\nSomething is not supported by the code generator. This …\nIdentify the different types of constant that can be …\nThis structure tracks the large constants used in VCode …\nVersion number of this crate.\nResulting map of Value labels and their ranges/locations.\nValue location range.\nA list of IR verifier errors.\nA reference to a well-known constant value that is …\nA type wrapper that indicates a register type is writable. …\nAdd a call-site record at the current offset.\nInform the buffer of a conditional branch at the given …\nAdd an external relocation at the current offset.\nAdd an external relocation at the given offset from …\nAdd a trap record at the current offset.\nInform the buffer of an unconditional branch at the given …\nAdd an unwind record at the current offset.\nThe addend to add to the symbol value.\nAlign a basic block offset (from start of function).  By …\nAlign a basic block offset (from start of function).  By …\nAlign up to the given alignment.\nCalculate the alignment of the constant data.\nThe required alignment of this buffer.\nAppends <code>data</code> to the text section with the <code>align</code> specified.\nGet a finalized machine buffer by applying the function’…\nReturn the raw bit encoding for this instance.\nRetrieve the constant data as a byte slice.\nReturn the underlying index value as a <code>u32</code>.\nBasic-block layout info: block edges. Each edge is …\nBasic-block layout info: block start offsets.\nBind a label to the current offset. A label can only be …\nBinary machine code emission.\nMachine code.\nGet the list of call sites for this code.\nThe calling convention of the callee.\nThe number of bytes that the callee will pop from the …\nThe calling convention of the caller.\nGet an appropriate type that can fully hold a value in a …\nPerform NaN canonicalizing rewrites on the function.\nThe control flow graph of <code>func</code>.\nThe <code>CFGPrinter</code> utility.\nGet the class of this register.\nGet the class of this register.\nClear all data structures in this context.\nRegisters clobbered by this call, as per its calling …\nThe trap code.\nCompile the function.\nCompile the function, and emit machine code into a <code>Vec&lt;u8&gt;</code>.\nInternally compiles the function into a stencil.\nReturns the compilation result for this function, …\nCompute the control flow graph.\nCompute dominator tree.\nCompute the loop analysis.\nCreates unwind information for the function.\nCreates unwind information for the function.\nCreates unwind information for the function using the …\nThe emission state holds ownership of a control plane, so …\nCurrent offset from start of buffer.\nCursor library.\nGet the code bytes.\nThis module gives users to instantiate values that …\nDebug tracing helpers.\nEmit a trap at some point in the future with the specified …\nRegister defs of this call.\nReceiver of this call\nReturns a display for the current FinalizedRelocTarget, …\nA Dominator Tree represented as mappings of Blocks to …\nDominator tree for <code>func</code>.\nDebug info: stackslots to stack pointer offsets.\nRun optimizations via the egraph infrastructure.\nPerform unreachable code elimination.\nEmit the instruction.\nEmit all pending constants and required pending veneers.\nCreates an empty set of info with no clobbers/uses/etc …\nThe end of the region of code corresponding to a source …\nThe end of the range. It is an offset in the generated …\nEnd a region of patchable code, yielding a <code>PatchRegion</code> …\nMark the end of the <code>SourceLoc</code> segment started at the last …\nCompletes this text section, filling out any final …\nFinish any deferred emissions and/or fixups.\nA control flow graph represented as mappings of basic …\nCompute the control flow graph and dominator tree.\nAllocate a new compilation context with an existing …\nA debug-only option which is used to for\nThe <code>FrameLayout</code> for the function currently being compiled.\nSize of stack frame, in bytes.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new instance from the raw bit encoding.\nGet a label for a block. (The first N MachLabels are …\nExplicitly construct a <code>Writable&lt;T&gt;</code> from a <code>T</code>. As noted in …\nCreate a new instance from a <code>u32</code>.\nThe function we’re compiling.\nFunction we tried to compile, for display purposes.\nReturns a description of the alignment required for …\nGenerate an instruction that must appear at the beginning …\nGenerate an instruction that must appear at the beginning …\nGenerate a dummy instruction that will keep a value alive …\nGenerate a store of an immediate 64-bit integer to a …\nGenerate a store of an immediate 64-bit integer to a …\nGenerate a store of an immediate 64-bit integer to a …\nGenerate a store of an immediate 64-bit integer to a …\nGenerate a jump to another target. Used during lowering of …\nGenerate a move.\nGenerate a NOP. The <code>preferred_size</code> parameter allows the …\nReturns the data associated with the specified constant.\nGet the numeric label index.\nReserve appended space and return a mutable slice …\nIf available, return information about the code layout in …\nIf available, return information about the code layout in …\nAllocate a <code>Label</code> to refer to some offset. May not be bound …\nReturns a label that can be used to refer to the <code>constant</code> …\nReturn the registers referenced by this machine …\nGet a list of source location mapping tuples in …\nThe physical register number.\nUnderlying <code>CodegenError</code> that triggered the error.\nInsert a constant; using this method indicates that a …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRepresentation of Cranelift IR functions.\nIs this an “args” pseudoinst?\nShould this instruction be included in the clobber-set?\nDoes this instruction access memory?\nIf this is a simple move, return the (source, destination) …\nIs this a real (physical) reg?\nIs this a safepoint?\nIs this a terminator (branch or ret)? If so, return its …\nIs this an unconditional trap?\nIs this a virtual reg?\nInstruction Set Architectures.\nIs an island needed within the next N bytes?\nIterate over the <code>VCodeConstant</code> keys and the data (as a …\nIterate over the <code>VCodeConstant</code> keys inserted in this …\nThe kind of relocation.\nRun the legalizer for <code>isa</code> on the function.\nReturn the number of constants inserted.\nThe source location.\nThe ValueLoc containing a ValueLabel during this range.\nA loop analysis represented as mappings of loops to their …\nLoop analysis of <code>func</code>.\nChange the <code>T</code> payload on this info to <code>U</code>.\nMap the underlying register to another value or type.\nCreate a new emission state given the ABI object.\nCreate a new section, known to start at <code>start_offset</code> and …\nCreates a new text section builder which will have …\nAllocate a new compilation context.\nThe offset at which the relocation applies, <em>relative to the</em>\nThe offset at which the trap instruction occurs, <em>relative </em>…\nA hook that triggers when first emitting a new block. It …\nA hook that triggers when first emitting a new block. It …\nOptimize the function, performing all compilation steps up …\nPerforms various optimizations on branches pointing at the …\nCompact representation of <code>Option&lt;T&gt;</code> for types with a …\nConsume the patch region to yield a mutable slice of the …\nChecks if the given VCodeConstantData is registered as …\nUpdate the emission state before emitting an instruction …\nPretty-print the instruction.\nUtility routines for pretty-printing error messages.\nPush a user stack map onto this buffer.\nAdd a byte.\nAdd 2 bytes.\nAdd 4 bytes.\nAdd 8 bytes.\nAdd a slice of bytes.\nDetermine register class(es) to store the given Cranelift …\nWhat is the register class used for reference types …\nGet a mutable borrow of the underlying register.\nSimilar to <code>MachBuffer::register_constants</code> but registers a …\nRegisters metadata in this <code>MachBuffer</code> about the <code>constants</code> …\nGet the list of external relocations for this code.\nPerform constant-phi removal on the function.\nReplace all redundant loads with the known values in …\nReserve the first N MachLabels for blocks.\nAttempts to resolve a relocation for this function.\nThe offset of the call’s return address, <em>relative to the </em>…\nSet the flag to request a disassembly when compiling with a\nShared settings module.\nDebug info: stackslots to stack pointer offsets.\nThe start of the region of code corresponding to a source …\nThe start of the range. It is an offset in the generated …\nBegin a region of patchable code. There is one requirement …\nSet the <code>SourceLoc</code> for code from this offset until the …\nReturn the code in this mach buffer as a hex string for …\nReturns the compilation result for this function, …\nUsed to continue using a control plane after the emission …\nTake this buffer’s user strack map metadata.\nThe external symbol / name to which this relocation refers.\nPass timing.\nGet the physical register (<code>RealReg</code>), if this register is …\nGet the underlying register, which can be read.\nCreates a string representing this label, for convenience.\nGet the virtual (non-physical) register, if this register …\nGet the total required size for the code.\nEven when trace logging is disabled, the trace macro has a …\nGet the list of trap records for this code.\nTraversals over the IR.\nAny unwind info at a given location.\nEmit a reference to the given label with the given …\nGet the user stack map metadata for this code.\nRegister uses of this call.\nDebug info: value labels to registers/stackslots at code …\nDisassembly, if requested.\nA verifier for ensuring that functions are well formed. It …\nRun the verifier on the function.\nRun the verifier only if the <code>enable_verifier</code> setting is …\nFlag: do we want a disassembly with the CompiledCode?\nInitialize the structure with the expected number of …\nWhat is the worst-case instruction size emitted by this …\nConverting Cranelift IR to text.\nAArch64 GOT Page Set the immediate value of an ADRP to …\nAArch64 GOT Low bits Set the LD/ST immediate field to bits …\nAarch64 TLSDESC Add Lo12 This is equivalent to …\nAarch64 TLSDESC Adr Page21 This is equivalent to …\nAarch64 TLSDESC Call This is equivalent to …\nAarch64 TLSDESC Ld64 Lo12 This is equivalent to …\nabsolute 4-byte\nabsolute 8-byte\nAddend to add to the symbol value.\nArm32 call target\nArm64 call target. Encoded as bottom 26 bits of …\nContainer for information about a vector of compiled code …\nOffset in bytes from the beginning of the function.\nElf x86_64 32 bit signed PC relative offset to two GOT …\nMach-O Aarch64 TLS PC-relative distance to the page of the …\nMach-O Aarch64 TLS Offset within page of TLVP slot.\nMach-O x86_64 32 bit signed PC relative offset to a …\nRelocation kinds for every ISA\nRISC-V Call PLT: 32-bit PC-relative function call, macros …\nHigh 20 bits of a 32-bit PC-relative GOT offset relocation\nLow 12 bits of a 32-bit PC-relative relocation (I-Type …\nRISC-V TLS GD: High 20 bits of 32-bit PC-relative TLS GD …\ns390x PC-relative 4-byte offset\ns390x PC-relative 4-byte offset to PLT\ns390x TLS GD64 - 64-bit offset of tls_index for GD symbol …\ns390x TLS GDCall - marker to enable optimization of TLS …\nx86 call to PC-relative 4-byte\nx86 call to PLT-relative 4-byte\nx86 GOT PC-relative 4-byte\nx86 PC-relative 4-byte\nThe 32-bit offset of the target from the beginning of its …\nDisplay trait implementation drops the arch, since its …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nNumber of bytes in total.\nA utility for pretty-printing the CFG of a <code>Function</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new CFGPrinter.\nWrite the CFG for this function to <code>w</code>.\nCursor is pointing after the end of a block. New …\nCursor is pointing at an existing instruction. New …\nCursor is before the beginning of a block. No instructions …\nAll cursor types implement the <code>Cursor</code> which provides …\nThe possible positions of a cursor.\nFunction cursor.\nCursor is not pointing anywhere. No instructions can be …\nRebuild this cursor positioned after <code>inst</code>.\nRebuild this cursor positioned at the bottom of <code>block</code>.\nRebuild this cursor positioned at the first insertion …\nRebuild this cursor positioned at the first instruction in …\nRebuild this cursor positioned at <code>inst</code>.\nRebuild this cursor positioned at the last instruction in …\nRebuild this cursor positioned at <code>pos</code>.\nRebuild this cursor positioned at the top of <code>block</code>.\nGet the block corresponding to the current position.\nGet the instruction corresponding to the current position, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe referenced function.\nGo to the position after a specific instruction, which …\nGo to the bottom of <code>block</code> which must be inserted into the …\nGo to the position for inserting instructions at the …\nGo to the first instruction in <code>block</code>.\nGo to a specific instruction which must be inserted in the …\nGo to the last instruction in <code>block</code>.\nGo to the top of <code>block</code> which must be inserted into the …\nCreate an instruction builder that inserts an instruction …\nInsert a block at the current position and switch to it.\nInsert an instruction at the current position.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nBorrow a reference to the function layout that this cursor …\nBorrow a mutable reference to the function layout that …\nCreate a new <code>FuncCursor</code> pointing nowhere.\nGo to the top of the next block in layout order and return …\nMove to the next instruction in the same block and return …\nGet the current cursor position.\nGo to the bottom of the previous block in layout order and …\nMove to the previous instruction in the same block and …\nRemove the instruction under the cursor.\nRemove the instruction under the cursor.\nSet the current position.\nSet the source location that should be assigned to new …\nGet the source location that should be assigned to new …\nUse the source location of <code>inst</code> for future instructions.\nExchange this cursor for one with a set source location.\nRepresent a data value. Where Value is an SSA reference, …\nRecord failures to cast DataValue.\nHelper structure for printing bracket-enclosed vectors of …\nPerforms a bitwise comparison over the contents of …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTry to cast an immediate integer (a wrapped <code>i64</code> on most …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn true if the value is a vector (i.e. <code>DataValue::V128</code>…\nRead a DataValue from a slice using a given Type in …\nRead a DataValue from a slice using a given Type in …\nRead a DataValue from a slice using a given Type with …\nRead a DataValue from a memory location using a given Type …\nConverts <code>self</code> to big endian from target’s endianness.\nConverts <code>self</code> to little endian from target’s endianness.\nReturn the Cranelift IR Type for this DataValue.\nHelper function for displaying <code>Vec&lt;DataValue&gt;</code>.\nWrite a DataValue to a slice in big-endian byte order.\nWrite a DataValue to a slice in little-endian byte order.\nWrite a DataValue to a slice in native-endian byte order.\nWrite a DataValue to a memory location in native-endian …\nHelper for printing lists.\nPrefix added to the log file names, just before the thread …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAn iterator that enumerates the direct children of a block …\nThe dominator tree for a single function.\nOptional pre-order information that can be computed for a …\nGet the CFG post-order of blocks that was used to compute …\nGet an iterator over the direct children of <code>block</code> in the …\nClear the data structures used to represent the dominator …\nCompute the common dominator of two basic blocks.\nReset and compute a CFG post-order and dominator tree.\nRecompute this data structure to match <code>domtree</code>.\nReturns <code>true</code> if <code>a</code> dominates <code>b</code>.\nFast, constant time dominance check with block granularity.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the immediate dominator of <code>block</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs <code>block</code> reachable from the entry block?\nCheck if the dominator tree is in a valid state.\nFind the last instruction in <code>a</code> that dominates <code>b</code>. If no …\nAllocate a new blank dominator tree. Use <code>compute</code> to …\nCreate a new blank <code>DominatorTreePreorder</code>.\nCompare two program points according to the dominator tree …\nCompare two blocks according to the dominator pre-order.\nCompare two program points relative to a reverse …\nCompare two blocks relative to the reverse post-order.\nAllocate and compute a dominator tree.\nA basic block denoted by its enclosing Block and last …\nThe Control Flow Graph maintains a mapping of blocks to …\nAn iterator over block predecessors. The iterator type is …\nAn iterator over block successors. The iterator type is …\nEnclosing Block key.\nClear all data structures in this control flow graph.\nCompute the control flow graph of <code>func</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nLast instruction in the basic block.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if the CFG is in a valid state.\nAllocate a new blank control flow graph.\nConvenient method to construct new BlockPredecessor.\nGet an iterator over the CFG predecessors to <code>block</code>.\nRecompute the control flow graph of <code>block</code>.\nGet an iterator over the CFG successors to <code>block</code>.\nAllocate and compute the control flow graph for <code>func</code>.\nFunction parameter or return value descriptor.\nAdd\nA value alias to original value.\nWhich disjoint region of aliasing memory is accessed in …\nAnd\nFunction argument extension options.\nThe special purpose of a function argument.\nAtomicCas(imms=(flags: ir::MemFlags), vals=3, blocks=0)\nAtomicCas(imms=(flags: ir::MemFlags), vals=3, blocks=0)\nAtomicRmw(imms=(flags: ir::MemFlags, op: ir::AtomicRmwOp), …\nAtomicRmw(imms=(flags: ir::MemFlags, op: ir::AtomicRmwOp), …\nDescribes the arithmetic operation in an atomic memory …\nFailed float-to-int conversion.\nSignature mismatch on indirect call.\nBig-endian\nBinary(imms=(), vals=2, blocks=0)\nBinary(imms=(), vals=2, blocks=0)\nBinaryImm64(imms=(imm: ir::immediates::Imm64), vals=1, …\nBinaryImm64(imms=(imm: ir::immediates::Imm64), vals=1, …\nBinaryImm8(imms=(imm: ir::immediates::Uimm8), vals=1, …\nBinaryImm8(imms=(imm: ir::immediates::Uimm8), vals=1, …\nA block header.\nBranchTable(imms=(table: ir::JumpTable), vals=1, blocks=0)\nBranchTable(imms=(table: ir::JumpTable), vals=1, blocks=0)\nBrif(imms=(), vals=1, blocks=2)\nBrif(imms=(), vals=1, blocks=2)\nCall(imms=(func_ref: ir::FuncRef), vals=0, blocks=0)\nCall(imms=(func_ref: ir::FuncRef), vals=0, blocks=0)\nCallIndirect(imms=(sig_ref: ir::SigRef), vals=1, blocks=0)\nCallIndirect(imms=(sig_ref: ir::SigRef), vals=1, blocks=0)\nceil.f32\nceil.f64\nTLS index symbol for the current thread. Used in COFF/PE …\nCondTrap(imms=(code: ir::TrapCode), vals=1, blocks=0)\nCondTrap(imms=(code: ir::TrapCode), vals=1, blocks=0)\nValue is a multiple of how many instances of <code>vector_type</code> …\nA dynamically-sized untyped blob of memory, with bound …\nDynamicStackLoad(imms=(dynamic_stack_slot: …\nDynamicStackLoad(imms=(dynamic_stack_slot: …\nDynamicStackStore(imms=(dynamic_stack_slot: …\nDynamicStackStore(imms=(dynamic_stack_slot: …\nELF well-known linker symbol <em>GLOBAL_OFFSET_TABLE</em>\nElf __tls_get_addr\nElf __tls_get_offset\nA type with no size.\nEndianness of a memory access.\nAn external function.\nThe name of an external is either a reference to a …\nFloatCompare(imms=(cond: ir::condcodes::FloatCC), vals=2, …\nFloatCompare(imms=(cond: ir::condcodes::FloatCC), vals=2, …\nfloor.f32\nfloor.f64\nfma.f32\nfma.f64\nFuncAddr(imms=(func_ref: ir::FuncRef), vals=0, blocks=0)\nFuncAddr(imms=(func_ref: ir::FuncRef), vals=0, blocks=0)\nInformation about a global value declaration.\nA wasm atomic operation was presented with a …\nA <code>heap_addr</code> instruction detected an out-of-bounds error.\nValue is an offset from another global value.\nIndirect call to a null table entry.\nBuilder that inserts an instruction at the current …\nAn instruction in the function.\nConvenience methods for building instructions.\nBase trait for instruction builders.\nBase trait for instruction inserters.\nIntAddTrap(imms=(code: ir::TrapCode), vals=2, blocks=0)\nIntAddTrap(imms=(code: ir::TrapCode), vals=2, blocks=0)\nIntCompare(imms=(cond: ir::condcodes::IntCC), vals=2, …\nIntCompare(imms=(cond: ir::condcodes::IntCC), vals=2, …\nIntCompareImm(imms=(cond: ir::condcodes::IntCC, imm: …\nIntCompareImm(imms=(cond: ir::condcodes::IntCC, imm: …\nAn integer division by zero.\nAn integer arithmetic operation caused an overflow.\nExecution has potentially run too long and may be …\nJump(imms=(), vals=0, blocks=1)\nJump(imms=(), vals=0, blocks=1)\nMap of jump tables.\nA well-known symbol.\nA well-known symbol.\nThe name of a runtime library routine.\nA well-known runtime library function.\nLittle-endian\nLoad(imms=(flags: ir::MemFlags, offset: …\nLoad(imms=(flags: ir::MemFlags, offset: …\nValue is pointed to by another global value.\nLoadNoOffset(imms=(flags: ir::MemFlags), vals=1, blocks=0)\nLoadNoOffset(imms=(flags: ir::MemFlags), vals=1, blocks=0)\nFlags for memory operations like load/store.\nlibc.memcmp\nlibc.memcpy\nlibc.memmove\nA statically-sized untyped blob of memory.\nData defining a memory type.\nOne field in a memory type.\nlibc.memset\nMultiAry(imms=(), vals=0, blocks=0)\nMultiAry(imms=(), vals=0, blocks=0)\nNand\nnearest.f32\nnearest.f64\nNo extension, high bits are indeterminate.\nA normal user program value passed to or from a function.\nNullAry(imms=(), vals=0, blocks=0)\nNullAry(imms=(), vals=0, blocks=0)\nA null <code>i31ref</code> was encountered which was required to be …\nA null reference was encountered which was required to be …\nOr\nprobe for stack overflow. These are emitted for functions …\nA <code>ProgramPoint</code> represents a position in a function where …\nSource location relative to another base source location.\nInstruction builder that replaces an existing instruction.\nSigned extension: high bits in register replicate sign bit.\nShuffle(imms=(imm: ir::Immediate), vals=2, blocks=0)\nShuffle(imms=(imm: ir::Immediate), vals=2, blocks=0)\nFunction signature.\nSigned max\nSigned min\nA source location.\nStackLoad(imms=(stack_slot: ir::StackSlot, offset: …\nStackLoad(imms=(stack_slot: ir::StackSlot, offset: …\nThe current stack space was exhausted.\nStackStore(imms=(stack_slot: ir::StackSlot, offset: …\nStackStore(imms=(stack_slot: ir::StackSlot, offset: …\nOriginal value labels assigned at transform.\nStore(imms=(flags: ir::MemFlags, offset: …\nStore(imms=(flags: ir::MemFlags, offset: …\nStoreNoOffset(imms=(flags: ir::MemFlags), vals=2, blocks=0)\nStoreNoOffset(imms=(flags: ir::MemFlags), vals=2, blocks=0)\nAn aggregate consisting of certain fields at certain …\nA C struct passed as argument.\nStruct return pointer.\nSub\nValue is symbolic, meaning it’s a name which will be …\nA <code>table_addr</code> instruction detected an out-of-bounds error.\nTernary(imms=(), vals=3, blocks=0)\nTernary(imms=(), vals=3, blocks=0)\nTernaryImm8(imms=(imm: ir::immediates::Uimm8), vals=2, …\nTernaryImm8(imms=(imm: ir::immediates::Uimm8), vals=2, …\nA test case function name of up to a hardcoded amount of …\nA name for a test case, mostly intended for Cranelift …\nTrap(imms=(code: ir::TrapCode), vals=0, blocks=0)\nTrap(imms=(code: ir::TrapCode), vals=0, blocks=0)\nA trap code describing the reason for a trap.\ntrunc.f32\nfrunc.f64\nUnsigned extension: high bits in register are 0.\nUnsigned max\nUnsigned min\nUnary(imms=(), vals=1, blocks=0)\nUnary(imms=(), vals=1, blocks=0)\nUnaryConst(imms=(constant_handle: ir::Constant), vals=0, …\nUnaryConst(imms=(constant_handle: ir::Constant), vals=0, …\nUnaryGlobalValue(imms=(global_value: ir::GlobalValue), …\nUnaryGlobalValue(imms=(global_value: ir::GlobalValue), …\nUnaryIeee16(imms=(imm: ir::immediates::Ieee16), vals=0, …\nUnaryIeee16(imms=(imm: ir::immediates::Ieee16), vals=0, …\nUnaryIeee32(imms=(imm: ir::immediates::Ieee32), vals=0, …\nUnaryIeee32(imms=(imm: ir::immediates::Ieee32), vals=0, …\nUnaryIeee64(imms=(imm: ir::immediates::Ieee64), vals=0, …\nUnaryIeee64(imms=(imm: ir::immediates::Ieee64), vals=0, …\nUnaryImm(imms=(imm: ir::immediates::Imm64), vals=0, …\nUnaryImm(imms=(imm: ir::immediates::Imm64), vals=0, …\nCode that was supposed to have been unreachable was …\nA user-defined name, with semantics left to the user.\nA reference to a name in a user-defined symbol table.\nA user-defined trap code.\nAn external name in a user-defined symbol table.\nAn explicit name for a user-defined function, be it …\nA compiled stack map, describing the location of many …\nA stack map entry describes a single GC-managed value and …\nA VM context pointer.\nValue is the address of the VM context struct.\nMarked with a label value.\nValue label assignments: label starts or value aliases.\nA label of a Value.\nThe <code>pshufb</code> on x86 when SSSE3 isn’t available.\nExchange\nXor\nReads the alias region that this memory operation works …\nTest if the <code>aligned</code> flag is set.\nReturns a slice with all supported AtomicRmwOp’s.\nGet a list of all known <code>LibCall</code>’s.\nReturn the raw bit encoding for this instance.\nReturn the underlying index value as a <code>u32</code>.\nPerform an atomic compare-and-swap operation on memory at <code>p</code>…\nPerform an atomic compare-and-swap operation on memory at <code>p</code>…\nAtomically load from memory at <code>p</code>.\nAtomically load from memory at <code>p</code>.\nAtomically read-modify-write memory at <code>p</code>, with second …\nAtomically read-modify-write memory at <code>p</code>, with second …\nAtomically store <code>x</code> to memory at <code>p</code>.\nAtomically store <code>x</code> to memory at <code>p</code>.\nUnsigned average with rounding: <code>a := (x + y + 1) // 2</code>\nUnsigned average with rounding: <code>a := (x + y + 1) // 2</code>\nBitwise and.\nBitwise and.\nBitwise and with immediate.\nBitwise and with immediate.\nBitwise and not.\nBitwise and not.\nReinterpret the bits in <code>x</code> as a different type.\nReinterpret the bits in <code>x</code> as a different type.\nReverse the bits of a integer.\nReverse the bits of a integer.\nRead the bits of this source location.\nConditional select of bits.\nConditional select of bits.\nConvert <code>x</code> to an integer mask.\nConvert <code>x</code> to an integer mask.\nBitwise not.\nBitwise not.\nBitwise or.\nBitwise or.\nBitwise or with immediate.\nBitwise or with immediate.\nBitwise or not.\nBitwise or not.\nIndirect branch via jump table.\nIndirect branch via jump table.\nConditional branch when cond is non-zero.\nConditional branch when cond is non-zero.\nReverse the byte order of an integer.\nReverse the byte order of an integer.\nInsert an instruction and return a reference to it, …\nBitwise xor.\nBitwise xor.\nBitwise xor with immediate.\nBitwise xor with immediate.\nBitwise xor not.\nBitwise xor not.\nDirect function call.\nDirect function call.\nCalling convention.\nIndirect function call.\nIndirect function call.\nRound floating point round to integral, towards positive …\nRound floating point round to integral, towards positive …\nTest if the <code>checked</code> bit is set.\nClear the signature so it is identical to a fresh one …\nCount leading sign bits.\nCount leading sign bits.\nCount leading zero bits.\nCount leading zero bits.\nWill this function be defined nearby, such that it will …\nCondition codes for the Cranelift code generator.\nConstants\nCount trailing zeros.\nCount trailing zeros.\nGet an immutable reference to the data flow graph that …\nGet an immutable reference to the data flow graph.\nGet a mutable reference to the data flow graph that will …\nGet a mutable reference to the data flow graph.\nEncodes an assembly debug trap.\nEncodes an assembly debug trap.\nData flow graph tracking Instructions, Values, and blocks.\nReturns a displayable version of the <code>ExtFuncData</code>, with or …\nReturns a display for the current <code>ExternalName</code>, with extra …\nGet the address of a dynamic stack slot.\nGet the address of a dynamic stack slot.\nLoad a value from a dynamic stack slot.\nLoad a value from a dynamic stack slot.\nStore a value to a dynamic stack slot.\nStore a value to a dynamic stack slot.\nDynamic IR types\nReturn endianness of the memory access.  This will return …\nCranelift IR entity references.\nIterate over the entries in this stack map.\nExpands the relative source location into an absolute one, …\nMethod for extending argument to a full register.\nReturn a fixed length sub vector, extracted from a dynamic …\nReturn a fixed length sub vector, extracted from a dynamic …\nExtract lane <code>Idx</code> from <code>x</code>.\nExtract lane <code>Idx</code> from <code>x</code>.\nFloating point constant.\nFloating point constant.\nFloating point constant.\nFloating point constant.\nFloating point constant.\nFloating point constant.\nFloating point constant.\nFloating point constant.\nFloating point absolute value.\nFloating point absolute value.\nGet the fact, if any, on a field.\nA proof-carrying-code fact about this value, if any.\nFloating point addition.\nFloating point addition.\nFloating point comparison.\nFloating point comparison.\nFloating point copy sign.\nFloating point copy sign.\nConvert signed integer to floating point.\nConvert signed integer to floating point.\nConvert unsigned integer to floating point.\nConvert unsigned integer to floating point.\nConverts floating point scalars to signed integer.\nConverts floating point scalars to signed integer.\nConvert floating point to signed integer as fcvt_to_sint …\nConvert floating point to signed integer as fcvt_to_sint …\nConverts floating point scalars to unsigned integer.\nConverts floating point scalars to unsigned integer.\nConvert floating point to unsigned integer as fcvt_to_uint …\nConvert floating point to unsigned integer as fcvt_to_uint …\nConvert <code>x</code> to a smaller floating point format.\nConvert <code>x</code> to a smaller floating point format.\nFloating point division.\nFloating point division.\nA memory fence.  This must provide ordering to ensure …\nA memory fence.  This must provide ordering to ensure …\nRound floating point round to integral, towards negative …\nRound floating point round to integral, towards negative …\nFloating point fused multiply-and-add.\nFloating point fused multiply-and-add.\nFloating point maximum, propagating NaNs using the …\nFloating point maximum, propagating NaNs using the …\nFloating point minimum, propagating NaNs using the …\nFloating point minimum, propagating NaNs using the …\nFloating point multiplication.\nFloating point multiplication.\nFloating point negation.\nFloating point negation.\nConvert <code>x</code> to a larger floating point format.\nConvert <code>x</code> to a larger floating point format.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nSource location when it is in effect\nCreates a new <code>RelSourceLoc</code> based on the given base and …\nCreate a new instance from the raw bit encoding.\nCreate a new instance from a <code>u32</code>.\nFloating point subtraction.\nFloating point subtraction.\nGet the address of a function.\nGet the address of a function.\nIntermediate representation of a function.\nConvert <code>x</code> to a smaller floating point format.\nConvert <code>x</code> to a smaller floating point format.\nConverts packed single precision floating point to packed …\nConverts packed single precision floating point to packed …\nGet the address in the frame pointer register.\nGet the address in the frame pointer register.\nGets the content of the pinned register, when it’s …\nGets the content of the pinned register, when it’s …\nGet a function reference for the probestack function in …\nGet the PC where this function will transfer control to …\nGet the PC where this function will transfer control to …\nGet the address in the stack pointer register.\nGet the address in the stack pointer register.\nGet a <code>UserExternalName</code> if this is a user-defined name.\nReturn the type of this global.\nCompute the value of global GV.\nCompute the value of global GV.\nInteger absolute value with wrapping: <code>a := |x|</code>.\nInteger absolute value with wrapping: <code>a := |x|</code>.\nWrapping integer addition: <code>a := x + y \\pmod{2^B}</code>.\nWrapping integer addition: <code>a := x + y \\pmod{2^B}</code>.\nAdd integers with carry in and out.\nAdd integers with carry in and out.\nAdd integers with carry in.\nAdd integers with carry in.\nAdd immediate integer.\nAdd immediate integer.\nDoes lane-wise integer pairwise addition on two operands, …\nDoes lane-wise integer pairwise addition on two operands, …\nInteger comparison.\nInteger comparison.\nCompare scalar integer to a constant.\nCompare scalar integer to a constant.\nConcatenate low and high bits to form a larger integer …\nConcatenate low and high bits to form a larger integer …\nInteger constant.\nInteger constant.\nImmediate operands for Cranelift instructions\nWrapping integer multiplication: <code>a := x y \\pmod{2^B}</code>.\nWrapping integer multiplication: <code>a := x y \\pmod{2^B}</code>.\nInteger multiplication by immediate constant.\nInteger multiplication by immediate constant.\nArbitrary.\nInteger negation: <code>a := -x \\pmod{2^B}</code>.\nInteger negation: <code>a := -x \\pmod{2^B}</code>.\nInsert a new instruction which belongs to the DFG.\nInsert <code>y</code> as lane <code>Idx</code> in x.\nInsert <code>y</code> as lane <code>Idx</code> in x.\nInstruction formats and opcodes.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert <code>x</code> to a smaller integer type by discarding the most …\nConvert <code>x</code> to a smaller integer type by discarding the most …\nImmediate reverse wrapping subtraction: …\nImmediate reverse wrapping subtraction: …\nIs this the default source location?\nIs this the default relative source location?\nDoes this return more than one normal value? (Pre-struct …\nInteger shift left. Shift the bits in <code>x</code> towards the MSB by …\nInteger shift left. Shift the bits in <code>x</code> towards the MSB by …\nInteger shift left by immediate.\nInteger shift left by immediate.\nSplit an integer into low and high parts.\nSplit an integer into low and high parts.\nStore the low 16 bits of <code>x</code> to memory at <code>p + Offset</code>.\nStore the low 16 bits of <code>x</code> to memory at <code>p + Offset</code>.\nStore the low 32 bits of <code>x</code> to memory at <code>p + Offset</code>.\nStore the low 32 bits of <code>x</code> to memory at <code>p + Offset</code>.\nStore the low 8 bits of <code>x</code> to memory at <code>p + Offset</code>.\nStore the low 8 bits of <code>x</code> to memory at <code>p + Offset</code>.\nWrapping integer subtraction: <code>a := x - y \\pmod{2^B}</code>.\nWrapping integer subtraction: <code>a := x - y \\pmod{2^B}</code>.\nSubtract integers with borrow in.\nSubtract integers with borrow in.\nSubtract integers with borrow in and out.\nSubtract integers with borrow in and out.\nJump.\nJump.\nJump table representation.\nThe label index.\nFunction layout.\nLoad from memory at <code>p + Offset</code>.\nLoad from memory at <code>p + Offset</code>.\nName of the external function.\nArbitrary.\nRound floating point round to integral, towards nearest …\nRound floating point round to integral, towards nearest …\nCreate a new builder which inserts instructions at <code>pos</code>. …\nCreate a <code>ReplaceBuilder</code> that will overwrite <code>inst</code>.\nCreate a new blank signature.\nCreate a parameter with default flags.\nCreates a new UserExternalName.\nCreate a new empty set of flags.\nCreate a new source location with the given bits.\nCreate a new relative source location with the given bits.\nReturns a slice of all traps except <code>TrapCode::User</code> traps\nJust a dummy instruction.\nJust a dummy instruction.\nTest if this memory operation cannot trap.\nHow many special parameters does this function have?\nHow many special returns does this function have?\nThe offset of this field in the memory type.\nThe offset within the stack slot where this entry’s …\nThe arguments passed to the function.\nProof-carrying code. We attach “facts” to values and …\nPopulation count\nPopulation count\nSpecial purpose of argument, or <code>Normal</code>.\nTest if the <code>readonly</code> flag is set.\nWhether this field is read-only, i.e., stores should be …\nReturn from the function.\nReturn from the function.\nDirect tail call.\nDirect tail call.\nIndirect tail call.\nIndirect tail call.\nValues returned from the function.\nRotate left.\nRotate left.\nRotate left by immediate.\nRotate left by immediate.\nRotate right.\nRotate right.\nRotate right by immediate.\nRotate right by immediate.\nAdd integers signed with overflow out. <code>of</code> is set when the …\nAdd integers signed with overflow out. <code>of</code> is set when the …\nAdd with signed saturation.\nAdd with signed saturation.\nCopies a scalar value to a vector value.  The scalar is …\nCopies a scalar value to a vector value.  The scalar is …\nSigned integer division rounded toward zero: …\nSigned integer division rounded toward zero: …\nSigned integer division by an immediate constant.\nSigned integer division by an immediate constant.\nConditional select.\nConditional select.\nConditional select intended for Spectre guards.\nConditional select intended for Spectre guards.\nSets the alias region that this works on to the specified …\nSet the <code>aligned</code> flag.\nSet a flag bit by name.\nSet the <code>checked</code> bit.\nSet endianness of the memory access.\nSets the trap code for this <code>MemFlags</code> to <code>None</code>.\nSets the content of the pinned register, when it’s …\nSets the content of the pinned register, when it’s …\nSet the <code>readonly</code> flag.\nConvert <code>self</code> to a parameter type with the <code>sext</code> flag set.\nConvert <code>x</code> to a larger integer type by sign-extending.\nConvert <code>x</code> to a larger integer type by sign-extending.\nSIMD vector shuffle.\nSIMD vector shuffle.\nGet a Signature for the function targeted by this LibCall.\nCall signature of function.\nLoad 16 bits from memory at <code>p + Offset</code> and sign-extend.\nLoad 16 bits from memory at <code>p + Offset</code> and sign-extend.\nLoad a 16x4 vector (64 bits) from memory at <code>p + Offset</code> and …\nLoad a 16x4 vector (64 bits) from memory at <code>p + Offset</code> and …\nLoad 32 bits from memory at <code>p + Offset</code> and sign-extend.\nLoad 32 bits from memory at <code>p + Offset</code> and sign-extend.\nLoad a 32x2 vector (64 bits) from memory at <code>p + Offset</code> and …\nLoad a 32x2 vector (64 bits) from memory at <code>p + Offset</code> and …\nLoad 8 bits from memory at <code>p + Offset</code> and sign-extend.\nLoad 8 bits from memory at <code>p + Offset</code> and sign-extend.\nLoad an 8x8 vector (64 bits) from memory at <code>p + Offset</code> and …\nLoad an 8x8 vector (64 bits) from memory at <code>p + Offset</code> and …\nThe stack slot that this stack map entry is within.\nSigned integer maximum.\nSigned integer maximum.\nSigned integer minimum.\nSigned integer minimum.\nMultiply integers signed with overflow out. <code>of</code> is set when …\nMultiply integers signed with overflow out. <code>of</code> is set when …\nSigned integer multiplication, producing the high half of a\nSigned integer multiplication, producing the high half of a\nCombine <code>x</code> and <code>y</code> into a vector with twice the lanes but …\nCombine <code>x</code> and <code>y</code> into a vector with twice the lanes but …\nCreate a special-purpose parameter that is not (yet) bound …\nFind the index of a presumed unique special-purpose …\nFind the index of a presumed unique special-purpose …\nVector splat.\nVector splat.\nFixed-point multiplication of numbers in the QN format, …\nFixed-point multiplication of numbers in the QN format, …\nFloating point square root.\nFloating point square root.\nSigned integer remainder. The result has the sign of the …\nSigned integer remainder. The result has the sign of the …\nSigned integer remainder with immediate divisor.\nSigned integer remainder with immediate divisor.\nSigned shift right. Shift bits in <code>x</code> towards the LSB by <code>y</code> …\nSigned shift right. Shift bits in <code>x</code> towards the LSB by <code>y</code> …\nSigned shift right by immediate.\nSigned shift right by immediate.\nSubtract integers signed with overflow out. <code>of</code> is set when …\nSubtract integers signed with overflow out. <code>of</code> is set when …\nSubtract with signed saturation.\nSubtract with signed saturation.\nGet the address of a stack slot.\nGet the address of a stack slot.\nLoad a value from a stack slot at the constant offset.\nLoad a value from a stack slot at the constant offset.\nStore a value to a stack slot at a constant offset.\nStore a value to a stack slot at a constant offset.\nSuspends execution of the current stack and resumes …\nSuspends execution of the current stack and resumes …\nStack slots.\nProvide the static size of this type, if known.\nStore <code>x</code> to memory at <code>p + Offset</code>.\nStore <code>x</code> to memory at <code>p + Offset</code>.\nWiden the high lanes of <code>x</code> using signed extension.\nWiden the high lanes of <code>x</code> using signed extension.\nWiden the low lanes of <code>x</code> using signed extension.\nWiden the low lanes of <code>x</code> using signed extension.\nVector swizzle.\nVector swizzle.\nAssume that <code>self</code> is an <code>GlobalValueData::Symbol</code> and return …\nCompute the value of global GV, which is a symbolic value.\nCompute the value of global GV, which is a symbolic value.\nCreates a new external name from a sequence of bytes. …\nCreates a new external name from a sequence of bytes. …\nCompute the value of global GV, which is a TLS (thread …\nCompute the value of global GV, which is a TLS (thread …\nTerminate execution unconditionally.\nTerminate execution unconditionally.\nGet the trap code to report if this memory access traps.\nTrap when non-zero.\nTrap when non-zero.\nTrap when zero.\nTrap when zero.\nRound floating point round to integral, towards zero.\nRound floating point round to integral, towards zero.\nCreate a set of flags representing an access from a “…\nThe primitive type of the value in this field. Accesses to …\nThe type of the value stored in this stack map entry.\nCommon types for the Cranelift code generator.\nAdd integers unsigned with overflow out. <code>of</code> is set when …\nAdd integers unsigned with overflow out. <code>of</code> is set when …\nUnsigned addition of x and y, trapping if the result …\nUnsigned addition of x and y, trapping if the result …\nAdd with unsigned saturation.\nAdd with unsigned saturation.\nUnsigned integer division: <code>a := \\lfloor {x \\over y} \\rfloor</code>…\nUnsigned integer division: <code>a := \\lfloor {x \\over y} \\rfloor</code>…\nUnsigned integer division by an immediate constant.\nUnsigned integer division by an immediate constant.\nConvert <code>self</code> to a parameter with the <code>uext</code> flag set.\nConvert <code>x</code> to a larger integer type by zero-extending.\nConvert <code>x</code> to a larger integer type by zero-extending.\nLoad 16 bits from memory at <code>p + Offset</code> and zero-extend.\nLoad 16 bits from memory at <code>p + Offset</code> and zero-extend.\nLoad a 16x4 vector (64 bits) from memory at <code>p + Offset</code> and …\nLoad a 16x4 vector (64 bits) from memory at <code>p + Offset</code> and …\nLoad 32 bits from memory at <code>p + Offset</code> and zero-extend.\nLoad 32 bits from memory at <code>p + Offset</code> and zero-extend.\nLoad an 32x2 vector (64 bits) from memory at <code>p + Offset</code> …\nLoad an 32x2 vector (64 bits) from memory at <code>p + Offset</code> …\nLoad 8 bits from memory at <code>p + Offset</code> and zero-extend.\nLoad 8 bits from memory at <code>p + Offset</code> and zero-extend.\nLoad an 8x8 vector (64 bits) from memory at <code>p + Offset</code> and …\nLoad an 8x8 vector (64 bits) from memory at <code>p + Offset</code> and …\nUnsigned integer maximum.\nUnsigned integer maximum.\nUnsigned integer minimum.\nUnsigned integer minimum.\nMultiply integers unsigned with overflow out. <code>of</code> is set …\nMultiply integers unsigned with overflow out. <code>of</code> is set …\nUnsigned integer multiplication, producing the high half …\nUnsigned integer multiplication, producing the high half …\nCombine <code>x</code> and <code>y</code> into a vector with twice the lanes but …\nCombine <code>x</code> and <code>y</code> into a vector with twice the lanes but …\nGet the instruction we know is inside.\nUnsigned integer remainder.\nUnsigned integer remainder.\nUnsigned integer remainder with immediate divisor.\nUnsigned integer remainder with immediate divisor.\nCreate a new external name from a user-defined external …\nCreate a new external name from a user-defined external …\nDoes this signature have a parameter whose <code>ArgumentPurpose</code> …\nDoes this signature have a return whose <code>ArgumentPurpose</code> is …\nDoes this signature take an struct return pointer …\nUnsigned shift right. Shift bits in <code>x</code> towards the LSB by <code>y</code> …\nUnsigned shift right. Shift bits in <code>x</code> towards the LSB by <code>y</code> …\nUnsigned shift right by immediate.\nUnsigned shift right by immediate.\nSubtract integers unsigned with overflow out. <code>of</code> is set …\nSubtract integers unsigned with overflow out. <code>of</code> is set …\nSubtract with unsigned saturation.\nSubtract with unsigned saturation.\nCombine <code>x</code> and <code>y</code> into a vector with twice the lanes but …\nCombine <code>x</code> and <code>y</code> into a vector with twice the lanes but …\nWiden the high lanes of <code>x</code> using unsigned extension.\nWiden the high lanes of <code>x</code> using unsigned extension.\nWiden the low lanes of <code>x</code> using unsigned extension.\nWiden the low lanes of <code>x</code> using unsigned extension.\nReduce a vector to a scalar boolean.\nReduce a vector to a scalar boolean.\nType of the argument value.\nReduce a vector to a scalar boolean.\nReduce a vector to a scalar boolean.\nSIMD vector constant.\nSIMD vector constant.\nReduce a vector to a scalar integer.\nReduce a vector to a scalar integer.\nSets the alias region that this works on to the specified …\nSet the <code>aligned</code> flag, returning new flags.\nSet the <code>checked</code> bit, returning new flags.\nSet endianness of the memory access, returning new flags.\nSets the trap code for this <code>MemFlags</code> to <code>None</code>, returning …\nSet the <code>readonly</code> flag, returning new flags.\nReuse a single result value.\nReuse result values in <code>reuse</code>.\nConfigures these flags with the specified trap code <code>code</code>.\nA bitselect-lookalike instruction except with the …\nA bitselect-lookalike instruction except with the …\nA float-to-integer conversion instruction for …\nA float-to-integer conversion instruction for …\nAn instruction with equivalent semantics to <code>pmaddubsw</code> on …\nAn instruction with equivalent semantics to <code>pmaddubsw</code> on …\nA similar instruction to <code>sqmul_round_sat</code> except with the …\nA similar instruction to <code>sqmul_round_sat</code> except with the …\nA vector swizzle lookalike which has the semantics of …\nA vector swizzle lookalike which has the semantics of …\nThe base pointer global value.\nThe base pointer global value.\nWill this symbol be defined nearby, such that it will …\nSpecifies the memory flags to be used by the load. …\nType of the loaded value.\nType of the iadd.\nThe symbolic name.\nOffset added to the base pointer before doing the load.\nByte offset to be added to the value.\nOffset from the symbol. This can be used instead of …\nDoes this symbol refer to a thread local storage value?\nBase vector type.\nFields in this type. Sorted by offset.\nDynamic part of size.\nSize of this type.\nAccessible size.\nStatic part of size.\nSource location when it is in effect\nThe label index.\nCommon traits of condition codes.\n<code>==</code>.\nEQ\nCondition code for comparing floating point numbers.\nGT\nGT | EQ\nCondition code for comparing integers.\nLT\nLT | EQ\n<code>!=</code>.\nThe C ‘!=’ operator is the inverse of ‘==’: …\nEQ | LT | GT\nLT | GT\nSigned <code>&gt;</code>.\nSigned <code>&gt;=</code>.\nSigned <code>&lt;</code>.\nSigned <code>&lt;=</code>.\nUN\nUN | EQ\nUN | GT\nUN | GT | EQ\nUN | LT\nUN | LT | EQ\nUnsigned <code>&gt;</code>.\nUnsigned <code>&gt;=</code>.\nUnsigned <code>&lt;</code>.\nUnsigned <code>&lt;=</code>.\nReturns a slice with all possible IntCC values.\nReturns a slice with all possible FloatCC values.\nGet the complemented condition code of <code>self</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the swapped args condition code for <code>self</code>.\nGet the corresponding string condition code for the IntCC …\nGet the corresponding IntCC with the signed component …\nGet the corresponding IntCC with the equal component …\nThis type describes the actual constant data. Note that …\nMaintains the mapping between a constant handle (i.e.  …\nAdd new bytes to the constant data.\nReturn the data as a slice.\nReturn the combined size of all of the constant values in …\nEmpty the constant pool of all data.\nIterate over mutable entries in the constant pool in …\nExpand the size of the constant data to <code>expected_size</code> …\nPrint the constant data in hexadecimal format, e.g. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nParse a hexadecimal string to <code>ConstantData</code>. This is the …\nRetrieve the constant data given a handle.\nInsert constant data into the pool, returning a handle for …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert the data to a vector.\nCheck if the constant contains any bytes.\nIterate over the constant’s bytes.\nIterate over the constants in insertion order.\nReturn the number of bytes in the constant.\nReturn the number of constants in the pool.\nCreate a new constant pool instance.\nLink a constant handle to its value. This does not …\nContents of a basic block.\nStorage for basic blocks within the DFG.\nA data flow graph defines all instructions and basic …\nObject that can display an instruction.\nStorage for instructions within the DFG.\nValue is the n’th parameter to a block.\nValue is the n’th result of an instruction.\nValue is a union of two other values.\nWhere did a value come from?\nIterator over all Values in a DFG.\nCreate a new basic block.\nInserts a <code>ValueLabelAssignments::Alias</code> for <code>to_alias</code> if …\nAppend a parameter with type <code>ty</code> to <code>block</code>.\nSimilar to <code>append_block_param</code>, append a parameter with …\nAppend a new stack map entry for the given call …\nAppend an existing value to <code>block</code>’s parameters.\nMake a BlockCall, bundling together the block and its …\nReturns <code>true</code> if the given block reference is valid.\nGet the types of the parameters on <code>block</code>.\nGet the parameters on <code>block</code>.\nbasic blocks in the function and their parameters.\nGet the call signature of a direct or indirect call …\nTurn a value into an alias of another.\nCheck that the given concrete <code>Type</code> has been defined in the …\nClear everything.\nClear the list of result values from <code>inst</code>.\nClone an instruction, attaching new result <code>Value</code>s and …\nStarts collection of debug information.\nCompute the type of an instruction result from opcode …\nConstants used within the function.\nGet the controlling type variable, or <code>INVALID</code> if <code>inst</code> isn…\nDetach all the parameters from <code>block</code> and return them as a …\nReturns an object that displays <code>inst</code>.\nReturns an object that displays the given <code>value</code>’s …\nDynamic types created.\nExternal function references. These are functions that can …\nFacts: proof-carrying-code assertions about values.\nGet the first result of an instruction.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTest if <code>inst</code> has any result values currently.\nStores large immediates that otherwise will not fit on …\nGet the instruction where the value was defined, if any.\nGet all value arguments on <code>inst</code> as a slice.\nGet all value arguments on <code>inst</code> as a mutable slice.\nGet the fixed value arguments on <code>inst</code> as a slice.\nGet the fixed value arguments on <code>inst</code> as a mutable slice.\nReturns <code>true</code> if the given instruction reference is valid.\nGet the result types of the given instruction.\nReturn all the results of an instruction.\nReturn all the results of an instruction as ValueList.\nConstruct a read-only visitor context for the values of …\nGet the variable value arguments on <code>inst</code> as a slice.\nGet the variable value arguments on <code>inst</code> as a mutable …\nData about all of the instructions in the function, …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the given block reference is valid.\nJump tables used in this function.\nGet the total number of basic blocks created in this …\nCreate a new basic block.\nDeclares a dynamic vector type\nCreate a new instruction.\nCreate result values for an instruction that produces …\nCreate result values for <code>inst</code>, reusing the provided …\nCreate result values for <code>inst</code>, reusing the provided …\nCreate an invalid value, to pad the index space. This is …\nCreate a new value alias. This is only for use by the …\nMap a function over the values of the instruction.\nMerge the facts for two values. If both values have facts …\nCreate a new empty <code>DataFlowGraph</code>.\nGet the number component of this definition.\nGet the number of parameters on <code>block</code>.\nGet the total number of basic blocks created in this …\nGet the total number of instructions created in this …\nGet the total number of values.\nOverwrite the instruction’s value references with values …\nGet the parameters on <code>block</code>.\nRemoves <code>val</code> from <code>block</code>‘s parameters by a standard linear …\nCreate a <code>ReplaceBuilder</code> that will replace <code>inst</code> with a new …\nReplace a block parameter with a new value of type <code>ty</code>.\nReplace an instruction result with a new value of type …\nReplace the results of one instruction with aliases to the …\nResolve value aliases.\nReplace all uses of value aliases with their resolved …\nCompute the type of an alias. This is only for use in the …\nFunction signature table. These signatures are referenced …\nRemoves <code>val</code> from <code>block</code>’s parameters by swapping it with …\nCreate a union of two values.\nUnwrap the block there the parameter is defined, or panic.\nUnwrap the instruction where the value was defined, or …\nGet the stack map entries associated with the given …\nIf <code>v</code> is already defined as an alias, return its …\nGet the definition of a value.\nDetermine if <code>v</code> is an attached instruction result / block …\nCheck whether a value is valid and not an alias.\nCheck if a value reference is valid.\nCheck if a value reference is valid, while being aware of …\nMemory pool of value lists.\nGet the type of a value.\nGet an iterator over all values.\nGet an iterator over all values and their definitions.\nSaves Value labels.\nA dynamic type object which has a base vector type and a …\nAll allocated dynamic types.\nBase vector type, this is the minimum size of the type.\nConvert ‘base_vector_ty’ into a concrete dynamic …\nThe dynamic scaling factor of the base vector type.\nConvert a dynamic-vector type to a fixed-vector type.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new dynamic type.\nAn opaque reference to any of the entities defined in this …\nAn opaque reference to a basic block in a <code>Function</code>.\na basic block.\nAn opaque reference to a constant.\nA constant.\nAn opaque reference to a dynamic stack slot.\nA dynamic stack slot.\nAn opaque reference to a dynamic type.\nA dynamic type\nAn opaque reference to another <code>Function</code>.\nAn external function.\nThe whole function.\nAn opaque reference to a global value.\nA Global value.\nAn opaque reference to an immediate.\nAn opaque reference to an instruction in a <code>Function</code>.\nAn instruction.\nAn opaque reference to a jump table.\nA jump table.\nAn opaque reference to a memory type.\nA memory type.\nAn opaque reference to a function <code>Signature</code>.\nA function call signature.\nA function’s stack limit\nAn opaque reference to a stack slot.\nA stack slot.\nA reference to an <code>UserExternalName</code>, declared with …\nAn opaque reference to an SSA value.\nAn SSA value.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new block reference from its number. This …\nCreate a value from its number representation. This is the …\nCreate a new stack slot reference from its number.\nCreate a new stack slot reference from its number.\nCreate a new dynamic type reference from its number.\nCreate a new global value reference from its number.\nCreate a new memory type reference from its number.\nCreate a const reference from its number.\nCreate an immediate reference from its number.\nCreate a new jump table reference from its number.\nCreate a new external function reference from its number.\nCreate a new function signature reference from its number.\nWrapper type capable of displaying a <code>Function</code>.\nFunctions can be cloned, but it is not a very fast …\nFunction parameters used when creating this function, and …\nFunction fields needed when compiling a function.\nA version marker used to ensure that serialized clif ir is …\nReturns the base <code>SourceLoc</code>.\nReturns an iterator over the blocks succeeding the given …\nClear all data structures in this function.\nStarts collection of debug information.\nCreates a dynamic stack slot in the function, to be used …\nDeclares a global value accessible to the function.\nCreates a jump table in the function, to be used by …\nDeclares a memory type for use by the function.\nCreates a sized stack slot in the function, to be used by …\nDeclare a user-defined external function import, to be …\nData flow graph containing the primary definition of all …\nReturn an object that can display this function with …\nDynamic stack slots allocated in this function.\nSets the base <code>SourceLoc</code>, if not set yet, and returns the …\nRetrieve a <code>UserExternalNameRef</code> for the given name, or add …\nSize occupied by all stack slots associated with this …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet a concrete <code>Type</code> from a user defined <code>DynamicType</code>.\nFind the global dyn_scale value associated with given …\nFind the global dyn_scale for the given stack slot.\nGlobal value proof-carrying-code facts.\nGlobal values referenced.\nDeclare an external function import.\nAdds a signature which can later be used to declare an …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks that the specified block can be encoded as a basic …\nReturns true if the function is function that doesn’t …\nLayout of blocks and instructions in the function body.\nMemory types for proof-carrying code.\nName of this function.\nCreates a new <code>FunctionParameters</code> with the given name.\nCreate a new empty, anonymous function with a Fast calling …\nAll the parameters that can be applied onto the function …\nResets an already existing user function name to a new …\nRewrite the branch destination to <code>new_dest</code> if the …\nSets an absolute source location for the given instruction.\nSignature of this function.\nSized stack slots allocated in this function.\nFind a presumed unique special-purpose function parameter …\nReturns an absolute source location for the given …\nSource locations.\nAn optional global value which represents an expression …\nAll the fields required for compiling a function, …\nReplace the <code>dst</code> instruction’s data with the <code>src</code> …\nReturns the internal mapping of <code>UserExternalNameRef</code> to …\nA version marker used to ensure that serialized clif ir is …\nCreate a function with the given name and signature.\nAn IEEE binary128 immediate floating point value, …\nAn IEEE binary16 immediate floating point value, …\nAn IEEE binary32 immediate floating point value, …\nAn IEEE binary64 immediate floating point value, …\n64-bit immediate signed integer operand.\nConvert a type into a vector of bytes; all implementors in …\nThe positive WebAssembly canonical NaN.\nThe positive WebAssembly canonical NaN.\nThe positive WebAssembly canonical NaN.\nThe positive WebAssembly canonical NaN.\n32-bit signed immediate offset.\nA 32-bit unsigned integer immediate operand.\n64-bit immediate unsigned integer operand.\n8-bit unsigned integer immediate operand.\nA 128-bit immediate operand.\nComputes the absolute value of <code>self</code>.\nComputes the absolute value of <code>self</code>.\nComputes the absolute value of <code>self</code>.\nComputes the absolute value of <code>self</code>.\nConverts <code>self</code> to a Rust <code>f32</code>.\nConverts <code>self</code> to a Rust <code>f64</code>.\nConvert the immediate into a slice.\nReturns the value of this immediate.\nGet the bitwise representation.\nGet the bitwise representation.\nGet the bitwise representation.\nGet the bitwise representation.\nIterate over the bytes in the constant.\nReturns the smallest integer greater than or equal to <code>self</code>.\nReturns the smallest integer greater than or equal to <code>self</code>.\nReturns a number composed of the magnitude of <code>self</code> and the …\nReturns a number composed of the magnitude of <code>self</code> and the …\nReturns a number composed of the magnitude of <code>self</code> and the …\nReturns a number composed of the magnitude of <code>self</code> and the …\nCreate an <code>Ieee16</code> number representing the greatest negative …\nCreate an <code>Ieee32</code> number representing the greatest negative …\nCreate an <code>Ieee64</code> number representing the greatest negative …\nCreate an <code>Ieee128</code> number representing the greatest …\nReturns the largest integer less than or equal to <code>self</code>.\nReturns the largest integer less than or equal to <code>self</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn the little-endian byte representation of the …\nCheck if the value is a NaN. For <code>Ieee16</code>, this means …\nCheck if the value is a NaN. For <code>Ieee32</code>, this means …\nCheck if the value is a NaN. For <code>Ieee64</code>, this means …\nCheck if the value is a NaN. For <code>Ieee128</code>, this means …\nReturns true if <code>self</code> has a negative sign, including -0.0, …\nReturns true if <code>self</code> has a negative sign, including -0.0, …\nReturns true if <code>self</code> has a negative sign, including -0.0, …\nReturns true if <code>self</code> has a negative sign, including -0.0, …\nReturns true if <code>self</code> has a negative sign, including 0.0, …\nReturns true if <code>self</code> has a negative sign, including 0.0, …\nReturns true if <code>self</code> has a negative sign, including 0.0, …\nReturns true if <code>self</code> has a negative sign, including 0.0, …\nReturns <code>true</code> if <code>self</code> is positive or negative zero.\nReturns <code>true</code> if <code>self</code> is positive or negative zero.\nReturns <code>true</code> if <code>self</code> is positive or negative zero.\nReturns <code>true</code> if <code>self</code> is positive or negative zero.\nReturns the maximum of <code>self</code> and <code>other</code>, following the …\nReturns the maximum of <code>self</code> and <code>other</code>, following the …\nReturns the maximum of <code>self</code> and <code>other</code>, following the …\nReturns the maximum of <code>self</code> and <code>other</code>, following the …\nReturns the minimum of <code>self</code> and <code>other</code>, following the …\nReturns the minimum of <code>self</code> and <code>other</code>, following the …\nReturns the minimum of <code>self</code> and <code>other</code>, following the …\nReturns the minimum of <code>self</code> and <code>other</code>, following the …\nCreate a new <code>Imm64</code> representing the signed number <code>x</code>.\nCreate a new <code>Uimm64</code> representing the unsigned number <code>x</code>.\nCreate a new <code>Offset32</code> representing the signed number <code>x</code>.\nReturns <code>None</code> if <code>self</code> is a NaN and <code>Some(self)</code> otherwise.\nReturns <code>None</code> if <code>self</code> is a NaN and <code>Some(self)</code> otherwise.\nReturns <code>None</code> if <code>self</code> is a NaN and <code>Some(self)</code> otherwise.\nReturns <code>None</code> if <code>self</code> is a NaN and <code>Some(self)</code> otherwise.\nCreate an <code>Ieee16</code> number representing <code>2.0^n</code>.\nCreate an <code>Ieee32</code> number representing <code>2.0^n</code>.\nCreate an <code>Ieee64</code> number representing <code>2.0^n</code>.\nCreate an <code>Ieee128</code> number representing <code>2.0^n</code>.\nReturns the nearest integer to <code>self</code>. Rounds half-way cases …\nReturns the nearest integer to <code>self</code>. Rounds half-way cases …\nReturns the square root of <code>self</code>.\nReturns the square root of <code>self</code>.\nConvert the immediate into a vector.\nReturns the integer part of <code>self</code>. This means that …\nReturns the integer part of <code>self</code>. This means that …\nAdd in the signed number <code>x</code> if possible.\nCreate a new <code>Offset32</code> representing the signed number <code>x</code> if …\nCreate a new <code>Ieee16</code> containing the bits of <code>bits</code>.\nCreate a new <code>Ieee32</code> containing the bits of <code>bits</code>.\nCreate a new <code>Ieee64</code> containing the bits of <code>bits</code>.\nCreate a new <code>Ieee128</code> containing the bits of <code>bits</code>.\nCreate a new <code>Ieee32</code> representing the number <code>x</code>.\nCreate a new <code>Ieee64</code> representing the number <code>x</code>.\nReturn self negated.\nReturn self negated.\nAtomicCas(imms=(flags: ir::MemFlags), vals=3, blocks=0)\n<code>a = atomic_cas MemFlags, p, e, x</code>. (AtomicCas) Type …\n<code>a = atomic_load MemFlags, p</code>. (LoadNoOffset)\nAtomicRmw(imms=(flags: ir::MemFlags, op: ir::AtomicRmwOp), …\n<code>a = atomic_rmw MemFlags, AtomicRmwOp, p, x</code>. (AtomicRmw)\n<code>atomic_store MemFlags, x, p</code>. (StoreNoOffset) Type inferred …\n<code>a = avg_round x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = band x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = band_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = band_not x, y</code>. (Binary) Type inferred from <code>x</code>.\nBinary(imms=(), vals=2, blocks=0)\nBinaryImm64(imms=(imm: ir::immediates::Imm64), vals=1, …\nBinaryImm8(imms=(imm: ir::immediates::Uimm8), vals=1, …\n<code>a = bitcast MemFlags, x</code>. (LoadNoOffset)\n<code>a = bitrev x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = bitselect c, x, y</code>. (Ternary) Type inferred from <code>x</code>.\nA pair of a Block and its arguments, stored in a single …\n<code>a = bmask x</code>. (Unary)\n<code>a = bnot x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = bor x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = bor_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = bor_not x, y</code>. (Binary) Type inferred from <code>x</code>.\nThe operand is bound to a known type.\n<code>br_table x, JT</code>. (BranchTable)\nBranchTable(imms=(table: ir::JumpTable), vals=1, blocks=0)\nBrif(imms=(), vals=1, blocks=2)\n<code>brif c, block_then, block_else</code>. (Brif) Type inferred from <code>c</code>…\n<code>a = bswap x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = bxor x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = bxor_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = bxor_not x, y</code>. (Binary) Type inferred from <code>x</code>.\nCall(imms=(func_ref: ir::FuncRef), vals=0, blocks=0)\n<code>rvals = call FN, args</code>. (Call)\nCallIndirect(imms=(sig_ref: ir::SigRef), vals=1, blocks=0)\n<code>rvals = call_indirect SIG, callee, args</code>. (CallIndirect) …\nInformation about call instructions.\n<code>a = ceil x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = cls x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = clz x</code>. (Unary) Type inferred from <code>x</code>.\nCondTrap(imms=(code: ir::TrapCode), vals=1, blocks=0)\n<code>a = ctz x</code>. (Unary) Type inferred from <code>x</code>.\n<code>debugtrap</code>. (NullAry)\nThis is a direct call to an external function declared in …\nWrapper for the context needed to display a BlockCall …\n<code>addr = dynamic_stack_addr DSS</code>. (DynamicStackLoad)\nDynamicStackLoad(imms=(dynamic_stack_slot: …\n<code>a = dynamic_stack_load DSS</code>. (DynamicStackLoad)\nDynamicStackStore(imms=(dynamic_stack_slot: …\n<code>dynamic_stack_store x, DSS</code>. (DynamicStackStore) Type …\n<code>a = extract_vector x, y</code>. (BinaryImm8) Type inferred from <code>x</code>.\n<code>a = extractlane x, Idx</code>. (BinaryImm8) Type inferred from <code>x</code>.\n<code>a = f128const N</code>. (UnaryConst)\n<code>a = f16const N</code>. (UnaryIeee16)\n<code>a = f32const N</code>. (UnaryIeee32)\n<code>a = f64const N</code>. (UnaryIeee64)\n<code>a = fabs x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = fadd x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = fcmp Cond, x, y</code>. (FloatCompare) Type inferred from <code>x</code>.\n<code>a = fcopysign x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = fcvt_from_sint x</code>. (Unary)\n<code>a = fcvt_from_uint x</code>. (Unary)\n<code>a = fcvt_to_sint x</code>. (Unary)\n<code>a = fcvt_to_sint_sat x</code>. (Unary)\n<code>a = fcvt_to_uint x</code>. (Unary)\n<code>a = fcvt_to_uint_sat x</code>. (Unary)\n<code>a = fdemote x</code>. (Unary)\n<code>a = fdiv x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>fence</code>. (NullAry)\nFloatCompare(imms=(cond: ir::condcodes::FloatCC), vals=2, …\n<code>a = floor x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = fma x, y, z</code>. (Ternary) Type inferred from <code>y</code>.\n<code>a = fmax x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = fmin x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = fmul x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = fneg x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = fpromote x</code>. (Unary)\nThe operand type can vary freely within the given set.\n<code>a = fsub x, y</code>. (Binary) Type inferred from <code>x</code>.\nFuncAddr(imms=(func_ref: ir::FuncRef), vals=0, blocks=0)\n<code>addr = func_addr FN</code>. (FuncAddr)\n<code>a = fvdemote x</code>. (Unary)\n<code>x = fvpromote_low a</code>. (Unary)\n<code>addr = get_frame_pointer</code>. (NullAry)\n<code>addr = get_pinned_reg</code>. (NullAry)\n<code>addr = get_return_address</code>. (NullAry)\n<code>addr = get_stack_pointer</code>. (NullAry)\n<code>a = global_value GV</code>. (UnaryGlobalValue)\n<code>a = iabs x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = iadd x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a, c_out = iadd_carry x, y, c_in</code>. (Ternary) Type inferred …\n<code>a = iadd_cin x, y, c_in</code>. (Ternary) Type inferred from <code>y</code>.\n<code>a = iadd_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = iadd_pairwise x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = icmp Cond, x, y</code>. (IntCompare) Type inferred from <code>x</code>.\n<code>a = icmp_imm Cond, x, Y</code>. (IntCompareImm) Type inferred …\n<code>a = iconcat lo, hi</code>. (Binary) Type inferred from <code>lo</code>.\n<code>a = iconst N</code>. (UnaryImm)\n<code>a = imul x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = imul_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\nThis is an indirect call with the specified signature. See …\n<code>a = ineg x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = insertlane x, y, Idx</code>. (TernaryImm8) Type inferred from …\nAn instruction format\nIntAddTrap(imms=(code: ir::TrapCode), vals=2, blocks=0)\nIntCompare(imms=(cond: ir::condcodes::IntCC), vals=2, …\nIntCompareImm(imms=(cond: ir::condcodes::IntCC, imm: …\n<code>a = ireduce x</code>. (Unary)\n<code>a = irsub_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = ishl x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = ishl_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>lo, hi = isplit x</code>. (Unary) Type inferred from <code>x</code>.\n<code>istore16 MemFlags, x, p, Offset</code>. (Store) Type inferred …\n<code>istore32 MemFlags, x, p, Offset</code>. (Store) Type inferred …\n<code>istore8 MemFlags, x, p, Offset</code>. (Store) Type inferred from …\n<code>a = isub x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = isub_bin x, y, b_in</code>. (Ternary) Type inferred from <code>y</code>.\n<code>a, b_out = isub_borrow x, y, b_in</code>. (Ternary) Type inferred …\nJump(imms=(), vals=0, blocks=1)\n<code>jump block_call</code>. (Jump)\nLoad(imms=(flags: ir::MemFlags, offset: …\n<code>a = load MemFlags, p, Offset</code>. (Load)\nLoadNoOffset(imms=(flags: ir::MemFlags), vals=1, blocks=0)\nMultiAry(imms=(), vals=0, blocks=0)\n<code>a = nearest x</code>. (Unary) Type inferred from <code>x</code>.\n<code>nop</code>. (NullAry)\nThis is not a call instruction.\nNullAry(imms=(), vals=0, blocks=0)\nAn instruction opcode.\nValue type constraints for a given opcode.\n<code>a = popcnt x</code>. (Unary) Type inferred from <code>x</code>.\nThe type constraint on a value argument once the …\n<code>return rvals</code>. (MultiAry)\n<code>return_call FN, args</code>. (Call)\n<code>return_call_indirect SIG, callee, args</code>. (CallIndirect) …\n<code>a = rotl x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = rotl_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = rotr x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = rotr_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a, of = sadd_overflow x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = sadd_sat x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = scalar_to_vector s</code>. (Unary)\n<code>a = sdiv x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = sdiv_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = select c, x, y</code>. (Ternary) Type inferred from <code>x</code>.\n<code>a = select_spectre_guard c, x, y</code>. (Ternary) Type inferred …\n<code>set_pinned_reg addr</code>. (Unary) Type inferred from <code>addr</code>.\n<code>a = sextend x</code>. (Unary)\nShuffle(imms=(imm: ir::Immediate), vals=2, blocks=0)\n<code>a = shuffle a, b, mask</code>. (Shuffle)\n<code>a = sload16 MemFlags, p, Offset</code>. (Load)\n<code>a = sload16x4 MemFlags, p, Offset</code>. (Load) Type inferred …\n<code>a = sload32 MemFlags, p, Offset</code>. (Load) Type inferred from …\n<code>a = sload32x2 MemFlags, p, Offset</code>. (Load) Type inferred …\n<code>a = sload8 MemFlags, p, Offset</code>. (Load)\n<code>a = sload8x8 MemFlags, p, Offset</code>. (Load) Type inferred …\n<code>a = smax x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = smin x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a, of = smul_overflow x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = smulhi x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = snarrow x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = splat x</code>. (Unary)\n<code>a = sqmul_round_sat x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = sqrt x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = srem x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = srem_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = sshr x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = sshr_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a, of = ssub_overflow x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = ssub_sat x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>addr = stack_addr SS, Offset</code>. (StackLoad)\nStackLoad(imms=(stack_slot: ir::StackSlot, offset: …\n<code>a = stack_load SS, Offset</code>. (StackLoad)\nStackStore(imms=(stack_slot: ir::StackSlot, offset: …\n<code>stack_store x, SS, Offset</code>. (StackStore) Type inferred from …\n…\nStore(imms=(flags: ir::MemFlags, offset: …\n<code>store MemFlags, x, p, Offset</code>. (Store) Type inferred from <code>x</code>.\nStoreNoOffset(imms=(flags: ir::MemFlags), vals=2, blocks=0)\n<code>a = swiden_high x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = swiden_low x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = swizzle x, y</code>. (Binary)\n<code>a = symbol_value GV</code>. (UnaryGlobalValue)\nTernary(imms=(), vals=3, blocks=0)\nTernaryImm8(imms=(imm: ir::immediates::Uimm8), vals=2, …\n<code>a = tls_value GV</code>. (UnaryGlobalValue)\nTrap(imms=(code: ir::TrapCode), vals=0, blocks=0)\n<code>trap code</code>. (Trap)\n<code>trapnz c, code</code>. (CondTrap) Type inferred from <code>c</code>.\n<code>trapz c, code</code>. (CondTrap) Type inferred from <code>c</code>.\n<code>a = trunc x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a, of = uadd_overflow x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = uadd_overflow_trap x, y, code</code>. (IntAddTrap) Type …\n<code>a = uadd_sat x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = udiv x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = udiv_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = uextend x</code>. (Unary)\n<code>a = uload16 MemFlags, p, Offset</code>. (Load)\n<code>a = uload16x4 MemFlags, p, Offset</code>. (Load) Type inferred …\n<code>a = uload32 MemFlags, p, Offset</code>. (Load) Type inferred from …\n<code>a = uload32x2 MemFlags, p, Offset</code>. (Load) Type inferred …\n<code>a = uload8 MemFlags, p, Offset</code>. (Load)\n<code>a = uload8x8 MemFlags, p, Offset</code>. (Load) Type inferred …\n<code>a = umax x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = umin x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a, of = umul_overflow x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = umulhi x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = unarrow x, y</code>. (Binary) Type inferred from <code>x</code>.\nUnary(imms=(), vals=1, blocks=0)\nUnaryConst(imms=(constant_handle: ir::Constant), vals=0, …\nUnaryGlobalValue(imms=(global_value: ir::GlobalValue), …\nUnaryIeee16(imms=(imm: ir::immediates::Ieee16), vals=0, …\nUnaryIeee32(imms=(imm: ir::immediates::Ieee32), vals=0, …\nUnaryIeee64(imms=(imm: ir::immediates::Ieee64), vals=0, …\nUnaryImm(imms=(imm: ir::immediates::Imm64), vals=0, …\n<code>a = urem x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = urem_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = ushr x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = ushr_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a, of = usub_overflow x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = usub_sat x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = uunarrow x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = uwiden_high x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = uwiden_low x</code>. (Unary) Type inferred from <code>x</code>.\n<code>s = vall_true a</code>. (Unary) Type inferred from <code>a</code>.\nSome instructions use an external list of argument values …\nMemory pool for holding value lists. See <code>ValueList</code>.\nA value type set describes the permitted set of types for …\n<code>s = vany_true a</code>. (Unary) Type inferred from <code>a</code>.\nA variable list of <code>Value</code> operands used for function call …\n<code>a = vconst N</code>. (UnaryConst)\n<code>x = vhigh_bits a</code>. (Unary)\n<code>a = x86_blendv c, x, y</code>. (Ternary) Type inferred from <code>x</code>.\n<code>a = x86_cvtt2dq x</code>. (Unary)\n<code>a = x86_pmaddubsw x, y</code>. (Binary)\n<code>a = x86_pmulhrsw x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = x86_pshufb x, y</code>. (Binary)\nAll cranelift opcodes.\nReturn information about a call instruction.\nAppend an argument to the block args.\nReturn a slice for the arguments of this block.\nReturn a slice for the arguments of this block.\nGet the value arguments to this instruction.\nGet mutable references to the value arguments to this …\nIf this is an atomic read/modify/write instruction, return …\nReturn the block for this BlockCall.\nGet the destinations of this instruction, if it’s a …\nGet a mutable slice of the destinations of this …\nCan this instruction read from memory?\nCan this instruction write to memory?\nCan this instruction cause a trap?\nClear out the arguments list.\nIf this is a control-flow instruction depending on an …\nGet the constraint descriptor for this opcode. Panic if …\nDoes <code>typ</code> belong to this set?\nGet the typeset of allowed types for the controlling type …\nDeep-clone the underlying list in the same pool. The …\nDeep-clone an <code>InstructionData</code>, including any referenced …\nReturn a value that can display this block call.\nAllowed dynamic vectors minimum lane sizes\nCompare two <code>InstructionData</code> for equality.\nGet an example member of this type set.\nAppends multiple elements to the arguments.\nAllowed float widths\nGet the instruction format for this opcode.\nIf this is a control-flow instruction depending on a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nParse an Opcode name from a string.\nHash an <code>InstructionData</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert this to a value list in <code>pool</code> with <code>fixed</code> prepended.\nAllowed int widths\nTrue for all branch or jump instructions.\nIs this a call instruction?\nCheck if the list is empty.\nIs this instruction polymorphic?\nIs this a return instruction?\nIs this instruction a GC safepoint?\nTrue for instructions that terminate the block\nAllowed lane sizes\nIf this is a load/store instruction, returns its immediate …\nReplace the values used in this instruction according to …\nIf this is a load/store instruction, return its memory …\nConstruct a BlockCall with the given block and arguments.\nCreate an empty argument list.\nGet the number of <em>fixed</em> result values produced by this …\nGet the number of <em>fixed</em> input values required by this …\nGet the opcode of this instruction.\nDoes this instruction have other side effects besides can_*…\nAdd an argument to the end.\nRemove the argument at ix from the argument list.\nIs it necessary to look at the designated value input …\nGet the value type of result number <code>n</code>, having resolved the …\nReplace the block for this BlockCall.\nDespite having side effects, is this instruction okay to …\nIf this instruction references a stack slot, return it\nIf this is a trapping instruction, get its trap code. …\nIf this is a trapping instruction, get an exclusive …\nGet the controlling type variable operand.\nCan the controlling type variable for this opcode be …\nGet the value type of input value number <code>n</code>, having …\nA wrapper for the context required to display a …\nContents of a jump table.\nThe jump table and default block as a single slice. The …\nThe jump table and default block as a single mutable …\nAccess the jump table as a mutable slice. This excludes …\nAccess the jump table as a slice. This excludes the …\nClears all entries in this jump table, except for the …\nFetch the default block for this jump table.\nMutable access to the default block of this jump table.\nReturn a value that can display the contents of this jump …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns an iterator to the jump table, excluding the …\nReturns an iterator that allows modifying each value, …\nCreate a new jump table with the provided blocks.\nIterate over blocks in layout order. See …\nIterate over instructions in a block in layout order. See …\nThe <code>Layout</code> struct determines the layout of blocks and …\nInsert <code>block</code> as the last block in the layout.\nAppend <code>inst</code> to the end of <code>block</code>.\nReturns the capacity of the <code>BlockData</code> map.\nIterate over the instructions in <code>block</code> in layout order.\nReturn an iterator over all blocks in layout order.\nClear the layout.\nGet the function’s entry block. This is simply the first …\nFetch a block’s first instruction.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInsert <code>block</code> in the layout before the existing block <code>before</code>…\nInsert <code>block</code> in the layout <em>after</em> the existing block <code>after</code>.\nInsert <code>inst</code> before the instruction <code>before</code> in the same …\nGet the block containing <code>inst</code>, or <code>None</code> if <code>inst</code> is not …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs <code>block</code> currently part of the layout?\nIs the given block cold?\nGet the last block in the layout.\nFetch a block’s last instruction.\nCreate a new empty <code>Layout</code>.\nGet the block following <code>block</code> in the layout order.\nFetch the instruction following <code>inst</code>.\nGet the block containing the program point <code>pp</code>. Panic if <code>pp</code> …\nCompare the program points <code>a</code> and <code>b</code> in the same block …\nGet the block preceding <code>block</code> in the layout order.\nFetch the instruction preceding <code>inst</code>.\nRemove <code>block</code> from the layout.\nRemove <code>inst</code> from the layout.\nMark a block as “cold”.\nSplit the block containing <code>before</code> in two.\nAccess to a field via the wrong type.\nThe base part of a bound expression.\nA comparison result between two dynamic values with a …\nA “conflict fact”: this fact results from merging two …\nA definition of a value to be used as a symbol in …\nA pointer to a memory type, dynamically bounded. The …\nA value bounded by a global value.\nContains the error value\nA bound expression.\nA fact on a value.\nA “context” in which we can evaluate and derive facts. …\nA global value.\nThe two kinds of inequalities: “strict” (<code>&lt;</code>, <code>&gt;</code>) and “…\nAccess to an invalid or undefined field offset in a struct.\nStore of data to a field with a fact that does not subsume …\nLoose inequality: {less,greater}-than-or-equal.\nTop of the address space. This is “saturating”: the …\nA pointer to a memory type.\nAn input to an operator that produces a fact-annotated …\nNo dynamic part (i.e., zero).\nContains the success value\nA memory access is out of bounds.\nAn operation wraps around, invalidating the stated value …\nAn error or inconsistency discovered when checking …\nThe result of checking proof-carrying-code facts.\nA bitslice of a value (up to a bitwidth) is within the …\nStrict inequality: {less,greater}-than.\nProof-carrying-code checking is not implemented for a …\nProof-carrying-code checking is not implemented for a …\nA block parameter claims a fact that one of its …\nA derivation of an output fact is unsupported (incorrect or\nAn SSA Value as a symbolic value. This can be referenced in\nStore to a read-only field.\nComputes whatever fact can be known about the sum of two …\nApply a known inequality to rewrite dynamic bounds using …\nIs this a constant value of the given bitwidth? Return it …\nIs this fact a single-value range with a symbolic Expr?\nThe dynamic (base) part.\nTop-level entry point after compilation: this checks the …\nCreate a range fact that specifies a single known constant …\nConstant value.\nCreate a dynamic range fact that points to the base of a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a fact that specifies the value is exactly the …\nThe value of a global value.\nCreate a fact that specifies the value is exactly the …\nTry to infer a minimal fact for a value of the given IR …\nMerge two facts. We take the <em>intersection</em>: that is, we know\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDoes this dynamic_expression take an offset?\nCheck a load, and determine what fact, if any, the result …\nCreate a range fact that specifies the maximum range for a …\nCreate a range fact that specifies the maximum range for a …\nCreate a new “fact context” in which to evaluate facts.\nOffsets a value with a fact by a known amount.\nAdd a static offset to an expression.\nThe static (offset) part.\nDoes this fact “propagate” automatically, i.e., cause …\nScales a value with a fact by a known constant.\nComputes the <code>sextend</code> of a value with the given facts.\nLeft-shifts a value with a fact by a known constant.\nCheck a store.\nGet the access struct field, if any, by a pointer with the …\nComputes whether <code>lhs</code> “subsumes” (implies) <code>rhs</code>.\nComputes whether the optional fact <code>lhs</code> subsumes (implies) …\nComputes the bit-truncation of a value with the given fact.\nComputes the <code>uextend</code> of a value with the given facts.\nCompute the union of two facts, if possible.\nCreate a fact that specifies the value is exactly an SSA …\nThe value of an SSA value.\nCreate a fact that specifies the value is exactly an SSA …\nIs this Expr a BaseExpr with no offset? Return it if so.\nThe bitwidth of bits we care about, from the LSB upward.\nThe bitwidth of bits we care about, from the LSB upward.\nThe kind of comparison.\nThe left-hand side of the comparison.\nThe maximum value that the bitslice can take (inclusive). …\nThe upper bound, inclusive.\nThe upper bound, inclusive.\nThe maximum offset into the memory type, inclusive.\nThe minimum value that the bitslice can take (inclusive). …\nThe lower bound, inclusive.\nThe lower bound, inclusive.\nThe minimum offset into the memory type, inclusive.\nThis pointer can also be null.\nThis pointer can also be null.\nThe right-hand side of the comparison.\nThe memory type.\nThe memory type.\nThe SSA value this value defines.\nContents of a dynamic stack slot.\nAll allocated dynamic stack slots.\nAn explicit stack slot for dynamic vector types. This is a …\nAn explicit stack slot. This is a chunk of stack memory …\nThe size of an object on the stack, or the size of a stack …\nContents of a stack slot.\nThe kind of a stack slot.\nAll allocated stack slots.\nAlignment of stack slot as a power-of-two exponent (log2 …\nGet the alignment in bytes of this stack slot given the …\nThe type of this slot.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe kind of stack slot.\nThe kind of stack slot.\nCreate a stack slot with the specified byte size and …\nCreate a stack slot with the specified byte size.\nSize of stack slot in bytes.\nA 128-bit floating point type represented in the IEEE …\nA SIMD vector with 2 lanes containing a <code>f128</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 4 lanes containing a <code>f128</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nA 16-bit floating point type represented in the IEEE …\nA SIMD vector with 16 lanes containing a <code>f16</code> each.\nA dynamically-scaled SIMD vector with a minimum of 16 …\nA SIMD vector with 2 lanes containing a <code>f16</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 32 lanes containing a <code>f16</code> each.\nA dynamically-scaled SIMD vector with a minimum of 32 …\nA SIMD vector with 4 lanes containing a <code>f16</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nA SIMD vector with 8 lanes containing a <code>f16</code> each.\nA dynamically-scaled SIMD vector with a minimum of 8 lanes …\nA 32-bit floating point type represented in the IEEE …\nA SIMD vector with 16 lanes containing a <code>f32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 16 …\nA SIMD vector with 2 lanes containing a <code>f32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 4 lanes containing a <code>f32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nA SIMD vector with 8 lanes containing a <code>f32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 8 lanes …\nA 64-bit floating point type represented in the IEEE …\nA SIMD vector with 2 lanes containing a <code>f64</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 4 lanes containing a <code>f64</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nA SIMD vector with 8 lanes containing a <code>f64</code> each.\nA dynamically-scaled SIMD vector with a minimum of 8 lanes …\nAn integer type with 128 bits.\nA SIMD vector with 2 lanes containing a <code>i128</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 4 lanes containing a <code>i128</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nAn integer type with 16 bits. WARNING: arithmetic on 16bit …\nA SIMD vector with 16 lanes containing a <code>i16</code> each.\nA dynamically-scaled SIMD vector with a minimum of 16 …\nA SIMD vector with 2 lanes containing a <code>i16</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 32 lanes containing a <code>i16</code> each.\nA dynamically-scaled SIMD vector with a minimum of 32 …\nA SIMD vector with 4 lanes containing a <code>i16</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nA SIMD vector with 8 lanes containing a <code>i16</code> each.\nA dynamically-scaled SIMD vector with a minimum of 8 lanes …\nAn integer type with 32 bits.\nA SIMD vector with 16 lanes containing a <code>i32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 16 …\nA SIMD vector with 2 lanes containing a <code>i32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 4 lanes containing a <code>i32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nA SIMD vector with 8 lanes containing a <code>i32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 8 lanes …\nAn integer type with 64 bits.\nA SIMD vector with 2 lanes containing a <code>i64</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 4 lanes containing a <code>i64</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nA SIMD vector with 8 lanes containing a <code>i64</code> each.\nA dynamically-scaled SIMD vector with a minimum of 8 lanes …\nAn integer type with 8 bits. WARNING: arithmetic on 8bit …\nA SIMD vector with 16 lanes containing a <code>i8</code> each.\nA dynamically-scaled SIMD vector with a minimum of 16 …\nA SIMD vector with 2 lanes containing a <code>i8</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 32 lanes containing a <code>i8</code> each.\nA dynamically-scaled SIMD vector with a minimum of 32 …\nA SIMD vector with 4 lanes containing a <code>i8</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nA SIMD vector with 64 lanes containing a <code>i8</code> each.\nA dynamically-scaled SIMD vector with a minimum of 64 …\nA SIMD vector with 8 lanes containing a <code>i8</code> each.\nA dynamically-scaled SIMD vector with a minimum of 8 lanes …\nNot a valid type. Can’t be loaded or stored. Can’t be …\nThe type of an SSA value.\nGet a type with the same number of lanes as this type, but …\nGet the type of a comparison result for the given type. …\nGet a type with the same number of lanes as this type, but …\nGet the total number of bits used to represent this type.\nGet the (minimum, maximum) values represented by each lane …\nGet a SIMD vector type with <code>n</code> times more lanes than this …\nGet the number of bytes used to store this type in memory.\nGet a type with the same number of lanes as this type, but …\nConvert a dynamic vector type to a fixed one.\nReturns the argument unchanged.\nGet a type with the same number of lanes as this type, but …\nIndex of this type, for use with hash tables etc.\nGet an integer type with the requested number of bits.\nGet an integer type with the requested number of bytes.\nCalls <code>U::from(self)</code>.\nIs this a SIMD vector type with a runtime number of lanes?\nIs this a scalar floating point type?\nIs this a scalar integer type?\nIs this the INVALID type?\nIs this a lane type?\nIs this a special type?\nIs this a SIMD vector type?\nGet the number of bits in a lane.\nGet the number of lanes in this SIMD vector type.\nThe type transformation that returns the lane type of a …\nGet the lane type of this SIMD vector type.\nGet log_2 of the number of bits in a lane.\nGet log_2 of the number of lanes in this SIMD vector type.\nGet log_2 of the number of lanes in this vector/dynamic …\nMerge lanes to half the number of lanes and double the …\nGet the minimum number of bits used to represent this type.\nGet the minimum of lanes in this SIMD vector type, this …\nSplit the lane width in half and double the number of …\nReturn the pointer type for the given target triple.\nConvert a fixed vector type to a dynamic one.\nTrue iff:\nThe string names of all the supported, but possibly not …\nMac aarch64 calling convention, which is a tweaked aarch64 …\nType alias of <code>IsaBuilder</code> used for building Cranelift’s …\nCalling convention identifiers.\nSmallest caller code size, not ABI-stable.\nBest performance, not ABI-stable.\nFunction alignment specifications as required by an ISA, …\nBuilder for a <code>TargetIsa</code>. Modify the ISA-specific settings …\nAfter determining that an instruction doesn’t have an …\nDescribes reason for target lookup failure\nThe type of a polymorphic TargetISA object which is ’…\nSpecialized convention for the probestack function.\nSupport for this target was disabled in the current build.\nSystem V-style convention used on many platforms.\nSupports tail calls, not ABI-stable.\nThis struct provides information that a frontend may need …\nMethods that are specialized to a target ISA.\nSupport for this target has not yet been implemented.\nWasmtime equivalent of SystemV, not ABI-stable.\nThe winch calling convention, not ABI-stable.\nWindows “fastcall” convention, also used for x64 and …\nCompile the given function.\nCreates a new System V Common Information Entry for the …\nGet the default calling convention of this target.\nThe default calling convention of the target.\nGet the ISA-dependent maximum vector register size, in …\nCreates unwind information for the function.\nGet the endianness of this ISA.\nIs the calling convention extending the Apple aarch64 ABI?\nIs the calling convention extending the Windows Fastcall …\nCombine the ISA-specific settings with the provided …\nGet the ISA-independent flags that were used to make this …\nReturns the calling convention used for libcalls according …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new Builder from a TargetIsa, copying all flags …\nGet the information needed by frontends producing …\nReturns the minimum function alignment and the preferred …\nReturns whether this ISA has a native …\nReturns whether the CLIF <code>x86_blendv</code> instruction is …\nReturns whether the CLIF <code>x86_pmaddubsw</code> instruction is …\nReturns whether the CLIF <code>x86_pmulhrsw</code> instruction is …\nReturns whether the CLIF <code>x86_pshufb</code> instruction is …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet a flag indicating whether branch protection is enabled.\nGet the ISA-dependent flag values that were used to make …\nIterates the available settings in the builder.\nLook for an ISA for the given <code>triple</code>. Return a builder …\nLook for a supported ISA with the given <code>name</code>. Return a …\nMap a regalloc::Reg to its corresponding DWARF register.\nThe minimum alignment required by an ISA, where all …\nGet the name of this ISA.\nCreates a new ISA-builder from its components, namely the …\nThe log2 of the target’s page size and alignment.\nThe log2 of the target’s page size and alignment.\nGet the width of pointers on this ISA, in units of bits.\nGet the width of pointers on this target, in units of bits.\nGet the width of pointers on this ISA, in units of bytes.\nGet the width of pointers on this target, in units of …\nGet the pointer type of this ISA.\nGet the pointer type of this target.\nThe pointer width of the target.\nA “preferred” alignment which should be used for more …\nDoes this calling convention support tail calls?\nReturns the minimum symbol alignment for this ISA.\nReturns an object that can be used to build the text …\nGet the target triple that was used to make this trait …\nGets the triple for the builder.\nReturn the default calling convention for the given target …\nRepresents information relating to function unwinding.\nCreate a polymorphic TargetIsa from this specific …\nX86_64-bit Instruction Set Architecture.\nDefines if the aarch64-specific pointer authentication …\nCFA-based unwind information used on SystemV.\nThe frame-pointer register for this architecture has just …\nNo unwind info.\nThe frame-pointer register for this architecture has just …\nThe stack slot at the given offset from the clobber-area …\nThe stack pointer was adjusted to allocate the stack.\nSystemV CIE/FDE unwind info.\nSystem V ABI unwind information.\nRepresents unwind information for a single function.\nExpected unwind info type.\nUnwind pseudoinstruction used in VCode backends: …\nWindows X64 Unwind info\nWindows x64 ABI unwind information.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSystem V ABI unwind information.\nWindows x64 ABI unwind information.\nThe offset from the start of the clobber area to this …\nThe offset from the current SP and FP value downward to …\nThe offset from the current SP (after push) to the SP at …\nThe offset from the current SP and FP value upward to the …\nThe saved register.\nWhether return addresses (hold in LR) contain a …\nSize to allocate.\nEnumerate the errors possible in mapping Cranelift …\nRepresents unwind information for a single System V ABI …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts the unwind information into a …\nRepresents Windows x64 unwind information.\nEmits the unwind information into the given mutable byte …\nGets the emit size of the unwind information, in bytes.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nConstant state used during emissions of a sequence of …\nState carried between emissions of a sequence of …\nInternal type MInst: defined at src/isa/x64/inst.isle line …\nInstruction operand sub-components (aka “parts”): …\nCreates a new x86-64 common information entry (CIE).\nEmit unwind info for an x86 target.\nContains the encoding machinery for the various x64 …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a constant state for emission of instructions.\nx86 Settings.\nAdd with carry.\nAdd operation.\nInternal type AluRmROpcode: defined at …\nSome basic ALU operations.\nInternal type Amode: defined at src/isa/x64/inst.isle line …\nBitwise AND operation.\nInternal type Avx512Opcode: defined at …\nInternal type AvxOpcode: defined at src/isa/x64/inst.isle …\n&lt; unsigned\n&lt;= unsigned\nByte -&gt; Longword.\nByte -&gt; Quadword.\nBit-scan forward.\nBit-scan reverse.\nThese indicate condition code tests.  Not all are …\nCMP instruction: compute <code>a - b</code> and set flags from result.\nComparison operations.\nA virtual offset to a constant that will be emitted in the …\nInternal type DivSignedness: defined at …\nEqual comparison.\nThis defines the ways a value can be extended: either …\nThese indicate ways of extending (widening) a value, using …\nEncode the ways that floats can be compared. This is used …\nAn x64 memory fence kind.\nAn extension trait for converting <code>Writable&lt;Reg&gt;</code> to …\nA newtype wrapper around <code>Reg</code>.\nA newtype wrapper around <code>RegMem</code> for general-purpose …\nA newtype wrapper around <code>RegMemImm</code>.\nAn immediate operand.\n8-bit immediate operand.\nA newtype wrapper around <code>Imm8Reg</code>.\nAn operand which is either an 8-bit integer immediate or a …\nA newtype wrapper around <code>Imm8Reg</code>.\nA (virtual) offset into the incoming argument area.\n&lt; signed\n&lt;= signed\n<code>lfence</code> instruction (“Load Fence”)\nLongword -&gt; Quadword.\nLess than comparison.\nLess than or equal comparison.\nCounts leading zeroes (Leading Zero CouNT).\n<code>mfence</code> instruction (“Memory Fence”)\nA memory operand.\nA memory operand.\n= unsigned\nunsigned\n= signed\nsigned\nno overflow\nnot parity\nnot-negative\nnot-zero\nNo value.\nNo value.\nNo extension.\nNot equal comparison.\noverflow\nAn operand’s size in bits.\nOptional writable Gpr.\nOptional writable Gpr.\nBitwise inclusive OR.\nOrdered.\nparity\nCounts the number of ones (POPulation CouNT).\nA real amode.\nA register operand.\nA register operand.\nA register operand.\nAn operand which is either an integer Register or a value …\nAn operand which is either an integer Register, a value in …\nLeft rotation.\nRight rotation.\nRound down mode.\nEncode the rounding modes used as part of the Rounding …\nRound to nearest mode.\nRound up mode.\nRound to zero mode.\nnegative\n<code>sfence</code> instruction (“Store Fence”)\nInteger subtraction with borrow.\nThese indicate the form of a scalar shift/rotate: left, …\nLeft shift.\nReplicates the sign bit in the most significant bits.\nInserts zeros in the most significant bits.\nSign-extend.\n16-bit.\n32-bit.\n64-bit.\n8-bit.\nA (virtual) offset to the slot area of the function frame, …\nSome value of type <code>T</code>.\nSome value of type <code>T</code>.\nSome SSE operations requiring 2 operands r/m and r.\nInteger subtraction.\nA Memory Address. These denote a 64-bit value only. Used …\nTEST instruction: compute <code>a &amp; b</code> and set flags from result.\nAn extension trait for converting <code>Writable{Xmm,Gpr}</code> to …\nCounts trailing zeroes (Trailing Zero CouNT).\nInternal type UnaryRmRImmVexOpcode: defined at …\nUnary operations requiring register or memory and register …\nInternal type UnaryRmRVexOpcode: defined at …\nUnordered.\nUnordered or greater than comparison.\nUnordered of greater than or equal comparison.\nWord -&gt; Longword.\nWord -&gt; Quadword.\nWritable Gpr.\nWritable Gpr.\nA newtype wrapper around <code>Reg</code>.\nA newtype wrapper around <code>RegMem</code> for general-purpose …\nA newtype wrapper around <code>RegMem</code> for general-purpose …\nA newtype wrapper around <code>RegMemImm</code>.\nA newtype wrapper around <code>RegMemImm</code>.\nBitwise exclusive OR.\nzero\nZero-extend.\nBorrow this newtype as its underlying <code>Imm8Reg</code>.\nBorrow this newtype as its underlying <code>Imm8Reg</code>.\nBorrow this newtype as its underlying <code>Imm8Reg</code>.\nBorrow this newtype as its underlying <code>Imm8Reg</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert <code>Writable&lt;Reg&gt;</code> to <code>Writable{Xmm,Gpr}</code>.\nCreate an immediate operand.\nCreate an immediate sign-extended and register addressing …\nCreate a sign-extended-32-to-64 with register and shift …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a memory operand.\nCreate a memory operand.\nCreate this newtype from the given register, or return <code>None</code>…\nConstruct a <code>RegMem</code> newtype from the given <code>RegMem</code>, or return\nConstruct this newtype from the given <code>RegMemImm</code>, or return …\nConstruct this newtype from the given <code>Imm8Reg</code>, or return …\nCreate this newtype from the given register, or return <code>None</code>…\nConstruct a <code>RegMem</code> newtype from the given <code>RegMem</code>, or return\nConstruct a <code>RegMem</code> newtype from the given <code>RegMem</code>, or return\nConstruct this newtype from the given <code>RegMemImm</code>, or return …\nConstruct this newtype from the given <code>RegMemImm</code>, or return …\nConstruct this newtype from the given <code>Imm8Reg</code>, or return …\nCreate a real addressing mode.\nCreate a register operand.\nCreate a register operand.\nGet this newtype’s underlying <code>Reg</code>.\nGet this newtype’s underlying <code>Reg</code>.\nConvert this newtype into its underlying <code>RegMem</code>.\nConvert this newtype into its underlying <code>RegMem</code>.\nConvert this newtype into its underlying <code>RegMem</code>.\nConvert this newtype into its underlying <code>RegMemImm</code>.\nConvert this newtype into its underlying <code>RegMemImm</code>.\nConvert this newtype into its underlying <code>RegMemImm</code>.\nConvert <code>Writable{Xmm,Gpr}</code> to <code>Writable&lt;Reg&gt;</code>.\nWhat is the “TupleType” of this opcode, which affects …\nLike <code>Self::new(r).unwrap()</code> but with a better panic message …\nLike <code>Self::new(rm).unwrap()</code> but with better panic messages …\nLike <code>Self::new(rmi).unwrap()</code> but with better panic …\nLike <code>Self::new(imm8_reg).unwrap()</code> but with better panic …\nLike <code>Self::new(r).unwrap()</code> but with a better panic message …\nLike <code>Self::new(rm).unwrap()</code> but with better panic messages …\nLike <code>Self::new(rm).unwrap()</code> but with better panic messages …\nLike <code>Self::new(rmi).unwrap()</code> but with better panic …\nLike <code>Self::new(rmi).unwrap()</code> but with better panic …\nLike <code>Self::new(imm8_reg).unwrap()</code> but with better panic …\nSet the specified MemFlags to the Amode.\nThe 8-bit immediate value.\nThe underlying register.\nThe memory address.\nThe underlying register.\nThe memory address.\nThe underlying register.\nThe immediate value.\nThe downward offset from the start of the incoming …\nThe offset into the slot area.\nThe encoding formats in this module all require a way of …\nEncodes EVEX instructions. These instructions are those …\nAdd 1 byte to the code section.\nAdd 2 bytes to the code section.\nAdd 4 bytes to the code section.\nAdd 8 bytes to the code section.\nEncodes instructions in the standard x86 encoding mode. …\nEncodes VEX instructions. These instructions are those …\nDefines the EVEX context for the <code>L&#39;</code>, <code>L</code>, and <code>b</code> bits (bits …\nConstructs an EVEX-encoded instruction using a builder …\nDefines the EVEX masking behavior; masking support is …\nThe EVEX format allows defining rounding control in the <code>L&#39;</code> …\nThe EVEX format allows choosing a vector length in the <code>L&#39;</code> …\nDescribe the register index to use. This wrapper is a …\nEncode the <code>aaa</code> bits for merging with the P2 byte.\nEncode the <code>L&#39;</code>, <code>L</code>, and <code>b</code> bits (bits 6:4 of EVEX P2 byte) …\nEmit the EVEX-encoded instruction to the code sink:\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nSet the imm byte.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSet the length of the instruction . Note that there are …\nSet the opcode map byte of the instruction: None | 0F | …\nSet the mask to use. See section 2.6 in the Intel Software …\nConstruct a default EVEX instruction.\nSet the instruction opcode byte.\nSet the legacy prefix byte of the instruction: None | 66 | …\nSet the register to use for the <code>reg</code> bits; many …\nSet the register to use for the <code>rm</code> bits; many instructions …\nSet the “tuple type” which is used for 8-bit scaling …\nSet the <code>vvvvv</code> register; some instructions allow using this …\nSet the W bit, typically used to indicate an instruction …\nEncode the <code>z</code> bit for merging with the P2 byte.\nWe may need to include one or more legacy prefix bytes …\nNo prefix bytes.\nAllows using the same opcode byte in different “opcode …\nA small bit field to record a REX prefix specification:\nOperand Size Override – here, denoting “16-bit …\nOperand size override and Lock.\nOperand size override and same effect as F3.\nThe Lock prefix.\nREPNE, but no specific meaning here – is just an opcode …\nREP/REPE, but no specific meaning here – is just an …\nRequire that the REX prefix is emitted.\nEmit the rex prefix if the referenced register would …\nCreates a new RexPrefix for which the REX.W bit will be …\nEmit a unary instruction.\nEmit a ternary instruction.\nEmit a binary instruction.\nEncode the ModR/M byte.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrue if the REX prefix must always be emitted.\nTrue if 64-bit operands are used.\nBy default, set the W field, and don’t always emit.\nConstructs a VEX-encoded instruction using a builder …\nThe VEX format allows choosing a vector length in the <code>L</code> …\nEmit the VEX-encoded instruction to the provided buffer.\nReturns the argument unchanged.\nReturns the argument unchanged.\nSet the imm byte. Overrides a previously set Self::imm_reg …\nSet the imm byte when used for a register. The reg bits …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSet the length of the instruction.\nSet the opcode map byte of the instruction: None | 0F | …\nConstruct a default VEX instruction.\nSet the instruction opcode byte.\nSome instructions use the ModRM.reg field as an opcode …\nSet the legacy prefix byte of the instruction: None | 66 | …\nSet the register to use for the <code>reg</code> bits; many …\nSet the register to use for the <code>rm</code> bits; many instructions …\nSet the <code>vvvv</code> register; some instructions allow using this …\nSet the W bit, denoted by <code>.W1</code> or <code>.W0</code> in the instruction …\nFlags group <code>x86</code>.")
searchState.loadedDescShard("revm_precompile", 0, "revm-precompile\nBerlin spec made a change to:\nByzantium spec introduced\nCancun spec added\nFrontier spec.\nIstanbul spec introduced\nOsaka spec added changes to modexp precompile:\nPrague spec added bls precompiles …\nEthereum hardfork spec ids. Represents the specs where …\nPrecompile with address and function.\nPrecompiles contain map of precompile addresses to …\nReturns reference of address.\nReturns an iterator over the precompiles addresses.\nReturns the precompiles addresses as a set.\nReturns precompiles for Berlin spec.\nBlake2 precompile. More details in <code>run</code>\nBLS12-381 precompiles added in <code>EIP-2537</code> For more details …\nConstants specifying the precompile addresses for each …\nUtility functions for the BLS12-381 precompiles\nBN128 precompiles added in <code>EIP-1962</code>\nReturns precompiles for Byzantium spec.\nCalculate the linear cost of a precompile.\nReturns precompiles for Cancun spec.\nIs the given address a precompile.\nReturns complement of <code>other</code> in <code>self</code>.\nExtends the precompiles with the given precompiles.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the appropriate precompile Spec for the primitive …\nReturns the precompile for the given address.\nReturns the precompile for the given address.\nHash precompiles, it contains SHA-256 and RIPEMD-160 hash …\nReturns precompiles for Homestead spec.\nIdentity precompile returns\nReturns inner HashMap of precompiles.\nInterface for the precompiles. It contains the precompile …\nReturns intersection of <code>self</code> and <code>other</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsumes the type and returns all precompile addresses.\nIs the precompiles list empty.\nReturns precompiles for Istanbul spec.\nKZG point evaluation precompile added in <code>EIP-4844</code> For more …\nReturns the precompiles for the latest spec.\nReturns the number of precompiles.\nModexp precompile added in <code>EIP-198</code> and reprices in berlin …\nReturns the precompiles for the given spec.\nReturns precompiles for Osaka spec.\nReturns precompiles for Prague spec.\nReturns reference of precompile.\n<code>ecrecover</code> precompile.\nConst function for making an address by concatenating the …\nUtility function that precompiles use, padding and …\nBlake2 precompile\nBlake2 algorithm\nreference: https://eips.ethereum.org/EIPS/eip-152 input …\ngot IV from: …\nSIGMA from spec: …\nCompression function F takes as an argument the state …\nG function: https://tools.ietf.org/html/rfc7693#section-3.1\nBLS12-381 G1 add precompile. More details in <code>g1_add</code>\nBLS12-381 G1 msm precompile. More details in <code>g1_msm</code>\nBLS12-381 G2 add precompile. More details in <code>g2_add</code>\nBLS12-381 G2 msm precompile. More details in <code>g2_msm</code>\nBLS12-381 map fp2 to g2 precompile. More details in …\nBLS12-381 map fp to g1 precompile. More details in …\nBLS12-381 pairing precompile. More details in <code>pairing</code>\nReturns the BLS12-381 precompiles with their addresses.\nEIP-2537 BLS12_G1ADD precompile.\nG1 addition call expects <code>256</code> bytes as an input that is …\nEIP-2537 BLS12_G1MSM precompile.\nImplements EIP-2537 G1MSM precompile. G1 …\nEIP-2537 BLS12_G2ADD precompile.\nG2 addition call expects <code>512</code> bytes as an input that is …\nEIP-2537 BLS12_G2MSM precompile.\nImplements EIP-2537 G2MSM precompile. G2 …\nEIP-2537 BLS12_MAP_FP2_TO_G2 precompile.\nField-to-curve call expects 128 bytes as an input that is …\nEIP-2537 BLS12_MAP_FP_TO_G1 precompile.\nField-to-curve call expects 64 bytes as an input that is …\nEIP-2537 BLS12_PAIRING precompile.\nPairing call expects 384*k (k being a positive integer) …\nDiscounts table for G1 MSM as a vector of pairs …\nDiscounts table for G2 MSM as a vector of pairs …\nFP_LENGTH specifies the number of bytes needed to …\nFP_PAD_BY specifies the number of bytes that an FP_ELEMENT …\nG1 add precompile address\nG1_ADD_BASE_GAS_FEE specifies the amount of gas needed to …\nG1_ADD_INPUT_LENGTH specifies the number of bytes that the …\nG1_LENGTH specifies the number of bytes needed to …\nG1 msm precompile address\nG1_MSM_BASE_GAS_FEE specifies the base amount of gas …\nG1_MSM_INPUT_LENGTH specifies the number of bytes that …\nG2 add precompile address\nG2_ADD_BASE_GAS_FEE specifies the amount of gas needed to …\nG2_ADD_INPUT_LENGTH specifies the number of bytes that the …\nG2 msm precompile address\nG2_MSM_BASE_GAS_FEE specifies the base amount of gas …\nG2_MSM_INPUT_LENGTH specifies the number of bytes that …\nMap fp2 to g2 precompile address\nMAP_FP2_TO_G2_BASE_GAS_FEE specifies the amount of gas …\nMap fp to g1 precompile address\nMAP_FP_TO_G1_BASE_GAS_FEE specifies the amount of gas …\nMSM_MULTIPLIER specifies the division constant that is …\nPADDED_FP2_LENGTH specifies the number of bytes that the …\nPADDED_FP_LENGTH specifies the number of bytes that the …\nPADDED_G1_LENGTH specifies the number of bytes that the …\nPADDED_G2_LENGTH specifies the number of bytes that the …\nPairing precompile address\nPAIRING_INPUT_LENGTH specifies the number of bytes that …\nPAIRING_MULTIPLIER_BASE specifies the slope/gradient for …\nPAIRING_OFFSET_BASE specifies the y-intercept for the …\nSCALAR_LENGTH specifies the number of bytes needed to …\nSCALAR_LENGTH_BITS specifies the number of bits needed to …\nImplements the gas schedule for G1/G2 …\nInput length for the add operation. <code>ADD</code> takes two …\nInput length for the multiplication operation. <code>MUL</code> takes …\nPair element length. <code>PAIR</code> elements are composed of an …\nBn128 add precompile\nBn128 mul precompile\nBn128 pair precompile\nRun the Bn128 add precompile\nRun the Bn128 mul precompile\nRun the Bn128 pair precompile\nBn128 add precompile address\nBn128 add precompile with BYZANTIUM gas rules\nBn128 add precompile with BYZANTIUM gas rules\nBn128 add precompile with ISTANBUL gas rules\nBn128 add precompile with ISTANBUL gas rules\nBn128 mul precompile address\nBn128 mul precompile with BYZANTIUM gas rules\nBn128 mul precompile with BYZANTIUM gas rules\nBn128 mul precompile with ISTANBUL gas rules\nBn128 mul precompile with ISTANBUL gas rules\nBn128 pair precompile address\nBn128 pair precompile with BYZANTIUM gas rules\nBn128 pair precompile with BYZANTIUM gas rules\nBn128 pair precompile with BYZANTIUM gas rules\nBn128 pair precompile with ISTANBUL gas rules\nBn128 pair precompile with ISTANBUL gas rules\nBn128 pair precompile with ISTANBUL gas rules\nRIPEMD-160 precompile\nSHA-256 precompile\nComputes the RIPEMD-160 hash of the input data\nComputes the SHA-256 hash of the input data\nAddress of the identity precompile.\nThe base cost of the operation\nThe cost per word\nTakes the input bytes, copies them, and returns it as the …\nBlake2 wrong final indicator flag\nBlake2 errors\nThe input length is not exactly 192 bytes\nThe commitment does not match the versioned hash\nThe proof verification failed\nBn128 affine g failed to create\nBn128 errors\nBn128 pair length\nContains the error value\nFatal error with a custom error message\nModexp base overflow\nModexp limit all input sizes.\nModexp errors\nModexp mod overflow\nContains the success value\nCatch-all variant for other errors\nout of gas is the main error. Others are here just for …\nPrecompile error type.\nPrecompile function type. Takes input and gas limit and …\nPrecompile execution output\nA precompile operation result type\nOutput bytes\nReturns the argument unchanged.\nReturns the argument unchanged.\nGas used by the precompile\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the error is out of gas.\nReturns new precompile output with the given gas used and …\nReturns another error with the given message.\nAddress of the KZG point evaluation precompile.\nGas cost of the KZG point evaluation precompile.\nKZG point evaluation precompile, containing address and …\n…\nVersioned hash version for KZG.\nConvert a slice to an array of a specific size.\nConvert a slice to a 32 byte big endian array.\nConvert a slice to a 48 byte big endian array.\n<code>VERSIONED_HASH_VERSION_KZG ++ sha256(commitment)[1..]</code>\nRun kzg point evaluation precompile.\nVerify KZG proof.\n<code>modexp</code> precompile with BERLIN gas rules.\n<code>modexp</code> precompile with BYZANTIUM gas rules.\n<code>modexp</code> precompile with OSAKA gas rules.\nCalculate gas cost according to EIP 2565: …\nSee: https://eips.ethereum.org/EIPS/eip-2565 Gas cost of …\nCalculate the gas cost for the modexp precompile with …\nSee: https://eips.ethereum.org/EIPS/eip-198 See: …\nCalculate the iteration count for the modexp precompile.\nCalculate gas cost.\nCalculate gas cost according to EIP-7883: …\nSee: https://eips.ethereum.org/EIPS/eip-7823 Gas cost of …\nRun the modexp precompile.\n<code>ecrecover</code> precompile, containing address and function to …\nbitcoin_secp256k1 implementation of <code>ecrecover</code>. More about …\n<code>ecrecover</code> precompile function. Read more about input and …\nk256 implementation of <code>ecrecover</code>. More about it in …\nRecover the public key from a signature and a message.\nRecover the public key from a signature and a message.\nConverts a boolean to a left-padded <code>B256</code> value.\nConverts a boolean to a left-padded 32-byte <code>Bytes</code> value.\nLeft-pads the given slice with zeroes until <code>LEN</code>.\nLeft-pads the given slice with zeroes until <code>len</code>.\nRight-pads the given slice with zeroes until <code>LEN</code>.\nRight-pads the given slice with zeroes until <code>len</code>.\nRight-pads the given slice at <code>offset</code> with zeroes until <code>LEN</code>.\nRight-pads the given slice at <code>offset</code> with zeroes until <code>len</code>.")
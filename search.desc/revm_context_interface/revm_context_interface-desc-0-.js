searchState.loadedDescShard("revm_context_interface", 0, "Optimism-specific constants, types, and helpers.\nDatabase error marker is needed to implement From …\nEVM database interface.\nThe database error type.\nGets basic account information.\nGets block hash by block number.\nGets account code by its hash.\nGets storage value of address at index.\nTrait for retrieving block information required for …\nThe base fee per gas, added in the London upgrade with …\nBeneficiary (Coinbase, miner) is a address that have …\nReturn <code>blob_excess_gas</code> header field. See EIP-4844.\nExcess blob gas and blob gasprice. See also …\nSee EIP-4844 and <code>calc_blob_gasprice</code>.\nThe difficulty of the block.\nThe gas limit of the block.\nThe number of ancestor blocks of this block (block height).\nThe output of the randomness beacon provided by the beacon …\nThe timestamp of the block in seconds since the UNIX epoch.\nStructure holding block blob excess gas and it calculates …\nThe calculated blob gas price based on the <code>excess_blob_gas</code>\nCalculates the blob gas price from the header’s excess …\nCalculates the <code>excess_blob_gas</code> from the parent header’s …\nThe excess blob gas of the block\nApproximates <code>factor * e ** (numerator / denominator)</code> using …\nReturns the argument unchanged.\nCalculate this block excess gas and price from the parent …\nCalls <code>U::from(self)</code>.\nCreates a new instance by calculating the blob gas price …\nPerform bytecode analysis\nWhat bytecode analysis to perform\nA transaction that calls a contract or transfer.\nA transaction that creates a contract.\nLegacy create scheme of <code>CREATE</code>\nCreate scheme of <code>CREATE2</code>\nCreate scheme\nCustom scheme where we set up the original address\nDo not perform bytecode analysis\nTransaction destination\nReturns the blob target and max count for the given spec …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSalt\nBlock type\nConfiguration type\nChain type\nInner Context error used for Interpreter to set error …\nTrait that defines the context of the EVM execution.\nCustom string error.\nDatabase error.\nDatabase type\nJournal type\nLocal context type\nRepresents the result of an <code>sstore</code> operation.\nResult of a selfdestruct action\nTransaction type\nGet the block\nGet the configuration\nGet the chain\nGet the chain reference\nGet the database\nGet the database reference\nGet the error\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the new value is equal to the present …\nReturns <code>true</code> if the new value is zero.\nReturns <code>true</code> if the original value is equal to the new …\nReturns <code>true</code> if the original value is equal to the present …\nReturns <code>true</code> if the original value is zero.\nReturns <code>true</code> if the present value is zero.\nGet the journal\nGet the journal reference\nGet the local context\nNew value that is set\nValue of the storage when it is first read\nCurrent value of the storage\nGet the transaction\nGet the transaction and journal. It is used to efficiently …\nGet the transaction and local context. It is used to …\nResult of the account load from Journal state\nCreate collision.\nSubRoutine checkpoint that will help us to go back from …\nTrait that contains database and journal of all changes …\nCaller does not have enough funds\nOverflow in target account\nState load information that contains the data and if the …\nTransfer and creation result\nCreates a checkpoint of the current state. State can be …\nCommits the changes made since the last checkpoint.\nReverts the changes made since the last checkpoint.\nCalled at the end of the transaction to clean all residue …\nReturns account code bytes and if address is cold loaded.\nGets code hash of account.\nCreates a checkpoint of the account creation.\nReturned data\nReturns the mutable database.\nReturns the database.\nReturns the depth of the journal.\nDoes cleanup and returns modified state.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIncrements the nonce of the account.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs account is cold loaded\nDoes account have delegate code and delegated account is …\nIs account empty, if <code>true</code> account is not created\nLoads the account.\nLoads the account code.\nLoads the account delegated.\nLogs the log in Journal state.\nMaps the data of the <code>StateLoad</code> to a new value.\nCreates new Journaled state.\nReturns a new <code>StateLoad</code> with the given data and cold load …\nReturns the addresses of the precompiles.\nMarks the account for selfdestruction and transfers all …\nSets bytecode and calculates hash.\nSets bytecode with hash. Assume that account is warm.\nSets the spec id.\nReturns the storage value from Journal state.\nStores the storage value in Journal state.\nLoads transient storage value.\nTouches the account.\nTransfers the balance from one account to another.\nStores transient storage value.\nWarms the account.\nWarms the account and storage.\nWarms the precompiles.\nLocal context used for caching initcode from Initcode …\nClear the local context.\nGet validated initcode by hash. if initcode is not …\nGet the local context\nInterpreter shared memory buffer. A reused memory buffer …\nSlice of the shared memory buffer returns None if range is …\nAccess list is not supported for blocks before the Berlin …\nEIP-7702 transaction has invalid fields set.\nEIP-7702 is not enabled.\nBlob transaction can’t be a create transaction.\nBlock <code>blob_gas_price</code> is greater than tx-specified …\nBlob transaction contains a versioned hash with an …\n<code>blob_hashes</code>/<code>blob_versioned_hashes</code> is not supported for …\nInitial gas for a Call is bigger than <code>gas_limit</code>.\n<code>gas_limit</code> in the tx is bigger than <code>block_gas_limit</code>.\nCreate init code size exceeds limit (runtime).\nError on created contract that begins with EF\nEIP-3860: Limit and meter initcode\nEIP-3860: Limit and meter initcode. Initcode size limit …\nCustom error\nDatabase error\nMain EVM error\nEIP-1559 is not supported.\nEIP-2930 is not supported.\nEIP-4844 is not supported.\nEIP-7702 is not supported.\nEIP-7873 initcode transaction should have <code>to</code> address.\nEIP-7873 is not supported.\nEmpty Authorization List is not allowed.\nThere should be at least one blob in Blob transaction.\nAux data overflow, new aux data is larger than u16 max …\nAux data is smaller than already present data size.\nEOF create should have <code>to</code> address\n<code>excess_blob_gas</code> is not set for Cancun and above.\nResult of a transaction execution\nGas floor calculated from EIP-7623 Increase calldata cost …\nEIP-1559: <code>gas_price</code> is less than <code>basefee</code>.\nReverted for various reasons and spend all gas\nIndicates that the EVM has experienced an exceptional halt.\nHeader validation error\nTransaction chain id does not match the config chain id.\nCheck for target address validity is only done inside …\nErrors related to misconfiguration of a <code>crate::Block</code>.\nTransaction validation error.\nTransaction account does not have enough amount of ether …\n<code>max_fee_per_blob_gas</code> is not supported for blocks before …\nNonce overflows in transaction.\nOutput of a transaction execution\nOverflow payment in transaction.\n<code>prevrandao</code> is not set for Merge and above.\nWhen using the EIP-1559 fee model introduced in the London …\nEIP-3607 Reject transactions from senders with deployed …\nReverted by <code>REVERT</code> opcode that doesn’t spend all gas\nEOF Subroutine stack overflow\nReturned successfully\nReason a transaction successfully completed.\nTransaction has more then <code>max</code> blobs\nTransaction validation error\nReturns the created address, if any.\nReturns created address if execution is Create transaction …\nReturns the output data of the execution output.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the gas used.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the output data of the execution output.\nConsumes <code>self</code> and returns the logs if execution is …\nConsumes the type and returns the output data of the …\nReturns true if execution result is a Halt.\nReturns if transaction execution is successful.\nReturns the logs if execution is successful, or an empty …\nMaps a <code>DBError</code> to a new error type using the provided …\nMaps a <code>DBError</code> to a new error type using the provided …\nMaps a <code>DBError</code> to a new error type using the provided …\nReturns the output data of the execution.\nStatus of execution\nState that got updated\nHalting will spend all the gas, and will be equal to …\nAccessList as defined in EIP-2930\nA list of addresses and storage keys that the transaction …\nAn unsigned EIP-7702 authorization.\nIndicates a failed recovery attempt where no valid address …\nRepresents the outcome of an attempt to recover the …\nA recovered authorization.\nA signed EIP-7702 authorization.\nMain Transaction trait that abstracts and specifies all …\nTransaction validity error types.\nIndicates a successfully recovered authority address.\nAccess list for the transaction.\nAdds an address to the access list and returns <code>true</code> if the …\nReturns an optional address if valid.\nGet the <code>address</code> for the authorization.\nAccount addresses that would be loaded at the start of …\nThe address of the authorization.\nReturns an optional address based on the current state of …\nList of authorizations, that contains the signature that …\nReturns length of the authorization list.\nReturns vector of fixed size hash(32 bytes)\nCalculates the maximum [EIP-4844] <code>data_fee</code> of the …\nCaller aka Author aka transaction signer.\nChain Id is optional for legacy transactions.\nGet the <code>chain_id</code> for the authorization.\nThe chain ID of the authorization.\nChecks if the access list contains the specified address.\nChecks if a specific storage slot within an account is …\nReturns the effective balance that is going to be spent …\nReturns effective gas price is gas price field for Legacy …\nReturns an iterator over the list’s addresses and …\nConverts the list into a vec, expected by revm\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe maximum amount of gas the transaction can use.\nGas price for the transaction. It is only applicable for …\nReturns the inner <code>Authorization</code>.\nReturns the input data of the transaction.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsumes the type and returns an iterator over the list’…\nConsumes the type and converts the list into a vec, …\nSplits the authorization into parts.\nRecover the authority and transform the signed …\nConvert to a signed authorization by adding a signature.\nReturns true if the authority is invalid.\nReturns true if the authority is valid.\nTransaction kind. It can be Call or Create.\nReturns the maximum balance that can be spent by the …\nMax fee per data gas\nReturns maximum fee that can be paid for the transaction.\nMaximum priority fee per gas.\nCreates a new signed authorization from raw signature …\nInstantiate without performing recovery. This should be …\nThe nonce of the transaction.\nGet the <code>nonce</code> for the authorization.\nThe nonce for the authorization.\nReturns the signature <code>r</code> value.\nRecover the authority for the authorization.\nReturns the signature <code>s</code> value.\nGets the <code>signature</code> for the authorization. Returns …\nComputes the signature hash used to sign the …\nCalculates a heuristic for the in-memory size of the …\nCalculates a heuristic for the in-memory size of the …\nKeys of storage that would be loaded at the start of …\nReturns the total number of storage keys in this access …\nReturns the inner <code>Authorization</code>.\nTotal gas for all blobs. Max number of blocks is already …\nReturns the transaction type.\nThe value sent to the receiver of <code>TxKind::Call</code>.\nReturns the signature parity value.\nAccess list type is introduced in EIP-2930, and every …\nReturns account address.\nReturns storage slot keys.\nAuthorization trait.\nReturns the address that this account is delegated to.\nAuthority address.\nReturns authorization the chain id.\nReturns the nonce.\nCustom type means that the transaction trait was extended …\nEIP-1559 Fee market change transaction type\nEIP-2930 Access List transaction type\nEIP-4844 Blob transaction type\nEIP-7702 Set EOA account code transaction type\nLegacy transaction type\nTransaction types of all Ethereum transaction\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.")
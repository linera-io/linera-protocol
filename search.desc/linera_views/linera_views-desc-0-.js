searchState.loadedDescShard("linera_views", 0, "This module is used in the Linera protocol to map complex …\nArithmetic error\nBCS serialization error.\nThe database is corrupt: Entries don’t have the expected …\nInput output error.\nThe key must not be too long\nThe database is corrupt: Some entries are missing\nThe entry does not exist in memory\nThe values are incoherent.\nErrors within the context can occur and are presented as …\nTokio errors can happen while joining.\nFailed to lock a reentrant collection entry since it is …\nMain error type for the crate.\nBackend implementing the <code>crate::store::KeyValueStore</code> trait.\nThe definition of the batches for writing in the database. …\nCommon definitions used for views and backends. This …\nThe <code>Context</code> trait and related definitions.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nDefinitions for the LRU cache. An LRU cache that supports …\nSupport for metrics.\nFunctions for random generation\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nThe <code>KeyValueDatabase</code> and <code>KeyValueStore</code> traits and related …\nHelper types for tests.\n<code>ToString::to_string</code>, but without panic on OOM.\nElementary data-structures implementing the <code>views::View</code> …\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nThe name of the backend that produced the error\nThe inner error\nImplements <code>crate::store::KeyValueStore</code> by combining two …\nImplements <code>crate::store::KeyValueStore</code> for the DynamoDB …\nTurns a <code>DirectKeyValueStore</code> into a <code>KeyValueStore</code> by adding …\nAdd LRU (least recently used) caching to a given store.\nImplements <code>crate::store::KeyValueDatabase</code> in memory.\nAdds metrics to a key-value store.\nImplements <code>crate::store::KeyValueStore</code> for the RocksDB …\nImplements <code>crate::store::KeyValueStore</code> for the ScyllaDB …\nAdds support for large values to a given store by …\nSerialization error with BCS.\nA dual database.\nA partition opened in one of the two databases.\nThe initial configuration of the system.\nThe error type for <code>DualStore</code>.\nThe trait for a (static) root key assignment.\nThe first store.\nThe first store.\nFirst store.\nThe second store.\nThe second store.\nSecond store.\nStore already exists during a create operation\nThe store in use.\nObtains the store assigned to this root key.\nThe first config.\nThe first database.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nThe second config.\nThe second database.\n<code>ToString::to_string</code>, but without panic on OOM.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nAn error occurred while batch getting items.\nA BCS error occurred.\nAn error occurred while building an object\nAn error occurred while creating the table.\nAn error occurred while deleting a table\nA shared DB client for DynamoDB with metrics\nDatabase-level connection to DynamoDB for managing …\nThe config type for <code>DynamoDbDatabase</code>`\nThe combined error type for <code>DynamoDbDatabase</code>.\nA DynamoDB client.\nThe initial configuration of the system.\nErrors that occur when using <code>DynamoDbStoreInternal</code>.\nAn error occurred while getting the item.\ninner store error\nallowed characters are lowercase letters, numbers, periods …\nError when validating a namespace\nA wrong namespace error occurred\nThe journal is not coherent\nThe key prefix must have at most 1024 bytes\nThe key must have at most 1024 bytes\nAn error occurred while listing tables\nThe stored key is missing.\nValue segment is missing from the database\nThe value attribute is missing.\nNo count of size <code>u32</code> is available in the value\nAn error occurred while doing a Query.\nThe namespace should be at most 63 characters.\nThe namespace should be at least 3 characters.\nThe key is of length less than 4, so we cannot extract the …\nThe transact maximum size is <code>MAX_TRANSACT_WRITE_ITEM_SIZE</code>.\nAn error occurred while writing a transaction of items.\nThe length of the value should be at most 400 KB.\nThe type of the keys was not correct (It should have been …\nThe value was stored as the wrong type (it should be a …\nKeys have to be of non-zero length.\nKey prefixes have to be of non-zero length.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe inner configuration of the <code>LruCachingStore</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaximum number of concurrent database queries allowed for …\nPreferred buffer size for async streams.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nThe cache size being used.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\nWhether to use DynamoDB local or not.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nCreates a <code>DynamoDbStoreInternalError::WrongKeyType</code> …\nCreates a <code>DynamoDbStoreInternalError::WrongValueType</code> …\nData type indicating that the database is not consistent\nA journaling key-value database.\nA journaling key-value store.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe read stuff does not change\nCreates a new journaling store.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\n<code>ToString::to_string</code>, but without panic on OOM.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nThe maximum number of entries in the cache. If the number …\nThe configuration type for the <code>LruCachingStore</code>.\nA key-value database with added LRU caching.\nA memory database with caching.\nA key-value store with added LRU caching.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe inner configuration of the <code>LruCachingStore</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nThe cache size being used.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nSerialization error with BCS.\nA connection to a namespace of key-values in memory.\nA virtual DB client where data are persisted in memory.\nThe initial configuration of the system\nThe error type for <code>MemoryStore</code>.\nThe namespace does not exist\nStore already exists during a create operation\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether a namespace should be immediately cleaned up from …\nPreferred buffer size for async streams.\nCreates a <code>MemoryStore</code> that doesn’t belong to any …\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\n<code>ToString::to_string</code>, but without panic on OOM.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nThe implementation of the <code>KeyValueStoreMetrics</code> for the …\nA metered database that keeps track of every operation.\nA metered store that keeps track of every operation.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreation of a named Metered counter.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nBCS serialization error.\nThis uses the <code>block_in_place</code> function of Tokio.\nFilesystem error\ninner store error\nError converting <code>OsString</code> to <code>String</code>\nNamespace contains forbidden characters\nThe key must have at most 8 MiB\nValue segment is missing from the database\nNo count of size <code>u32</code> is available in the value\nThe database contains a file which is not a directory\nA path and the guard for the temporary directory if needed\nRocksDB error.\nThe <code>RocksDbDatabase</code> composed type with metrics\nDatabase-level connection to RocksDB for managing …\nThe choice of the spawning mode. <code>SpawnBlocking</code> always …\nThe composed config type for the <code>RocksDbStore</code>\nThe composed error type for the <code>RocksDbStore</code>\nThe inner client\nThe initial configuration of the system\nThe error type for <code>RocksDbStoreInternal</code>\nThis uses the <code>spawn_blocking</code> function of Tokio.\nStore already exists\nTokio join error in RocksDB.\nThe key is of length less than 4, so we cannot extract the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nObtains the spawning mode from runtime.\nThe inner configuration of the <code>LruCachingStore</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPreferred buffer size for async streams.\nCreates a <code>PathWithGuard</code> from an existing path.\nThe path to the data\nThe path to the storage containing the namespaces\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nThe chosen spawn mode\nThe cache size being used.\n<code>ToString::to_string</code>, but without panic on OOM.\n<code>ToString::to_string</code>, but without panic on OOM.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nThe batch is too long to be written\nBCS serialization error.\nA deserialization error in ScyllaDB\nAn execution error in ScyllaDB\ninner store error\nA type error in the accessed data in ScyllaDB\nNamespace contains forbidden characters\nThe journal is not coherent\nThe key must have at most <code>MAX_KEY_SIZE</code> bytes\nValue segment is missing from the database\nA next row error in ScyllaDB\nNo count of size <code>u32</code> is available in the value\nA query error in ScyllaDB\nA prepare error in ScyllaDB\nA row error in ScyllaDB\nThe <code>ScyllaDbDatabase</code> composed type with metrics\nDatabase-level connection to ScyllaDB for managing …\nA query error in ScyllaDB\nThe <code>ScyllaDbStoreConfig</code> input type\nThe combined error type for the <code>ScyllaDbDatabase</code>.\nThe client itself and the keeping of the count of active …\nThe type for building a new ScyllaDB Key Value Store\nThe error type for <code>ScyllaDbStoreInternal</code>\nThe key is of length less than 4, so we cannot extract the …\nA type check error in ScyllaDB\nThe value must have at most <code>RAW_MAX_VALUE_SIZE</code> bytes\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe inner configuration of the <code>LruCachingStore</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaximum number of concurrent database queries allowed for …\nPreferred buffer size for async streams.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nThe replication factor.\nThe cache size being used.\n<code>ToString::to_string</code>, but without panic on OOM.\nThe URL to which the requests have to be sent\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\ninner store error\nA memory store for which the values are limited to 100 …\nValue segment is missing from the database\nNo count of size <code>u32</code> is available in the value\nThe key is of length less than 4, so we cannot extract the …\nA key-value database with no size limit for values.\nThe composed error type built from the inner error type.\nA key-value store with no size limit for values.\nProvides a <code>LimitedTestMemoryStore&lt;()&gt;</code> that can be used for …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new store that deals with big values from one …\nCreates a <code>LimitedTestMemoryStore</code>\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\n<code>ToString::to_string</code>, but without panic on OOM.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nA batch of write operations.\nAn iterator-like object that can write values one by one …\nDelete the given key.\nDelete all the keys matching the given prefix.\nA trait to expand <code>DeletePrefix</code> operations.\nThe error type that can happen when expanding the key …\nThe iterator type used to process values from the batch.\nSet or replace the value of a given key.\nA batch of deletions and insertions that operate on …\nThe iterator that corresponds to a <code>SimpleUnorderedBatch</code>\nA notion of batch useful for certain computations (notably …\nAn unordered batch of deletions and insertions, together …\nThe iterator that corresponds to a <code>SimpleUnorderedBatch</code>\nA write operation as requested by a view when it needs to …\nAdds the deletion of key to the batch.\nAdds the insertion of a key-value pair to the batch.\nBuilds a batch from a builder function.\nChecks the size of the values of the batch.\nInserts the deletion of a <code>key</code> into the batch.\nInserts the deletion of a <code>key_prefix</code> into the batch.\nThe deletions.\nModifies an <code>UnorderedBatch</code> so that the key-prefix …\nReturns the list of keys to be appended to the list.\nFrom an <code>UnorderedBatch</code>, creates a <code>SimpleUnorderedBatch</code> …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a simplified batch from a standard one.\nThe insertions.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns an owning iterator over the values in the batch.\nReturns true if there are no more values to write.\nWhether the batch is empty or not\nTests whether the batch is empty or not\nReturns true if the batch is empty.\nThe key-prefix deletions.\nReturns the total number of entries in the batch.\nThe total number of entries of the batch.\nCreates an empty batch.\nComputes the batch size that we would obtain if we wrote …\nReturns the total number of bytes in the batch.\nReturns the number of operations in this <code>Batch</code>.\nThe write operations.\nReturns the overhead size of the batch.\nAdds the insertion of a key-value pair into the batch with …\nAdds the insertion of a <code>(key, value)</code> pair into the batch …\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nThe batch of deletions and insertions.\nSimplifies the batch by removing operations that are …\nThe total size of the batch\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the next value (if any) to the batch and updates …\nThe key that will be deleted.\nThe key to be inserted or replaced.\nThe prefix of the keys to be deleted.\nThe value to be inserted on the key.\nSometimes we need a serialization that is different from …\nThe entry is removed.\nThe entry is set to the following.\nExtention trait for slices.\nAn update, for example to a view.\nSame as <code>chunks_exact</code> but we allow the <code>chunk_size</code> to be …\nReturns the argument unchanged.\nDeserializes an optional vector of <code>u8</code>\nDeserialize the vector\nCalls <code>U::from(self)</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nSerializes the value\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nA wrapper over <code>Vec&lt;u8&gt;</code> with functions for using it as a …\nThe context in which a view is operated. Typically, this …\nThe type of errors that may be returned by operations on …\nUser-provided data to be carried along.\nA context which can’t be used to read or write data, …\nAn implementation of <code>crate::context::Context</code> that stores …\nThe type of the key-value store used by this context.\nImplementation of the <code>Context</code> trait on top of a DB client …\nConcatenates the base key and index.\nGetter for the address of the base key.\nMutable getter for the address of the base key.\nConcatenates the base key and tag.\nConcatenates the base key, tag and index.\nThe byte value of the key prefix.\nObtains a similar <code>Context</code> implementation with a different …\nCreates a context suitable for a root view, using the …\nObtains the <code>Vec&lt;u8&gt;</code> key from the key by serialization and …\nObtains the short <code>Vec&lt;u8&gt;</code> key from the key by …\nObtains the <code>Vec&lt;u8&gt;</code> key from the key by serialization and …\nDeserialize <code>bytes</code> into type <code>Item</code>.\nGetter for the user-provided data.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a <code>Context</code> instance in memory for testing.\nCreates a <code>Context</code> instance in memory for testing.\nCreates a context for the given base key, store, and an …\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nGetter for the store.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nThe parametrization of the cache.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe maximum number of entries in the cache.\nThe maximum size of cached <code>find_key_values_by_prefix</code> …\nThe maximum size of cached <code>find_keys_by_prefix</code> results.\nThe maximum size of the cache, in bytes (keys size + value …\nThe maximum size of cached values.\nThe maximum size of a find-key-values entry size, in bytes.\nThe maximum size of a find-keys entry size, in bytes.\nThe maximum size of a value entry size, in bytes.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nIncrements the metrics counter with the given name, with …\nA deterministic RNG.\nA RNG that is non-deterministic if the platform supports …\nGet a random alphanumeric string that can be used for all …\nReturns a unique namespace for testing.\nReturns a deterministic RNG for testing.\nReturns a non-deterministic RNG where supported.\nThe name of the backend.\nThe batch type.\nThe configuration needed to interact with a new backend.\nA key-value store that can perform both read and direct …\nAsynchronous direct write key-value operations with …\nThe error type.\nThe definition of a key-value database.\nA key-value store that can perform both read and write …\nThe error type for the key-value stores.\nThe maximal number of items in a batch.\nThe maximal number of bytes of a batch.\nThe maximal size of keys that can be stored.\nThe maximal size of values that can be stored.\nThe maximal size of values that can be stored.\nAsynchronous read key-value operations.\nThe result of opening a partition.\nThe functions needed for testing purposes\nDefine an associated <code>KeyValueStoreError</code>.\nAsynchronous write key-value operations.\nClears any journal entry that may remain. The journal is …\nConnects to an existing namespace using the given …\nCreates a database for testing purposes\nTests whether a key exists in the database\nTests whether a list of keys exist in the database\nCreates a namespace. Returns an error if the namespace …\nDeletes the given namespace.\nDeletes all the existing namespaces.\nTests if a given namespace exists.\nFinds the <code>(key,value)</code> pairs matching the prefix. The …\nFinds the <code>key</code> matching the prefix. The prefix is not …\nThe name of this database.\nA module containing a dummy store used for caching views.\nObtains the list of existing namespaces.\nLists the root keys of the namespace. It is possible that …\nRetrieve the number of stream queries.\nInitializes a storage if missing and provides it.\nObtains a test config\nCreates a store for testing purposes\nOpens an exclusive partition starting at <code>root_key</code>. It is …\nOpens a shared partition starting at <code>root_key</code>. It is …\nReads multiple <code>keys</code> and deserializes the results if …\nRetrieves multiple <code>Vec&lt;u8&gt;</code> from the database using the …\nReads a single <code>key</code> and deserializes the result if present.\nRetrieves a <code>Vec&lt;u8&gt;</code> from the database using the provided …\nCreates a new storage. Overwrites it if this namespace …\nWrites the <code>batch</code> in the database.\nWrites the batch to the database.\nA store which does not actually store anything - used for …\nAn error struct for the inactive store.\nFinds the <code>(key,value)</code> pairs matching the prefix. The …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\n<code>ToString::to_string</code>, but without panic on OOM.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nThe size of the small value used for tests.\nBoth checks together.\nAdds a prefix to a list of key-values\nReading many keys at a time could trigger an error. This …\nA store can be in exclusive access where it stores the …\nTakes a random number generator, a <code>key_prefix</code> and extends …\nReturns a random key prefix used for tests\nA bunch of puts and some deletes.\nTakes a random number generator <code>rng</code>, a number n and …\nTakes a random number generator, a <code>key_prefix</code> and generates\nGenerates a list of random key-values with no duplicates\nBuilds a random k element subset of n\nWe build a number of scenarios for testing the reads.\nExercises the namespace functionalities of the …\nFunctions for computing the performance of stores.\nTests listing the root keys.\nDynamoDB has limits at 1 MB (for pagination), 4 MB (for …\nThis test starts with a collection of key/values being …\nWrites and then reads data under a prefix, and verifies …\nRun many operations on batches always starting from a …\nRun some deterministic and random batches operation and …\nA random reordering of the puts and deletes. For something …\nSome <code>View</code>s that are easy to use with test cases.\nThat test is especially challenging for ScyllaDB. In its …\nBenchmarks the <code>contains_key</code> operation.\nBenchmarks the <code>contains_keys</code> operation.\nBenchmarks the <code>find_keys_by_prefix</code> operation.\nBenchmarks the <code>find_keys_by_prefix</code> operation.\nBenchmarks the <code>read_multi_values_bytes</code> operation.\nBenchmarks the <code>read_value_bytes</code> operation.\nBenchmarks the <code>write_batch</code> operation.\nRepresentation of the view’s state.\nWrapper to test with a <code>BucketQueueView</code>.\nWrapper to test with a <code>CollectionView</code>.\nWrapper to test with a <code>LogView</code>.\nWrapper to test with a <code>MapView</code>.\nWrapper to test with a <code>QueueView</code>.\nWrapper to test with a <code>RegisterView</code>.\nWrapper to test with a <code>SetView</code>.\nA <code>View</code> to be used in test cases.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReads the view’s current state.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nStages some changes to the view that won’t be persisted …\nStages some changes to the view that will be persisted …\nPerforms some initial changes to the view, staging them, …\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nA view that can be shared (unsafely) by cloning it.\nThe type of context stored in this view\nA <code>RootView</code> that also supports crypto hash\nA <code>View</code> that also supports crypto hash\nA view that supports hashing its values.\nThe requirement for the hasher type in <code>HashableView</code>.\nHow to compute hashes.\nThe minimum value for the view tags. Values in …\nThe number of keys used for the initialization\nThe output type.\nA view which can have its context replaced.\nA <code>View</code> whose staged modifications can be saved in storage.\nThe type returned after replacing the context.\nA view gives exclusive access to read and write the data …\nThe <code>BucketQueueView</code> implements a queue that can push on …\nClears the view. That can be seen as resetting to default. …\nCreates a clone of this view, sharing the underlying …\nThe <code>CollectionView</code> implements a map structure whose keys …\nObtains a mutable reference to the internal context.\nComputing the hash and attributing the type to it. May …\nSame as <code>crypto_hash</code> but guaranteed to be wait-free.\nFinishes the hashing process and returns its output.\nPersists changes to storage. This leaves the view still …\nReturns <code>true</code> if flushing this view would result in changes …\nComputes the hash of the values.\nSame as <code>hash</code> but guaranteed to be wait-free.\nWrapping a view to memoize hashing.\nWrapping a view to compute hash based on the history of …\nThe implementation of a key-value store view. We implement …\nLoads a view\nThe <code>LogView</code> implements a log list that can be pushed.\nThe <code>MapView</code> implements a map with ordered keys. The <code>MapView</code>…\nBuilds a trivial view that is already deleted\nLoads a view from the values\nCreates the keys needed for loading the view\nThe <code>QueueView</code> implements a queue that can push on the back …\nThe <code>ReentrantCollectionView</code> implements a map structure …\nThe <code>RegisterView</code> implements a register for a single value.\nDiscards all pending changes. After that <code>flush</code> should have …\nSaves the root view to the database context\nThe <code>SetView</code> implements a set with ordered entries.\nSerializes a value with BCS and includes it in the hash.\nIncludes bytes in the hash.\nReturns a view with a replaced context.\nA view that supports a FIFO queue for values of type <code>T</code>. …\nType wrapping <code>QueueView</code> while memoizing the hash.\nWrapper around <code>BucketQueueView</code> to compute hashes based on …\nReturns the last element of a bucket queue view\nThe total number of entries of the container\nDeletes the front value, if any.\nReturns the list of elements in the queue.\nReturns the argument unchanged.\nGets a reference on the front value if any.\nReads the front value, if any.\nCalls <code>U::from(self)</code>.\nGets a mutable iterator on the entries of the queue\nPushes a value to the end of the queue.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReturns the last element of a bucket queue view\nReturns the first elements of a bucket queue view\nGets the number of entries in the container that are stored\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nA view that supports accessing a collection of views of …\nA view that supports accessing a collection of views of …\nA map view that serializes the indices.\nType wrapping <code>ByteCollectionView</code> while memoizing the hash.\nType wrapping <code>CollectionView</code> while memoizing the hash.\nType wrapping <code>CustomCollectionView</code> while memoizing the …\nWrapper around <code>ByteCollectionView</code> to compute hashes based …\nWrapper around <code>CollectionView</code> to compute hashes based on …\nWrapper around <code>CustomCollectionView</code> to compute hashes …\nThe view is loaded in the updates\nThe view is not loaded in the updates\nA read-only accessor for a particular subview in a …\nTests if the collection contains a specified key and …\nReturns the number of entries in the collection.\nReturns the number of entries in the collection.\nReturns the number of entries in the collection.\nGets the extra data.\nGets the extra data.\nGets the extra data.\nApplies a function f on each index. Indices are visited in …\nApplies a function on each index. Indices are visited in …\nApplies a function f on each index. Indices are visited in …\nApplies a function f on each index. Indices are visited in …\nApplies a function f on each index (aka key). Keys are …\nApplies a function f on each index (aka key). Keys are …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the list of indices in the collection in the order …\nReturns the list of indices in the collection in the order …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the list of keys in the collection. The order is …\nLoads a subview for the data at the given index in the …\nLoads a subview for the data at the given index in the …\nLoads a subview for the data at the given index in the …\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nMarks the entry as removed. If absent then nothing is done.\nRemoves an entry from the <code>CollectionView</code>. If absent …\nRemoves an entry from the <code>CollectionView</code>. If absent …\nResets an entry to the default value.\nResets an entry to the default value.\nMarks the entry so that it is removed in the next flush.\nLoad all entries for reading at once.\nLoad all entries for reading at once.\nLoad all entries for reading at once.\nLoad multiple entries for reading at once. The entries in …\nLoad multiple entries for reading at once. The entries in …\nLoad multiple entries for reading at once. The entries in …\nLoads multiple entries for reading at once with their keys.\nLoads multiple entries for reading at once with their keys.\nLoads multiple entries for reading at once with their keys.\nLoads a subview for the data at the given index in the …\nLoads a subview for the data at the given index in the …\nLoads a subview for the data at the given index in the …\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nThe guard for the updates. It is needed so that it prevents\nThe key in question.\nThe guard for the updates.\nThe view obtained from the storage\nWrapping a view to memoize its hash.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrapper to compute the hash of the view based on its …\nReturns the argument unchanged.\nObtains a hash of the history of the changes in the view.\nCalls <code>U::from(self)</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nBCS serialization error.\nType wrapping <code>KeyValueStoreView</code> while memoizing the hash.\nWrapper around <code>KeyValueStoreView</code> to compute hashes based …\nA view that represents the functions of <code>KeyValueStore</code>.\nA pair containing the key and value size.\nA virtual DB client using a <code>KeyValueStoreView</code> as a backend …\nThe error type for <code>ViewContainer</code> operations.\nView error.\nAdds a size to <code>self</code>\nTests whether the store contains a specific index.\nTests whether the view contains a range of indices\nReturns the number of entries.\nIterates over all the key-value pairs, for keys matching …\nIterates over all the keys matching the given prefix. The …\nApplies the function f over all indices.\nApplies the function f over all index/value pairs.\nApplies the function f over all index/value pairs. If the …\nApplies the function f over all indices. If the function f …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nObtains the value at the given index, if any.\nReturns the list of indices and values in lexicographic …\nReturns the list of indices in lexicographic order.\nSets or inserts a value.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe size of the key\nObtains the values of a range of indices\nCreates a <code>ViewContainer</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nRemoves a value. If absent then the action has no effect.\nDeletes a key prefix.\nSubtracts a size from <code>self</code>\nSums both terms\nGetting the total sizes that will be used for keys and …\n<code>ToString::to_string</code>, but without panic on OOM.\nThe size of the value\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nApplies the given batch of <code>crate::common::WriteOperation</code>.\nType wrapping <code>LogView</code> while memoizing the hash.\nWrapper around <code>LogView</code> to compute hashes based on the …\nA view that supports logging values of type <code>T</code>.\nReads the size of the log.\nObtains the extra data.\nReturns the argument unchanged.\nReads the logged value with the given index (including …\nCalls <code>U::from(self)</code>.\nReads several logged keys (including staged ones)\nReads the index-value pairs at the given positions.\nPushes a value to the end of the log.\nReads the logged values in the given range (including …\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nA view that supports inserting and removing values indexed …\nA map view that uses custom serialization\nType wrapping <code>ByteMapView</code> while memoizing the hash.\nType wrapping <code>CustomMapView</code> while memoizing the hash.\nType wrapping <code>MapView</code> while memoizing the hash.\nWrapper around <code>ByteMapView</code> to compute hashes based on the …\nWrapper around <code>CustomMapView</code> to compute hashes based on …\nWrapper around <code>MapView</code> to compute hashes based on the …\nA <code>View</code> that has a type for keys. The ordering of the …\nReturns <code>true</code> if the map contains a value for the specified …\nReturns <code>true</code> if the map contains a value for the specified …\nReturns <code>true</code> if the map contains a value for the specified …\nReturns the number of keys of the map\nObtains the number of entries in the map\nObtains the number of entries in the map\nObtains the extra data.\nObtains the extra data.\nObtains the extra data.\nApplies a function f on each index. Indices are visited in …\nApplies a function f on each index. Indices are visited in …\nApplies a function on each index/value pair. Indices and …\nApplies a function f on each index/value pair. Indices and …\nApplies a function f on each index/value pair. Indices and …\nApplies a function f on the index/value pairs. Indices and …\nApplies a function f on each index. Indices are visited in …\nApplies a function f on each index. Indices are visited in …\nApplies the function f on each index (aka key) having the …\nApplies a function f on each key/value pair matching a …\nApplies a function f on each index/value pair matching a …\nApplies the function f on each index (aka key) which has …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReads the value at the given position, if any.\nReads the value at the given position, if any.\nReads the value at the given position, if any.\nObtains a mutable reference to a value at a given position …\nObtains a mutable reference to a value at a given position …\nObtains a mutable reference to a value at a given position …\nObtains a mutable reference to a value at a given position.\nObtains a mutable reference to a value at a given position.\nObtains a mutable reference to a value at a given position.\nObtains all the <code>(index,value)</code> pairs.\nObtains all the <code>(index,value)</code> pairs.\nReturns the list of indices in the map. The order is …\nReturns the list of indices in the map. The order is …\nInserts or resets the value of a key of the map.\nInserts or resets a value at an index.\nInsert or resets a value.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the list of keys and values of the map in …\nReturns the list of keys and values of the map matching a …\nReturns the list of keys of the map in lexicographic order.\nReturns the list of keys of the map having a specified …\nReads the values at the given positions, if any.\nReads values at given positions, if any.\nRead values at several positions, if any.\nReads the key-value pairs at the given positions, if any.\nReads the index-value pairs at the given positions, if any.\nRead index-value pairs at several positions, if any.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nRemoves a value. If absent then nothing is done.\nRemoves a value. If absent then the operation does nothing.\nRemoves a value. If absent then this does not do anything.\nRemoves a value. If absent then nothing is done.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nType wrapping <code>QueueView</code> while memoizing the hash.\nWrapper around <code>QueueView</code> to compute hashes based on the …\nA view that supports a FIFO queue for values of type <code>T</code>.\nReads the back value, if any.\nReads the size of the queue.\nDeletes the front value, if any.\nReads all the elements\nObtains the extra data.\nReturns the argument unchanged.\nReads the front value, if any.\nCalls <code>U::from(self)</code>.\nGets a mutable iterator on the entries of the queue\nPushes a value to the end of the queue.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads the <code>count</code> last values in the queue (including staged …\nReads the <code>count</code> next values in the queue (including staged …\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nType wrapping <code>ReentrantByteCollectionView</code> while memoizing …\nType wrapping <code>ReentrantCollectionView</code> while memoizing the …\nType wrapping <code>ReentrantCustomCollectionView</code> while …\nWrapper around <code>ReentrantByteCollectionView</code> to compute …\nWrapper around <code>ReentrantCollectionView</code> to compute hashes …\nWrapper around <code>ReentrantCustomCollectionView</code> to compute …\nA read-only accessor for a particular subview in a …\nA view that supports accessing a collection of views of …\nA view that supports accessing a collection of views of …\nA view that supports accessing a collection of views of …\nA read-write accessor for a particular subview in a …\nReturns <code>true</code> if the collection contains a value for the …\nReturns <code>true</code> if the collection contains a value for the …\nReturns <code>true</code> if the collection contains a value for the …\nReturns the number of indices of the collection.\nReturns the number of indices in the collection.\nReturns the number of entries in the collection.\nGets the extra data.\nGets the extra data.\nGets the extra data.\nApplies a function f on each index. Indices are visited in …\nApplies a function f on each index. Indices are visited in …\nApplies a function f on each index. Indices are visited in …\nApplies a function f on each index. Indices are visited in …\nApplies a function f on each index (aka key). Keys are …\nApplies a function f on each index (aka key). Keys are …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the list of indices in the collection in an order …\nReturns the list of indices in the collection. The order …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the list of indices in the collection in …\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nRemoves an entry. If absent then nothing happens.\nMarks the entry so that it is removed in the next flush.\nRemoves an entry. If absent then nothing happens.\nLoads all the entries for reading at once.\nLoad multiple entries for reading at once. The entries in …\nLoad multiple entries for reading at once. The entries in …\nLoads all the entries for writing at once.\nLoads all entries for writing at once. The entries in …\nLoads all entries for writing at once. The entries in …\nLoads multiple entries for reading at once. The entries in …\nLoad multiple entries for reading at once. The entries in …\nLoad multiple entries for reading at once. The entries in …\nLoads multiple entries for writing at once. The entries in …\nLoad multiple entries for writing at once. The entries in …\nLoad multiple entries for writing at once. The entries in …\nLoads multiple entries for reading at once with their keys.\nLoads multiple entries for reading at once with their keys.\nLoads multiple entries for reading at once with their keys.\nLoads multiple entries for writing at once with their keys.\nLoads multiple entries for writing at once with their keys.\nLoads multiple entries for writing at once with their keys.\nLoads a subview at the given index in the collection and …\nLoads a subview at the given index in the collection and …\nLoads a subview at the given index in the collection and …\nLoads a subview for the data at the given index in the …\nLoads a subview for the data at the given index in the …\nLoads a subview for the data at the given index in the …\nMarks the entry so that it is removed in the next flush.\nMarks the entry so that it is removed in the next flush.\nMarks the entry so that it is removed in the next flush.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nType wrapping <code>RegisterView</code> while memoizing the hash.\nA view that supports modifying a single value of type <code>T</code>.\nObtains the extra data.\nReturns the argument unchanged.\nAccess the current value in the register.\nObtains a mutable reference to the value in the register.\nCalls <code>U::from(self)</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nSets the value in the register.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nA <code>View</code> that supports inserting and removing values indexed …\nA <code>View</code> implementing the set functionality with the index <code>I</code> …\nType wrapping <code>ByteSetView</code> while memoizing the hash.\nType wrapping <code>CustomSetView</code> while memoizing the hash.\nType wrapping <code>SetView</code> while memoizing the hash.\nWrapper around <code>ByteSetView</code> to compute hashes based on the …\nWrapper around <code>CustomSetView</code> to compute hashes based on …\nWrapper around <code>SetView</code> to compute hashes based on the …\nA <code>View</code> implementing the set functionality with the index <code>I</code> …\nReturns true if the given index exists in the set.\nReturns true if the given index exists in the set.\nReturns true if the given index exists in the set.\nReturns the number of entries in the set.\nReturns the number of entries in the set.\nReturns the number of entries of the set.\nGets the extra data.\nObtains the extra data.\nObtains the extra data.\nApplies a function f on each index. Indices are visited in …\nApplies a function f on each index. Indices are visited in …\nApplies a function f on each index. Indices are visited in …\nApplies a function f on each index. Indices are visited in …\nApplies a function f on each serialized index (aka key). …\nApplies a function f on each index (aka key). Keys are …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the list of indices in the set. The order is …\nReturns the list of indices in the set. The order is …\nInsert a value. If already present then it has no effect.\nInserts a value. If already present then no effect.\nInserts a value. If present then it has no effect.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the list of keys in the set. The order is …\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nReads <code>length</code> bytes from memory from the provided <code>location</code>.\nRemoves a value from the set. If absent then no effect.\nRemoves a value. If absent then nothing is done.\nRemoves a value. If absent then nothing is done.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.\nWrites the <code>bytes</code> to memory at the provided <code>location</code>.")
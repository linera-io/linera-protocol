searchState.loadedDescShard("jsonwebtoken", 0, "Create and parses JWT (JSON Web Tokens)\nThe algorithms supported for signing/verifying JWTs\nAll the different kind of keys we can use to decode a JWT. …\nECDSA using SHA-256\nECDSA using SHA-384\nEdwards-curve Digital Signature Algorithm (EdDSA)\nA key to encode a JWT with. Can be a secret, a PEM-encoded …\nHMAC using SHA-256\nHMAC using SHA-384\nHMAC using SHA-512\nA basic JWT header, the alg defaults to HS256 and typ is …\nRSASSA-PSS using SHA-256\nRSASSA-PSS using SHA-384\nRSASSA-PSS using SHA-512\nRSASSA-PKCS1-v1_5 using SHA-256\nRSASSA-PKCS1-v1_5 using SHA-384\nRSASSA-PKCS1-v1_5 using SHA-512\nThe return type of a successful call to decode.\nContains the various validations that are applied after …\nThe algorithm used\nThe validation will check that the <code>alg</code> of the header is …\nValidation will check that the <code>aud</code> field is a member of the\nThe decoded JWT claims\nLower level functions, if you want to do something other …\nContent type\nDecode and validate a JWT\nDecode a JWT without any signature …\nReturns a JWT header using the default Algorithm, HS256\nEncode the header and claims given and sign the payload …\nAll the errors that can be encountered while …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIf you’re using HMAC with a base64 encoded secret, use …\nIf you have a base64 HMAC secret, use that.\nIf you have (x,y) ECDSA key components\nIf you know what you’re doing and have a RSA EC encoded …\nIf you know what you’re doing and have the DER-encoded …\nIf you have a ECDSA public key in PEM format, use this. …\nIf you are loading a ECDSA key from a .pem file This …\nFrom x part (base64 encoded) of the JWK encoding\nIf you know what you’re doing and have a Ed DER encoded …\nIf you know what you’re doing and have the DER-encoded …\nIf you have a EdDSA public key in PEM format, use this. …\nIf you are loading a EdDSA key from a .pem file This …\nIf you have a key in Jwk format\nIf you have (n, e) RSA public key components as strings, …\nIf you know what you’re doing and have a RSA DER encoded …\nIf you know what you’re doing and have the DER-encoded …\nIf you are loading a public RSA key in a PEM format, use …\nIf you are loading a RSA key from a .pem file. This errors …\nIf you have (n, e) RSA public key components already …\nIf you’re using HMAC, use this.\nIf you’re using a HMAC secret that is not base64, use …\nGets the current timestamp in the format expected by JWTs.\nThe decoded JWT header\nWhether to validate the JWT cryptographic signature. …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIf it contains a value, the validation will check that the …\nJSON Key URL\nThis crate contains types only for working JWK and JWK Sets\nJSON Web Key\nKey ID\nAdd some leeway (in seconds) to the <code>exp</code> and <code>nbf</code> validation …\nReturns a JWT header with the algorithm given\nCreate a default validation setup allowing the given alg\nReject a token some time (in seconds) before the <code>exp</code> to …\nWhich claims are required to be present before starting …\n<code>aud</code> is a collection of one or more acceptable audience …\n<code>iss</code> is a collection of one or more acceptable issuers …\nWhich claims are required to be present for this JWT to be …\nIf it contains a value, the validation will check that the …\nThe type of JWS: it can only be “JWT” here\nWhether to validate the <code>aud</code> field.\nWhether to validate the <code>exp</code> field.\nWhether to validate the <code>nbf</code> field.\nX.509 certificate chain. A Vec of base64 encoded ASN.1 DER …\nDecodes the X.509 certificate chain into ASN.1 DER format.\nX.509 SHA1 certificate thumbprint\nX.509 SHA256 certificate thumbprint\nX.509 URL\nTake the payload of a JWT, sign it using the algorithm …\nCompares the signature given with a re-computed signature …\nAn error happened when decoding some base64 text\nSomething unspecified went wrong with crypto\nContains the error value\nAn error that can occur when encoding/decoding JWTs\nThe specific type of an error.\nWhen a token’s <code>exp</code> claim indicates that it has expired\nWhen a token’s <code>nbf</code> claim represents a time in the future\nWhen the algorithm in the header doesn’t match the one …\nWhen the algorithm from string doesn’t match the one …\nWhen a token’s <code>aud</code> claim does not match one of the …\nWhen the secret given is not a valid ECDSA key\nWhen a token’s <code>iss</code> claim does not match the expected …\nWhen a key is provided with an invalid format\nWhen the secret given is not a valid RSA key\nWhen the signature doesn’t match\nWhen a token’s <code>sub</code> claim does not match one of the …\nWhen a token doesn’t have a valid JWT shape\nAn error happened while serializing/deserializing JSON\nWhen the Validation struct does not contain at least 1 …\nWhen a claim required by the validation is not present\nContains the success value\nA type alias for <code>Result&lt;T, jsonwebtoken::errors::Error&gt;</code>.\nWe could not sign with the given key\nSome of the text was invalid UTF-8\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nUnwrap this error into its underlying type.\nReturn the specific type of this error.\nAlgorithm specific parameters\nCommon JWK parameters\nDecrypt content and validate decryption, if applicable\nDerive bits not to be used as a key\nDerive key\nKey type value for an Elliptic Curve Key.\nECDSA using SHA-256\nECDSA using SHA-384\nEd25519 curve\nEdwards-curve Digital Signature Algorithm (EdDSA)\nType of cryptographic curve used by a key. This is defined …\nParameters for an Elliptic Curve Key\nKey type value for an Elliptic Curve Key. This single …\nEncrypt content\nIndicates a public key is meant for encryption\nHMAC using SHA-256\nHMAC using SHA-384\nHMAC using SHA-512\nA JWK set\nThe algorithms of the keys\nOperations that the key is intended to be used for. This …\nKey type value for an Octet symmetric key.\nKey type value for an Octet Key Pair.\nParameters for an Octet Key Pair\nKey type value for an Octet Key Pair. This single value …\nParameters for an Octet Key\nKey type value for an Octet symmetric key. This single …\nOther usage\nOther operation\nP-256 curve\nP-384 curve\nP-521 curve – unsupported by <code>ring</code>.\nRSASSA-PSS using SHA-256\nRSASSA-PSS using SHA-384\nRSASSA-PSS using SHA-512\nThe intended usage of the public <code>KeyType</code>. This enum is …\nRSASSA-PKCS1-v1_5 using SHA-256\nRSASSA-PKCS1-v1_5 using SHA-384\nRSASSA-PKCS1-v1_5 using SHA-512\nKey type value for an RSA Key.\nRSAES-PKCS1-V1_5\nParameters for a RSA Key\nKey type value for an RSA Key. This single value enum is a …\nRSAES-OAEP using SHA-1\nRSAES-OAEP-256 using SHA-2\nComputer digital signature or MAC\nIndicates a public key is meant for signature verification\nDecrypt key and validate decryption, if applicable\nVerify digital signature or MAC\nEncrypt key\nKey algorithm specific parameters\nThe “crv” (curve) parameter identifies the …\nThe “crv” (curve) parameter identifies the …\nThe “e” (exponent) parameter contains the exponent …\nFind the key in the set that matches the given key id, if …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nFind whether the Algorithm is implemented and supported\nThe algorithm keys intended for use with the key.\nThe case sensitive Key ID for the key\nThe “key_ops” (key operations) parameter identifies …\nKey type value for an Elliptic Curve Key.\nKey type value for a RSA Key\nKey type value for an Octet Key\nKey type value for an Octet Key Pair\nThe “n” (modulus) parameter contains the modulus value …\nThe intended use of the public key. Should not be …\nThe octet key value\nThe “x” (x coordinate) parameter contains the x …\nThe “x” parameter contains the base64 encoded public …\nX.509 public key certificate chain. This is currently not …\nX.509 Certificate SHA1 thumbprint. This is currently not …\nX.509 Certificate SHA256 thumbprint. This is currently not …\nX.509 Public key certificate URL. This is currently not …\nThe “y” (y coordinate) parameter contains the y …")
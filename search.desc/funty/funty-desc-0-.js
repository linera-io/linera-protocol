searchState.loadedDescShard("funty", 0, "<code>fun</code>damental <code>ty</code>pes\nDeclare that a type is one hundred twenty-eight or more …\nDeclare that a type is sixteen or more bits wide.\nDeclare that a type is thirty-two or more bits wide.\nDeclare that a type is sixty-four or more bits wide.\nDeclare that a type is eight or more bits wide.\nDeclare that a type is one hundred twenty-eight or fewer …\nDeclare that a type is sixteen or fewer bits wide.\nDeclare that a type is thirty-two or fewer bits wide.\nDeclare that a type is sixty-four or fewer bits wide.\nDeclare that a type is eight or fewer bits wide.\nThe size of this type in bits.\nThe <code>[u8; N]</code> byte array that stores values of <code>Self</code>.\nApproximate number of significant digits in base 10.\nEuler’s number (e)\nMachine epsilon value for <code>f32</code>.\n1/π\n1/sqrt(2)\n2/π\n2/sqrt(π)\nπ/2\nπ/3\nπ/4\nπ/6\nπ/8\nDeclare that a type is a floating-point number.\nDeclare that a type is one of the language fundamental …\nInfinity (∞).\nDeclare that a type is a fixed-point integer.\nDeclare that a type is exactly one hundred twenty-eight …\nDeclare that a type is exactly sixteen bits wide.\nDeclare that a type is exactly thirty-two bits wide.\nDeclare that a type is exactly sixty-four bits wide.\nDeclare that a type is exactly eight bits wide.\nln(10)\nln(2)\nlog10(e)\nlog2(e)\nNumber of significant digits in base 2.\nThe type’s maximum value.\nLargest finite <code>f32</code> value.\nMaximum possible power of 10 exponent.\nMaximum possible power of 2 exponent.\nThe type’s minimum value. This is zero for unsigned …\nSmallest finite <code>f32</code> value.\nMinimum possible normal power of 10 exponent.\nOne greater than the minimum possible normal power of 2 …\nSmallest positive normal <code>f32</code> value.\nNot a Number (NaN).\nNegative infinity (−∞).\nDeclare that a type is an abstract number.\nThe type’s step value.\nArchimedes’ constant (π)\nThe radix or base of the internal representation of <code>f32</code>.\nThe unsigned integer type of the same width as <code>Self</code>.\nsqrt(2)\nDeclare that a type is a signed integer.\nDeclare that a type is an unsigned integer.\nThe type’s zero value.\nOverflow behavior\nTests <code>self != 0</code>.\nRepresents <code>self</code> as a Unicode Scalar Value, if possible.\nPerforms <code>self as f32</code>.\nPerforms <code>self as f64</code>.\nPerforms <code>self as i128</code>.\nPerforms <code>self as i16</code>.\nPerforms <code>self as i32</code>.\nPerforms <code>self as i64</code>.\nPerforms <code>self as i8</code>.\nPerforms <code>self as isize</code>.\nPerforms <code>self as u128</code>.\nPerforms <code>self as u16</code>.\nPerforms <code>self as u32</code>.\nPerforms <code>self as u64</code>.\nPerforms <code>self as u8</code>.\nPerforms <code>self as usize</code>.\nChecked absolute value. Computes <code>self.abs()</code>, returning <code>None</code>…\nChecked integer addition. Computes <code>self + rhs</code>, returning …\nChecked integer division. Computes <code>self / rhs</code>, returning …\nChecked Euclidean division. Computes <code>self.div_euclid(rhs)</code>, …\nChecked integer multiplication. Computes <code>self * rhs</code>, …\nChecked negation. Computes <code>-self</code>, returning <code>None</code> if …\nReturns the smallest power of two greater than or equal to …\nChecked exponentiation. Computes <code>self.pow(exp)</code>, returning …\nChecked integer remainder. Computes <code>self % rhs</code>, returning …\nChecked Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>…\nChecked shift left. Computes <code>self &lt;&lt; rhs</code>, returning <code>None</code> …\nChecked shift right. Computes <code>self &gt;&gt; rhs</code>, returning <code>None</code> …\nChecked integer subtraction. Computes <code>self - rhs</code>, …\nReturns the floating point category of the number. If only …\nReturns the number of ones in the binary representation of …\nReturns the number of zeros in the binary representation …\nCalculates the quotient of Euclidean division of self by …\nConverts an integer from big endian to the target’s …\nCreate a numeric value from its representation as a byte …\nRaw transmutation from <code>u32</code>.\nConverts an integer frm little endian to the target’s …\nCreate a numeric value from its representation as a byte …\nCreate a numeric value from its memory representation as a …\nConverts a string slice in a given base to an integer.\nReturns <code>true</code> if this number is neither infinite nor <code>NaN</code>.\nReturns <code>true</code> if this value is positive infinity or …\nReturns <code>true</code> if this value is <code>NaN</code>.\nReturns <code>true</code> if <code>self</code> is negative and <code>false</code> if the number …\nReturns <code>true</code> if the number is neither zero, infinite, …\nReturns <code>true</code> if <code>self</code> is positive and <code>false</code> if the number …\nReturns <code>true</code> if and only if <code>self == 2^k</code> for some <code>k</code>.\nReturns <code>true</code> if <code>self</code> has a negative sign, including <code>-0.0</code>, …\nReturns <code>true</code> if <code>self</code> has a positive sign, including <code>+0.0</code>, …\nReturns the number of leading ones in the binary …\nReturns the number of leading zeros in the binary …\nReturns the maximum of the two numbers.\nReturns the largest value that can be represented by this …\nReturns the minimum of the two numbers.\nReturns the smallest value that can be represented by this …\nReturns the smallest power of two greater than or equal to …\nComputes the absolute value of <code>self</code>.\nCalculates <code>self + rhs</code>\nCalculates the divisor when <code>self</code> is divided by <code>rhs</code>.\nCalculates the quotient of Euclidean division …\nCalculates the multiplication of <code>self</code> and <code>rhs</code>.\nNegates self, overflowing if this is equal to the minimum …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nCalculates the remainder when <code>self</code> is divided by <code>rhs</code>.\nOverflowing Euclidean remainder. Calculates …\nShifts self left by <code>rhs</code> bits.\nShifts self right by <code>rhs</code> bits.\nCalculates <code>self - rhs</code>\nRaises self to the power of <code>exp</code>, using exponentiation by …\nTakes the reciprocal (inverse) of a number, <code>1/x</code>.\nCalculates the least nonnegative remainder of …\nReverses the bit pattern of the integer.\nShifts the bits to the left by a specified amount, <code>n</code>, …\nShifts the bits to the right by a specified amount, <code>n</code>, …\nSaturating integer addition. Computes <code>self + rhs</code>, …\nSaturating integer multiplication. Computes <code>self * rhs</code>, …\nSaturating integer exponentiation. Computes <code>self.pow(exp)</code>, …\nSaturating integer subtraction. Computes <code>self - rhs</code>, …\nReturns a number representing sign of <code>self</code>.\nReverses the byte order of the integer.\nConverts <code>self</code> to big endian from the target’s endianness.\nReturn the memory representation of this number as a byte …\nRaw transmutation to <code>u32</code>.\nConverts radians to degrees.\nConverts <code>self</code> to little endian from the target’s …\nReturn the memory representation of this number as a byte …\nReturn the memory representation of this number as a byte …\nConverts degrees to radians.\nReturns the number of trailing ones in the binary …\nReturns the number of trailing zeros in the binary …\nWrapping (modular) absolute value. Computes <code>self.abs()</code>, …\nWrapping (modular) addition. Computes <code>self + rhs</code>, wrapping …\nWrapping (modular) division. Computes <code>self / rhs</code>, wrapping …\nWrapping Euclidean division. Computes <code>self.div_euclid(rhs)</code>…\nWrapping (modular) multiplication. Computes <code>self * rhs</code>, …\nWrapping (modular) negation. Computes <code>-self</code>, wrapping …\nWrapping (modular) exponentiation. Computes <code>self.pow(exp)</code>, …\nWrapping (modular) remainder. Computes <code>self % rhs</code>, …\nWrapping Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>…\nPanic-free bitwise shift-left; yields <code>self &lt;&lt; mask(rhs)</code>, …\nPanic-free bitwise shift-right; yields <code>self &gt;&gt; mask(rhs)</code>, …\nWrapping (modular) subtraction. Computes <code>self - rhs</code>, …")
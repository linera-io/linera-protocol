searchState.loadedDescShard("alloy_dyn_abi", 0, "alloy-dyn-abi\nAddress.\nAn address.\nDynamically sized array.\nA dynamically-sized array of values.\nBoolean.\nA boolean.\nDynamic bytes.\nA dynamic-length byte array.\nA decoded dynamic ABI error.\nA decoded dynamic ABI event.\nA dynamic-length sequence.\nA representation of a Solidity call\nA dynamic ABI error.\nA dynamic ABI event.\nA representation of a Solidity call’s returns.\nA dynamic Solidity type.\nA dynamic Solidity value.\nA dynamic token.\nLength mismatch during encoding.\nContains the error value\nError when parsing EIP-712 <code>encodeType</code> strings\nProvides error encoding and decoding for the <code>Error</code> type.\nProvides event encoding and decoding for the <code>Event</code> type.\nInvalid event signature.\nFixed-sized array.\nA fixed-size array of values.\nFixed-size bytes, up to 32.\nA fixed-length byte array. The second parameter is the …\nA Fixed Sequence.\nFunction.\nA function pointer.\nProvide ABI encoding and decoding for the <code>Function</code> type.\n<code>hex</code> error.\nSigned Integer.\nA signed integer. The second parameter is the number of …\nProvides ABI encoding and decoding functionality.\nContains the success value\nA packed sequence (string or bytes).\nDynamic ABI result type.\nSelector mismatch during function or error decoding.\n<code>alloy_sol_types</code> error.\nTrait for items that can be resolved to <code>DynSol*</code>, i.e. they …\nString.\nA string.\nLength mismatch during event topic decoding.\nTuple.\nA tuple of values.\nType mismatch during encoding or coercion.\n<code>alloy_sol_type_parser</code> error.\nUnsigned Integer.\nAn unsigned integer. The second parameter is the number of …\nA single word.\nDecode a <code>DynSolValue</code> from a byte slice. Fails if the value …\nABI-decodes the given data according to this item’s …\nABI decode the given data as function returns.\nABI-decodes the given data according to this functions’s …\nABI decode the given data as function return values.\nABI decode the given data as function return values.\nDecode a <code>DynSolValue</code> from a byte slice. Fails if the value …\nDecode a <code>DynSolValue</code> from a byte slice. Fails if the value …\nEncode this value into a byte array by wrapping it into a …\nABI-encodes the given values, prefixed by this item’s …\nABI encode the given values as function params.\nABI-encodes the given values, without prefixing the data …\nABI encode the given values as function params without …\nABI-encodes the given values.\nABI encode the given values as function return values.\nABI encode the given values as function return values.\nNon-standard Packed Mode ABI encoding.\nNon-standard Packed Mode ABI encoding.\nEncode this value into a byte array suitable for passing …\nIf this value is a fixed sequence, encode it into a byte …\nReturns the length of this value when ABI-encoded in …\nFallible cast to the contents of a variant DynSolValue {.\nFallible cast to the contents of a variant.\nFallible cast to the contents of a variant.\nFallible cast to the contents of a variant.\nFallible cast to the contents of a variant.\nFallible cast to the contents of a variant.\nFallible cast into a dynamic sequence.\nFallible cast to the contents of a variant.\nFallible cast to the contents of a variant.\nFallible cast into a fixed sequence.\nFallible cast to a fixed-size array. Any of a <code>FixedArray</code>, …\nFallible cast to the contents of a variant.\nFallible cast into a packed sequence.\nFallible cast to a packed sequence. Any of a String, or a …\nFallible cast to the contents of a variant.\nFallible cast into a sequence, dynamic or fixed-size\nFallible cast to the contents of a variant.\nFallible cast to the contents of a variant.\nThe Solidity type. This returns the Solidity type …\nFallible cast to the contents of a variant.\nAttempt to cast to a word.\nFallible cast to a single word. Will succeed for any …\nError body types.\nGet the un-indexed types.\nThe decoded error body.\nThe un-indexed values, in order.\nCoerces a string into a <code>DynSolValue</code> via this type.\nInstantiates a new error with a static str.\nDecode the error from the given data.\nDecode the error from the given data.\nDecodes the given log object according to this item’s …\nDecodes the given log object according to this item’s …\nDecode the event from the given log info.\nDecodes the given log info according to this item’s …\nDecode the event from the given log info.\nDynamic detokenization.\nTransform a <code>Log</code> containing this event into a <code>Log</code> containing\nRe-encode the event into a <code>LogData</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInstantiate a DynToken from a dynamic sequence of values.\nInstantiate a DynToken from a fixed sequence of values.\nReturns whether this type is contains a custom struct.\nReturns whether this type is contains a custom struct.\nAppend this data to the head of an in-progress blob via …\nGet the indexed types.\nThe indexed values, in order.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrue if anonymous.\nTrue if anonymous. False if not.\nReturns <code>true</code> if this type is dynamically sized type.\nTrue if the type is dynamic, else false.\nReturns <code>true</code> if the value is an instance of a dynamically …\nReturns true if the value is a sequence type.\nTrust if this value is encoded as a single word. False …\nReturn true if the type is zero-sized, e.g. <code>()</code> or <code>T[0]</code>\nCheck that the given <code>DynSolValue</code> matches this type.\nCheck that this value has the same type as the given …\nCheck that the given <code>DynSolValue</code>s match these types.\nCheck that these values have the same type as the given …\nGet the method name of the call (if available)\nCalculate the minimum number of ABI words necessary to …\nCalculate the minimum number of words required to encode …\nCalculate the nesting depth of this type. Simple types …\nCreates a new error from a selector.\nCreates a new event.\nCreate a new <code>DynSolCall</code> with the given selector and types.\nCreate a new <code>DynSolReturns</code> with the given types.\nCreates a new error, without length-checking the body. …\nCreates a new event, without length-checking the indexed, …\nA Solidity panic.\nParses a Solidity type name string into a <code>DynSolType</code>.\nResolve the type into a value.\nGet the types of the call’s returns.\nRepresents a standard Solidity revert. These are thrown by …\nError selector is the first 4 bytes of the keccak256 hash …\nGet the selector of the call.\nThe hashes event_signature (if any)\nThe Solidity type name. This returns the Solidity type …\nThe Solidity type name. This returns the Solidity type …\nAppend this data to the tail of an in-progress blob via …\nThe Solidity type name, as a <code>String</code>.\nTokenize this value into a <code>DynToken</code>.\nGet the selector for this event, if any.\nGet the types of the call.\nGet the types of the returns.\nThe contents of the dynamic sequence.\nThe actual type.\nThe actual length.\nThe actual length.\nThe actual selector.\nThe actual signature.\nThe expected type.\nThe expected length.\nThe expected length.\nThe expected selector.\nThe expected signature.")
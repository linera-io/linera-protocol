searchState.loadedDescShard("revm_interpreter", 0, "revm-interpreter\nInvalid <code>CALL</code> with value transfer in static context.\nIndicates a call or contract creation.\nExceeded maximum call depth.\nExecution should continue to the next one.\nLegacy create scheme of <code>CREATE</code>\nCreate scheme of <code>CREATE2</code>\nAddress collision during contract creation.\nExceeded contract size limit during creation.\nCreated contract starts with invalid bytes (<code>0xEF</code>).\nExceeded init code size limit (EIP-3860:  Limit and meter …\nRevert if <code>CREATE</code>/<code>CREATE2</code> starts with <code>0xEF00</code>.\nInternal CREATE/CREATE starts with 0xEF00\nCreate scheme\nCustom scheme where we set up the original address\nLegacy contract is calling opcode that is enabled only in …\nAux data overflow, new aux data is larger than <code>u16</code> max …\nAux data is smaller than already present data size.\nFatal external error. Returned by database.\nInternal instruction that signals call or create.\nInternal instruction that signals Interpreter should …\nInternal results that are not exposed externally\nInvalid EVM Object Format (EOF) init code.\n<code>EXT*CALL</code> target address needs to be padded with 0s.\n<code>ExtDelegateCall</code> calling a non EOF contract.\nInternal to ExtDelegateCall\nAn undefined bytecode value encountered during execution.\nInvalid jump destination. Dynamic jumps points to invalid …\nOut of gas error encountered while calling an invalid …\nEIP-170: Contract code size limit\nEIP-3860: Limit and meter initcode\nThe memory limit of the EVM has been exceeded.\nOut of gas error encountered during memory expansion.\nNonce overflow.\nThe feature or opcode is not activated in this version of …\nUnknown or invalid opcode.\nInsufficient funds for transfer.\nOut of gas error.\nInvalid memory or storage offset.\nPayment amount overflow.\nError in precompiled contract execution.\nOut of gas error encountered during the execution of a …\nOut of gas error encountered while checking for reentrancy …\nReturn from the current call.\nReturn a contract (used in contract creation).\n<code>RETURNCONTRACT</code> called outside init EOF code.\nRevert the transaction.\nRepresents the result of an <code>sstore</code> operation.\nSelf-destruct the current contract.\nResult of a selfdestruct action\nAttempting to push a value onto a full stack.\nAttempting to pop a value from an empty stack.\nInvalid state modification in static call.\nState load information that contains the data and if the …\nEncountered a <code>STOP</code> opcode\nStack overflow in EOF subroutine function calls.\nConverts a <code>U256</code> value to a <code>isize</code>, saturating to <code>isize::MAX</code> …\nConverts a <code>U256</code> value to a <code>u64</code>, saturating to <code>MAX</code> if the …\nConverts a <code>U256</code> value to a <code>usize</code>, failing the instruction …\nConverts a <code>U256</code> value to a <code>usize</code> and returns <code>ret</code>, failing …\nConverts a <code>U256</code> value to a <code>usize</code>, saturating to <code>MAX</code> if the …\nCheck if the <code>SPEC</code> is enabled, and fail the instruction if …\nReturned data\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nEVM gas calculation utilities.\nRecords a <code>gas</code> cost and fails the instruction if it would …\nSame as <code>gas!</code>, but with <code>gas</code> as an option.\nEVM opcode implementations.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs account is cold loaded\nReturns whether the result is an error.\nReturns true if the EVM has experienced an exceptional halt\nReturns <code>true</code> if the new value is equal to the present …\nReturns <code>true</code> if the new value is zero.\nReturns whether the result is a success.\nReturns <code>true</code> if the original value is equal to the new …\nReturns <code>true</code> if the original value is equal to the present …\nReturns <code>true</code> if the original value is zero.\nReturns <code>true</code> if the present value is zero.\nReturns whether the result is a revert.\nReturns true if the transaction reverted.\nReturns true if the transaction returned successfully …\nMaps the data of the <code>StateLoad</code> to a new value.\nReturns a new <code>StateLoad</code> with the given data and cold load …\nNew value that is set\nValue of the storage when it is first read\nPops n values from the stack. Fails the instruction if n …\nPops n values from the stack and returns the top value. …\nCurrent value of the storage\nPushes a <code>B256</code> value onto the stack. Fails the instruction …\nError if the current call is executing EOF.\nFails the instruction if the current call is static.\nResizes the interpreterreter memory if necessary. Fails …\nReturns the HaltReason value the EVM has experienced an …\nReturns the SuccessReason value if this a successful result\n<code>const</code> Option <code>?</code>.\nSalt\nMemory was extended.\nRepresents the state of gas during execution.\nEIP-3860 : Limit and meter initcode\nEIP-1884: Repricing for trie-size-dependent opcodes\nInit and floor gas from transaction\nUtility struct that speeds up calculation of memory …\nThe cost of a non-zero byte in calldata.\nThe cost of a non-zero byte in calldata adjusted by …\nThe multiplier for a non zero byte in calldata.\nThe multiplier for a non zero byte in calldata adjusted by …\nNot enough gas to extend memory.\nThe standard cost of calldata token.\nMemory size stayed the same.\nCalculate the transaction cost floor as specified in …\nInitial gas that is deducted for transaction to be …\nInitial gas that is deducted for transaction to be …\nCalculate call gas cost for the call instruction.\n<code>*COPY</code> opcodes cost calculation.\nCalculate the cost of buffer per word.\n<code>CREATE2</code> opcode cost calculation.\nErases a gas cost from the totals.\n<code>EXP</code> opcode cost calculation.\nCurrent memory expansion cost\n<code>EXTCODECOPY</code> opcode cost calculation.\nIf transaction is a Call and Prague is enabled floor_gas …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nRetrieve the total number of tokens in calldata.\nEIP-3860: Limit and meter initcode\nInitial gas for transaction.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>KECCAK256</code> opcode cost calculation.\nReturns the gas limit.\n<code>LOG</code> opcode cost calculation.\nReturns the memory gas.\nMemory expansion cost calculation for a given number of …\nReturns the memory gas.\nCreate a new InitialAndFloorGas instance.\nCreates a new <code>Gas</code> struct with the given gas limit.\nCreates a new <code>Gas</code> struct with the given gas limit, but …\nRecords an explicit cost.\nRecord memory expansion\nRecords a refund value.\nReturns the total amount of gas that was refunded.\nReturns the amount of gas remaining.\nReturn remaining gas after subtracting 63/64 parts.\n<code>SELFDESTRUCT</code> opcode cost calculation.\nSet a refund value for final refund.\nSet a refund value. This overrides the current refund …\nSet a spent value. This overrides the current spent value.\n<code>SLOAD</code> opcode cost calculation.\nSpends all remaining gas.\nReturns the total amount of gas spent.\nReturns the total amount of gas spent, minus the refunded …\n<code>SSTORE</code> opcode cost calculation.\n<code>SSTORE</code> opcode refund calculation.\nBerlin warm and cold storage access cost for account …\nBerlin warm and cold storage access cost for account …\nCurrent memory length\nDummy host that implements <code>Host</code> trait and  returns all …\nHost trait with all methods that are needed by the …\nBalance, calls <code>ContextTr::journal().load_account(address)</code>\nBlock basefee, calls ContextTr::block().basefee()\nBlock beneficiary, calls ContextTr::block().beneficiary()\nBlock blob gasprice, calls …\nTransaction blob hash, calls …\nBlock hash, calls …\nBlock number, calls ContextTr::block().number()\nTransaction caller, calls <code>ContextTr::tx().caller()</code>\nChain id, calls ContextTr::cfg().chain_id()\nBlock difficulty, calls ContextTr::block().difficulty()\nTransaction effective gas price, calls …\nReturns the argument unchanged.\nBlock gas limit, calls ContextTr::block().gas_limit()\nInitcodes mapped to the hash.\nCalls <code>U::from(self)</code>.\nLoad account code, calls …\nLoad account code hash, calls …\nLoad account delegated, calls …\nLog, calls <code>ContextTr::journal().log(log)</code>\nMax initcode size, calls …\nBlock prevrandao, calls ContextTr::block().prevrandao()\nSelfdestruct account, calls …\nSload, calls <code>ContextTr::journal().sload(address, key)</code>\nSstore, calls …\nBlock timestamp, calls ContextTr::block().timestamp()\nTload, calls <code>ContextTr::journal().tload(address, key)</code>\nTstore, calls …\nEVM opcode function signature.\nInstruction table is list of instruction function pointers …\nReturns the instruction table for the given spec.\nUtility macros to help implementing opcode instruction …\nImplements the <code>SIGNEXTEND</code> opcode as defined in the …\nEIP-145: Bitwise shifting instructions in EVM\nEIP-145: Bitwise shifting instructions in EVM\nEIP-145: Bitwise shifting instructions in EVM\nEIP-3198: BASEFEE opcode\nEIP-7516: BLOBBASEFEE opcode\nEIP-1344: ChainID opcode\nEOF Create instruction\nPop target address from stack and check if it is valid.\nResize memory and return range of memory. If <code>len</code> is 0 dont …\nInstruction to create a new EOF contract from a …\nInvalid opcode. This opcode halts the execution.\nEIP-140: REVERT instruction\nStop opcode. This opcode halts the execution.\nUnknown opcode. This opcode halts the execution.\nEIP-1052: EXTCODEHASH opcode\nEIP-1884: Repricing for trie-size-dependent opcodes\nEIP-1153: Transient storage opcodes Load value from …\nEIP-1153: Transient storage opcodes Store value to …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nEIP-3855: PUSH0 instruction\nEIP-211: New opcodes: RETURNDATASIZE and RETURNDATACOPY\nPart of EOF <code>&lt;https://eips.ethereum.org/EIPS/eip-7069&gt;</code>.\nEIP-211: New opcodes: RETURNDATASIZE and RETURNDATACOPY\nPushes an arbitrary length slice of bytes onto the stack, …\nDefault types for Ethereum interpreter.\nInputs for the interpreter that are used for execution of …\nMain interpreter structure that contains all components …\nThe result of an interpreter operation.\nEVM interpreter stack limit.\nA sequential memory shared between calls, which uses a <code>Vec</code> …\nEVM stack with STACK_LIMIT capacity of words.\nFunction Stack\nFunction(Sub Routine) return frame in eof\nAddress of the bytecode that is being executed. This field …\nValue of the call.\nAddress of the caller of the call.\nReturns a reference to the memory of the current context, …\nReturns a mutable reference to the memory of the current …\nCopies elements from one part of the memory to another …\nReturns a reference to the underlying data buffer.\nReturns a mutable reference to the underlying data buffer.\nDuplicates the <code>N</code>th value from the top of the stack.\nExchange two values on the stack.\nPrepares the shared memory for returning from child …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe gas usage information.\nReturns the byte at the given offset.\nReturns a U256 of the memory region at the given offset.\nReturns a 32-byte slice of the memory region at the given …\nReturns a byte slice of the memory region at the given …\nReturns a byte slice of the memory region at the given …\nSet data from global memory to local memory. If global …\nThe index of the code container that this frame is …\nInput data for the call.\nThe execution control flag.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsumes the stack and returns the underlying data buffer.\nReturns <code>true</code> if the current memory range is empty.\nReturns whether the stack is empty.\nReturns whether the instruction result is an error.\nReturns whether the instruction result is a success.\nReturns whether the instruction result is a revert.\nReturns the length of the current memory range.\nReturns the length of the stack in words.\nCreates a new memory instance that can be shared between …\nInstantiate a new stack with the default stack limit.\nReturn new function frame.\nReturns new function stack.\nCreate new interpreter\nReturns a new <code>InterpreterResult</code> with the given values.\nPrepares the shared memory for a new child context.\nCreates a new memory instance with a given shared buffer.\nActions that the EVM should do.\nReturns number of words what would fit to provided number …\nThe output of the instruction execution.\nThe program counter where frame execution should continue.\nPeek a value at given index for the stack, where the top of\nRemoves the topmost element from the stack and returns it, …\nRemoves the topmost element from the stack and returns it.\nPops <code>N</code> values from the stack.\nPops <code>N</code> values from the stack and returns the top of the …\nPush a new value onto the stack.\nPushes an arbitrary length slice of bytes onto the stack, …\nResets the control to the initial state. so that we can …\nResizes the memory in-place so that <code>len</code> is equal to <code>new_len</code>…\nThe result of the instruction execution.\nReturn stack length\nExecutes the interpreter until it returns or stops.\nExecutes the interpreter until it returns or stops, …\nSet memory region at given <code>offset</code>.\nSet a value at given index for the stack, where the top of …\nSets the <code>byte</code> at the given <code>index</code>.\nSets current_code_idx, this is needed for JUMPF opcode.\nSet memory from data. Our memory offset+len is expected to …\nSets the given U256 <code>value</code> to the memory region at the …\nSets the given 32-byte <code>value</code> to the memory region at the …\nReturns a byte slice of the memory region at the given …\nReturns a byte slice of the memory region at the given …\nReturns a byte slice of the memory region at the given …\nSwaps the topmost value with the <code>N</code>th value from the top.\nTakes the next action from the control and returns it.\nTakes the next action from the control and returns it as …\nStorage of this account address is being used.\nPeeks the top of the stack.\nSets the bytecode that is going to be executed\nCreates a new memory instance that can be shared between …\nReturns the argument unchanged.\nReturns the bytecode hash.\nCalls <code>U::from(self)</code>.\nCreate new extended bytecode and set the instruction …\nCreates new <code>ExtBytecode</code> with the given hash.\nRegenerates the bytecode hash.\nApparent value, that is <strong>not</strong> actually transferred.\nBytes of the call data.\n<code>CALL</code>.\n<code>CALL</code>, <code>CALLCODE</code>, <code>DELEGATECALL</code>, <code>STATICCALL</code> or EOF <code>EXTCALL</code>, …\n<code>CALLCODE</code>\nInput enum for a call.\nInputs for a call.\nRepresents the outcome of a call operation in a virtual …\nCall scheme.\nCall value.\n<code>CREATE</code> or <code>CREATE2</code> instruction called.\nInputs for a create call\nRepresents the outcome of a create operation in an …\n<code>DELEGATECALL</code>\nEOF <code>CREATE</code> instruction called.\nInputs for EOF Create call\nEOF create can be called from two places:\n<code>EXTCALL</code>\n<code>EXTDELEGATECALL</code>\n<code>EXTSTATICCALL</code>\nNew frame\nNo action\nInterpreter finished execution.\nThe Range points to the SharedMemory buffer. Buffer can be …\n<code>STATICCALL</code>\nConcrete value, transferred from caller to callee at the …\nAn optional address associated with the create operation\nReturns the apparent value, if any.\nReturns the <strong>apparent</strong> call value.\nThe account address of bytecode that is going to be …\nReturns the bytes of the call input.\nReturns the call value, regardless of the transfer value …\nThis caller is invoking the call.\nCaller address of the EVM\nCaller of EOF Create\nReturns the address that this create call will create.\nReturns created address\nReturns a default <code>CallInput</code> with an empty <code>Bytes</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the gas usage information.\nRetrieves a reference to the <code>Gas</code> details from the …\nThe gas limit of the call.\nThe gas limit of the call\nGas limit for the create call\nReturns the call value, regardless of the type.\nThe init code of the contract\nThe call data of the call.\nReturns a reference to the instruction result.\nRetrieves a reference to the <code>InstructionResult</code> from the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>InterpreterResult</code> if action is return.\nReturns whether the call value is apparent, and not …\nReturns <code>true</code> if action is call.\nReturns <code>true</code> if action is create.\nReturns <code>true</code> if the call input is empty.\nWhether the call is initiated from EOF bytecode.\nReturns true if it is EOF EXT*CALL.\nReturns true if it is ExtDelegateCall.\nReturns <code>true</code> if action is none.\nReturns <code>true</code> if action is return.\nReturns <code>true</code> if action is some.\nWhether the call is a static call, or is initiated inside …\nReturns whether the call value will be transferred.\nEOF Create kind\nReturns the length of the call input.\nReturns the length of the memory range.\nReturns the start position of the memory offset.\nConstructs a new <code>CallOutcome</code>.\nConstructs a new <code>CreateOutcome</code>.\nCreates new EOF Create input from transaction that has …\nReturns a new instance of EOFCreateInput.\nReturns a reference to the output data.\nRetrieves a reference to the output bytes from the …\nThe result of the interpreter operation\nThe return memory offset where the output of the call is …\nThe call scheme.\nThe create scheme\nTarget address, this account storage is going to be …\nReturns the transferred value, if any.\nReturns the address of the transfer source account.\nReturns the address of the transfer target account.\nReturns the transfer value.\nReturns <code>true</code> if the call will transfer a non-zero value.\nCall value.\nThe value to transfer\nValues of ether transferred\nEOF code info.\nReturns EOF containers. Used by …\nEOF data fetching.\nHelper function to read immediates data from the bytecode\nTrait for fetching inputs of the call.\nTrait for Interpreter to be able to jump\nTrait needed for legacy bytecode.\nTrait for Interpreter memory operations.\nReturns return data.\nFunctions needed for Interpreter Stack operations.\nHandles EOF introduced sub routine calls.\nAbsolute jumps require checking for overflow and if target …\nReturns return data.\nReturns bytecode address of the call. For DELEGATECALL …\nReturns current bytecode original length. Used in …\nReturns current bytecode original slice. Used in …\nReturns call value of the call.\nReturns caller address of the call.\nClears return buffer.\nReturns code information containing stack information.\nReturns program counter at the start of code section.\nCopies memory data from source to destination.\nReturns EOF data.\nReturns EOF data size.\nReturns EOF data slice.\nDuplicates the <code>N</code>th value from the top of the stack.\nReturns EOF container at given index.\nExchanges two values on the stack.\nMemory slice with global range. This range\nReturns input of the call.\nReturns <code>true</code> if sub routine stack is empty.\nReturns <code>true</code> if stack is empty.\nCheck legacy jump destination from jump table.\nReturns sub routine stack length.\nReturns stack length.\nOffset of local context of memory.\nReturns instruction opcode.\nReturns current program counter.\nPops previous subroutine, sets previous code index and …\nPops one value from the stack.\nPops address from the stack.\nPops value from the stack.\nPop N values from the stack and return top value.\nPushes a new frame to the stack and new code index.\nPushes values to the stack.\nPushes B256 value to the stack.\nRelative jumps does not require checking for overflow.\nResizes memory to new size\nReturns current sub routine index.\nSets memory data at given offset.\nSets return buffer.\nSets memory data at given offset from data with a given …\nInner clone part of memory from global context to local …\nSets new code section without touching subroutine stack.\nReturns memory size.\nMemory slice with range\nMemory slice len\nReturns target address of the call.\nReturns top value from the stack.")
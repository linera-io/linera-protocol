searchState.loadedDescShard("crypto_bigint", 0, "RustCrypto: Cryptographic Big Integers\nCompute <code>self + rhs mod p</code>.\nSupport for decoding a <code>GenericArray</code> as a big integer.\nSupport for encoding a big integer as a <code>GenericArray</code>.\nTotal size of the represented integer in bits.\nSize of this integer in bits.\nSize of the inner integer in bits.\nTotal size of the represented integer in bits.\nTotal size of the represented integer in bytes.\nSize of this integer in bytes.\nSize of the inner integer in bytes.\nTotal size of the represented integer in bytes.\nIntegers whose representation takes a bounded amount of …\nAlias for a byte array whose size is defined by …\nSize of a byte array which encodes a big integer.\nProvides intentionally-checked arithmetic on <code>T</code>.\nChecked addition.\nChecked multiplication.\nChecked subtraction.\nConcatenate two numbers into a “wide” double-width …\nConcatenate two numbers into a “wide” combined-width …\nA boolean value returned by constant-time <code>const fn</code>s.\nEncoding support.\nThe falsy value.\nInteger type.\nConstant-time inversion.\nThe number of limbs used on this platform.\nThe number of limbs used on this platform.\nBig integers are represented as an array of smaller CPU …\nMaximum value this integer can express.\nMaximum value this <code>Limb</code> can express.\nMaximum value this integer can express.\nMaximum value this <code>Uint</code> can express.\nConcatenated output: combination of <code>Lo</code> and <code>Self</code>.\nCompute <code>self * rhs mod p</code>.\nPerforms modular multi-exponentiation using Montgomery’s …\nPerforms modular multi-exponentiation using Montgomery’s …\nCompute <code>-self mod p</code>.\nWrapper type for non-zero integers.\nThe value <code>1</code>.\nThe value <code>1</code>.\nThe value <code>1</code>.\nThe value <code>1</code>.\nBig integer which decodes a <code>GenericArray</code>.\nOutput type.\nOutput type.\nOutput type.\nOutput type.\nOutput type.\nOutput type.\nOutput type.\nConcatenated output: twice the width of <code>Self</code>.\nSplit output: high/low components of the value.\nOutput of the inversion.\nConstant-time exponentiation.\nConstant-time exponentiation with exponent of a bounded …\nRandom number generation support.\nModular random number generation support.\nA pre-calculated reciprocal for division by a single limb.\nByte array representation.\nSplit a number in half, returning the most significant …\nSplit a number into parts, returning the most significant …\nSupport for optimized squaring\nCompute <code>self - rhs mod p</code>.\nThe truthy value.\n1024-bit unsigned big integer.\n128-bit unsigned big integer.\n1280-bit unsigned big integer.\n1536-bit unsigned big integer.\n16384-bit unsigned big integer.\n1792-bit unsigned big integer.\n192-bit unsigned big integer.\n2048-bit unsigned big integer.\n256-bit unsigned big integer.\n3072-bit unsigned big integer.\n320-bit unsigned big integer.\n32768-bit unsigned big integer.\n3584-bit unsigned big integer.\n384-bit unsigned big integer.\n4096-bit unsigned big integer.\n4224-bit unsigned big integer.\n4352-bit unsigned big integer.\n448-bit unsigned big integer.\n512-bit unsigned big integer.\n576-bit unsigned big integer.\n6144-bit unsigned big integer.\n64-bit unsigned big integer.\n640-bit unsigned big integer.\n704-bit unsigned big integer.\n768-bit unsigned big integer.\n8192-bit unsigned big integer.\n832-bit unsigned big integer.\n896-bit unsigned big integer.\n960-bit unsigned big integer.\nStack-allocated big unsigned integer.\nWide integer type: double the width of <code>Word</code>.\nUnsigned integer type that the <code>Limb</code> newtype wraps.\nProvides intentionally-wrapped arithmetic on <code>T</code>.\nThe value <code>0</code>.\nThe value <code>0</code>.\nThe value <code>0</code>.\nZero values.\nComputes <code>self + rhs + carry</code>, returning the result along …\nComputes <code>a + b + carry</code>, returning the result along with …\nCompute <code>self + rhs mod p</code>.\nComputes <code>self + rhs mod p</code>.\nComputes <code>self + rhs mod p</code> for the special modulus …\nBorrow the limbs of this <code>Uint</code>.\nBorrow the limbs of this <code>Uint</code> mutably.\nBorrow the inner limbs as an array of <code>Word</code>s.\nBorrow the inner limbs as a mutable array of <code>Word</code>s.\nGet the value of the bit at position <code>index</code>, as a truthy or …\nReturns <code>true</code> if the bit at position <code>index</code> is set, <code>false</code> …\nCalculates <code>a &amp; b</code>.\nComputes bitwise <code>a &amp; b</code>.\nCalculates <code>a | b</code>.\nComputes bitwise <code>a &amp; b</code>.\nCalculate the number of bits needed to represent this …\nCalculate the number of bits needed to represent this …\nCalculate the number of bits needed to represent this …\nCalculates <code>a ^ b</code>.\nComputes bitwise <code>a ^ b</code>.\nPerform checked subtraction, returning a <code>CtOption</code> which …\nPerform checked bitwise <code>AND</code>, returning a <code>CtOption</code> which …\nPerform checked division, returning a <code>CtOption</code> which …\nPerform checked multiplication, returning a <code>CtOption</code> which …\nPerform checked bitwise <code>OR</code>, returning a <code>CtOption</code> which …\nPerform checked reduction, returning a <code>CtOption</code> which …\nSee <code>Self::checked_sqrt_vartime</code>.\nPerform checked sqrt, returning a <code>CtOption</code> which <code>is_some</code> …\nPerform checked subtraction, returning a <code>CtOption</code> which …\nPerform checked bitwise <code>XOR</code>, returning a <code>CtOption</code> which …\nPerform a comparison of the inner value in variable-time.\nReturns the Ordering between <code>self</code> and <code>rhs</code> in variable time.\nConcatenate the two halves, with <code>self</code> as most significant …\nConcatenate the two halves, with <code>self</code> as most significant …\nConcatenate the two values, with <code>self</code> as most significant …\nConcatenate the two values, with <code>self</code> as most significant …\nConcatenate the two values, with <code>self</code> as most significant …\nConcatenate the two values, with <code>self</code> as most significant …\nConcatenate the two values, with <code>self</code> as most significant …\nConcatenate the two values, with <code>self</code> as most significant …\nConcatenate the two values, with <code>self</code> as most significant …\nConcatenate the two values, with <code>self</code> as most significant …\nConcatenate the two values, with <code>self</code> as most significant …\nConcatenate the two values, with <code>self</code> as most significant …\nConcatenate the two values, with <code>self</code> as most significant …\nConcatenate the two values, with <code>self</code> as most significant …\nConcatenate the two values, with <code>self</code> as most significant …\nConcatenate the two values, with <code>self</code> as most significant …\nConcatenate the two values, with <code>self</code> as most significant …\nConcatenate the two values, with <code>self</code> as most significant …\nConcatenate the two values, with <code>self</code> as most significant …\nConcatenate the two values, with <code>self</code> as most significant …\nConcatenate the two values, with <code>self</code> as most significant …\nConcatenate the two values, with <code>self</code> as most significant …\nConcatenate the two values, with <code>self</code> as most significant …\nConst-friendly assertion that two values are equal.\nConst-friendly assertion that two values are NOT equal.\nCreates a new non-zero limb in a const context. The second …\nCreates a new non-zero integer in a const context. The …\nComputes <code>self</code> % <code>rhs</code>, returns the remainder and and the …\nComputes <code>self</code> % <code>rhs</code>, returns the remainder and and the …\nCreates a <code>Residue</code> with the given value for a specific …\nComputes <code>self</code> / <code>rhs</code> using a pre-made reciprocal, returns …\nPre-calculates a reciprocal for a known divisor, to be …\nReturns a default instance of this object. It is a …\nComputes self / rhs, returns the quotient, remainder.\nComputes <code>self</code> / <code>rhs</code>, returns the quotient (q) and …\nComputes <code>self</code> / <code>rhs</code> using a pre-made reciprocal, returns …\nPerforms an equality check in variable-time.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nDeserialize from a big-endian byte array.\nDecode a non-zero integer from big endian bytes.\nDecode from big endian bytes.\nDecode from big endian bytes.\nCreate a new <code>Uint</code> from the provided big endian hex string.\nCreate a new <code>Uint</code> from the provided big endian bytes.\nDeserialize from a little-endian byte array.\nDecode a non-zero integer from big endian bytes.\nDecode from little endian bytes.\nDecode from little endian bytes.\nCreate a new <code>Uint</code> from the provided little endian hex …\nCreate a new <code>Uint</code> from the provided little endian bytes.\nCreate a <code>NonZero&lt;Uint&gt;</code> from a <code>NonZeroU128</code> (const-friendly)\nCreate a <code>Uint</code> from a <code>u128</code> (const-friendly)\nCreate a <code>Limb</code> from a <code>u16</code> integer (const-friendly)\nCreate a <code>NonZero&lt;Limb&gt;</code> from a <code>NonZeroU16</code> (const-friendly)\nCreate a <code>NonZero&lt;Uint&gt;</code> from a <code>NonZeroU16</code> (const-friendly)\nCreate a <code>Uint</code> from a <code>u16</code> (const-friendly)\nCreate a <code>Limb</code> from a <code>u32</code> integer (const-friendly)\nCreate a <code>NonZero&lt;Uint&gt;</code> from a <code>NonZeroU32</code> (const-friendly)\nCreate a <code>NonZero&lt;Limb&gt;</code> from a <code>NonZeroU32</code> (const-friendly)\nCreate a <code>Uint</code> from a <code>u32</code> (const-friendly)\nCreate a <code>Limb</code> from a <code>u64</code> integer (const-friendly)\nCreate a <code>NonZero&lt;Uint&gt;</code> from a <code>NonZeroU64</code> (const-friendly)\nCreate a <code>NonZero&lt;Limb&gt;</code> from a <code>NonZeroU64</code> (const-friendly)\nCreate a <code>Uint</code> from a <code>u64</code> (const-friendly)\nCreate a <code>Limb</code> from a <code>u8</code> integer (const-friendly)\nCreate a <code>NonZero&lt;Limb&gt;</code> from a <code>NonZeroU8</code> (const-friendly)\nCreate a <code>NonZero&lt;Uint&gt;</code> from a <code>NonZeroU8</code> (const-friendly)\nCreate a <code>Uint</code> from a <code>u8</code> (const-friendly)\nCreate a <code>NonZero&lt;Uint&gt;</code> from a <code>Uint</code> (const-friendly)\nCreate a <code>Uint</code> from a <code>WideWord</code> (const-friendly)\nCreate a <code>Uint</code> from a <code>Word</code> (const-friendly)\nCreate a <code>Uint</code> from an array of <code>Word</code>s (i.e. word-sized …\nImplements a modulus with the given name, type, and value, …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDeserialize from a big-endian <code>GenericArray</code>.\nDeserialize from a little-endian <code>GenericArray</code>.\nComputes the multiplicative inverse of <code>self</code> mod <code>modulus</code>. …\nComputes 1/<code>self</code> mod <code>2^k</code>.\nComputes 1/<code>self</code> mod <code>2^k</code>. This method is constant-time …\nComputes the multiplicative inverse of <code>self</code> mod <code>modulus</code>, …\nComputes the multiplicative inverse of <code>self</code> mod <code>modulus</code>, …\nComputes the inverse.\nIs this integer value an even number?\nIs this integer value an even number?\nIs this integer value an odd number?\nIs this limb an odd number?\nDetermine if this value is equal to zero.\nDetermine if this value is equal to zero.\nCalculate the number of leading zeros in the binary …\nCalculate the number of leading zeros in the binary …\nCalculate the number of leading zeros in the binary …\nComputes <code>self + (b * c) + carry</code>, returning the result …\nImplements modular arithmetic for constant moduli.\nMultiply <code>self</code> by <code>rhs</code>, returning a concatenated “wide” …\nCompute <code>self * rhs mod p</code>.\nComputes <code>self * rhs mod p</code> for the special modulus …\nCompute “wide” multiplication, with a product twice …\nCalculates <code>x1 ^ k1 * ... * xn ^ kn</code>.\nCalculates <code>x1 ^ k1 * ... * xn ^ kn</code>.\nCompute <code>-self mod p</code>.\nComputes <code>-a mod p</code>. Assumes <code>self</code> is in <code>[0, p)</code>.\nComputes <code>-a mod p</code> for the special modulus <code>p = MAX+1-c</code> …\nCreate a new checked arithmetic wrapper for the given …\nCreate a new non-zero integer.\nA non-const-fn version of <code>new_const()</code>, wrapping the result …\nConst-friendly <code>Uint</code> constructor.\nCalculate the number of limbs required to represent the …\nCalculates <code>!a</code>.\nComputes bitwise <code>!a</code>.\nRaises to the <code>exponent</code> power.\nRaises to the <code>exponent</code> power, with <code>exponent_bits</code> …\nImport prelude for this crate: includes important traits.\nGenerate a cryptographically secure random value.\nGenerate a random <code>NonZero&lt;T&gt;</code>.\nGenerate a cryptographically secure random <code>Uint</code>.\nGenerate a cryptographically secure random number which is …\nGenerate a cryptographically secure random <code>Uint</code> which is …\nComputes self % rhs, returns the remainder.\nComputes <code>self</code> % 2^k. Faster than reduce since its a power …\nConstruct a <code>Uint&lt;T&gt;</code> from the unsigned integer value, …\nPerform saturating addition.\nPerform saturating addition, returning <code>MAX</code> on overflow.\nPerform saturating multiplication.\nPerform saturating multiplication, returning <code>MAX</code> on …\nPerform saturating subtraction.\nPerform saturating subtraction, returning <code>ZERO</code> on …\nComputes <code>self - (rhs + borrow)</code>, returning the result along …\nComputes <code>a - (b + borrow)</code>, returning the result along with …\nComputes <code>self &lt;&lt; rhs</code>. Panics if <code>rhs</code> overflows <code>Limb::BITS</code>.\nNOTE: this operation is variable time with respect to <code>rhs</code> …\nNOTE: this operation is variable time with respect to <code>rhs</code> …\nComputes <code>self &lt;&lt; n</code>. Returns zero if <code>n &gt;= Self::BITS</code>.\nNOTE: this operation is variable time with respect to <code>rhs</code> …\nComputes <code>self &lt;&lt; shift</code>.\nComputes a left shift on a wide input as <code>(lo, hi)</code>.\nComputes <code>self &gt;&gt; rhs</code>. Panics if <code>rhs</code> overflows <code>Limb::BITS</code>.\nComputes <code>self &lt;&lt; n</code>. Returns zero if <code>n &gt;= Self::BITS</code>.\nNOTE: this operation is variable time with respect to <code>rhs</code> …\nNOTE: this operation is variable time with respect to <code>rhs</code> …\nComputes <code>self &gt;&gt; n</code>.\nComputes a right shift on a wide input as <code>(lo, hi)</code>.\nSplit this number in half, returning its high and low …\nSplit this number in half, returning its high and low …\nSplit this number in half, returning its high and low …\nSplit this number in half, returning its high and low …\nSplit this number in half, returning its high and low …\nSplit this number in half, returning its high and low …\nSplit this number in half, returning its high and low …\nSplit this number in half, returning its high and low …\nSplit this number in half, returning its high and low …\nSplit this number in half, returning its high and low …\nSplit this number in half, returning its high and low …\nSplit this number in half, returning its high and low …\nSplit this number in half, returning its high and low …\nSplit this number in half, returning its high and low …\nSplit this number in half, returning its high and low …\nSplit this number in half, returning its high and low …\nSplit this number in half, returning its high and low …\nSplit this number in half, returning its high and low …\nSplit this number in half, returning its high and low …\nSplit this number in half, returning its high and low …\nSplit this number in half, returning its high and low …\nSplit this number in half, returning its high and low …\nSplit this number in half, returning its high and low …\nSplit this number in half, returning its high and low …\nSplit this number in half, returning its high and low …\nSplit this number in half, returning its high and low …\nSplit this number in half, returning its high and low …\nSplit this number in half, returning its high and low …\nSplit this number in half, returning its high and low …\nSplit this number in half, returning its high and low …\nSplit this number in half, returning its high and low …\nSplit this number in half, returning its high and low …\nSplit this number in half, returning its high and low …\nSplit this number in half, returning its high and low …\nSplit this number in half, returning its high and low …\nSplit this number in half, returning its high and low …\nSplit this number in half, returning its high and low …\nSplit this number in half, returning its high and low …\nSplit this number in half, returning its high and low …\nSplit this number in half, returning its high and low …\nSplit this number in half, returning its high and low …\nSplit this number in half, returning its high and low …\nSplit this number into parts, returning its high and low …\nSee <code>Self::sqrt_vartime</code>.\nComputes √(<code>self</code>) Uses Brent &amp; Zimmermann, Modern …\nComputes the same as <code>self.mul(self)</code>, but may be more …\nComputes the same as <code>self.mul(self)</code>, but may be more …\nSquare self, returning a concatenated “wide” result.\nSquare self, returning a “wide” result in two parts as …\nCompute <code>self - rhs mod p</code>.\nComputes <code>self - rhs mod p</code>.\nComputes <code>self - rhs mod p</code> for the special modulus …\nSerialize to a big-endian byte array.\nEncode to big endian bytes.\nSerialize to a little-endian byte array.\nEncode to little endian bytes.\nConvert this <code>Uint</code> into its inner limbs.\nCreate an array of <code>Word</code>s (i.e. word-sized unsigned …\nCalculate the number of trailing ones the binary …\nCalculate the number of trailing ones in the binary …\nCalculate the number of trailing ones in the binary …\nCalculate the number of trailing zeros in the binary …\nCalculate the number of trailing zeros in the binary …\nCalculate the number of trailing zeros in the binary …\nPerform wrapping addition, discarding overflow.\nPerform wrapping addition, discarding overflow.\nPerform wrapping bitwise <code>AND</code>.\nWrapped division is just normal division i.e. <code>self</code> / <code>rhs</code> …\nPerform wrapping multiplication, discarding overflow.\nPerform wrapping multiplication, discarding overflow.\nPerform wrapping negation.\nPerform wrapping negation.\nPerform wrapping bitwise <code>OR</code>.\nWrapped (modular) remainder calculation is just <code>self</code> % <code>rhs</code>.\nSee <code>Self::wrapping_sqrt_vartime</code>.\nWrapped sqrt is just normal √(<code>self</code>) There’s no way …\nPerform wrapping subtraction, discarding underflow and …\nPerform wrapping subtraction, discarding underflow and …\nPerform wrapping bitwise `XOR``.\nThe type-level bit 0.\nThe type-level bit 1.\nThe type-level signed integer 0.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInstantiates a singleton representing this bit.\nInstantiates a singleton representing this bit.\nInstantiates a singleton representing the integer 0.\nThe original type.\nA generalization for numbers kept in optimized …\nImplements <code>Residue</code>s, supporting modular arithmetic with a …\nAlgorithm 14.32 in Handbook of Applied Cryptography …\nConvert the number back from the optimized representation.\nImplements <code>DynResidue</code>s, supporting modular arithmetic with …\nNumber of limbs required to encode a residue\nThe constant modulus\nThe lowest limbs of -(MODULUS^-1) mod R\nThe representation of 1 mod <code>MOD</code>.\nParameter used in Montgomery reduction\nR^2, used to move into Montgomery form\nR^3, used to perform a multiplicative inverse\nA residue mod <code>MOD</code>, represented using <code>LIMBS</code> limbs. The …\nThe parameters to efficiently go to and from the …\nThe representation of 0 mod <code>MOD</code>.\nAdds <code>rhs</code>.\nAccess the <code>Residue</code> value in Montgomery form.\nMutably access the <code>Residue</code> value in Montgomery form.\nCreates a <code>Residue</code> with the given value for a specific …\nPerforms the modular division by 2, that is for given <code>x</code> …\nReturns the argument unchanged.\nCreate a <code>Residue</code> from a value in Montgomery form.\nImplements a modulus with the given name, type, and value, …\nCalls <code>U::from(self)</code>.\nComputes the residue <code>self^-1</code> representing the …\nMultiplies by <code>rhs</code>.\nNegates the number.\nInstantiates a new <code>Residue</code> that represents this <code>integer</code> …\nInstantiates a new <code>Residue</code> that represents this <code>integer</code> …\nRaises to the <code>exponent</code> power.\nRaises to the <code>exponent</code> power, with <code>exponent_bits</code> …\nRetrieves the integer currently encoded in this <code>Residue</code>, …\nComputes the (reduced) square of a residue.\nSubtracts <code>rhs</code>.\nExtract the value from the <code>Residue</code> in Montgomery form.\nA residue represented using <code>LIMBS</code> limbs. The odd modulus …\nThe parameters to efficiently go to and from the …\nAdds <code>rhs</code>.\nAccess the <code>DynResidue</code> value in Montgomery form.\nMutably access the <code>DynResidue</code> value in Montgomery form.\nPerforms the modular division by 2, that is for given <code>x</code> …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a <code>DynResidue</code> from a value in Montgomery form.\nCreate <code>DynResidueParams</code> corresponding to a <code>ResidueParams</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nComputes the residue <code>self^-1</code> representing the …\nReturns the modulus which was used to initialize these …\nMultiplies by <code>rhs</code>.\nNegates the number.\nInstantiates a new set of <code>ResidueParams</code> representing the …\nInstantiates a new <code>Residue</code> that represents this <code>integer</code> …\nInstantiates a new set of <code>ResidueParams</code> representing the …\nInstantiates a new <code>Residue</code> that represents 1.\nReturns the parameter struct used to initialize this …\nRaises to the <code>exponent</code> power.\nRaises to the <code>exponent</code> power, with <code>exponent_bits</code> …\nRetrieves the integer currently encoded in this <code>Residue</code>, …\nComputes the (reduced) square of a residue.\nSubtracts <code>rhs</code>.\nExtract the value from the <code>DynResidue</code> in Montgomery form.\nInstantiates a new <code>Residue</code> that represents zero.\nCompute <code>self + rhs mod p</code>.\nSupport for decoding a <code>GenericArray</code> as a big integer.\nSupport for encoding a big integer as a <code>GenericArray</code>.\nTotal size of the represented integer in bits.\nSize of this integer in bits.\nTotal size of the represented integer in bytes.\nSize of this integer in bytes.\nIntegers whose representation takes a bounded amount of …\nSize of a byte array which encodes a big integer.\nChecked addition.\nChecked multiplication.\nChecked subtraction.\nConcatenate two numbers into a “wide” double-width …\nConcatenate two numbers into a “wide” combined-width …\nEncoding support.\nInteger type.\nConstant-time inversion.\nThe number of limbs used on this platform.\nMaximum value this integer can express.\nConcatenated output: combination of <code>Lo</code> and <code>Self</code>.\nCompute <code>self * rhs mod p</code>.\nPerforms modular multi-exponentiation using Montgomery’s …\nPerforms modular multi-exponentiation using Montgomery’s …\nCompute <code>-self mod p</code>.\nThe value <code>1</code>.\nBig integer which decodes a <code>GenericArray</code>.\nOutput type.\nOutput type.\nOutput type.\nOutput type.\nOutput type.\nOutput type.\nOutput type.\nConcatenated output: twice the width of <code>Self</code>.\nSplit output: high/low components of the value.\nOutput of the inversion.\nConstant-time exponentiation.\nConstant-time exponentiation with exponent of a bounded …\nRandom number generation support.\nModular random number generation support.\nByte array representation.\nSplit a number in half, returning the most significant …\nSplit a number into parts, returning the most significant …\nSupport for optimized squaring\nCompute <code>self - rhs mod p</code>.\nThe value <code>0</code>.\nZero values.\nCompute <code>self + rhs mod p</code>.\nPerform checked subtraction, returning a <code>CtOption</code> which …\nPerform checked multiplication, returning a <code>CtOption</code> which …\nPerform checked subtraction, returning a <code>CtOption</code> which …\nConcatenate the two halves, with <code>self</code> as most significant …\nConcatenate the two values, with <code>self</code> as most significant …\nDeserialize from a big-endian byte array.\nDecode from big endian bytes.\nDeserialize from a little-endian byte array.\nDecode from little endian bytes.\nDeserialize from a big-endian <code>GenericArray</code>.\nDeserialize from a little-endian <code>GenericArray</code>.\nComputes the inverse.\nIs this integer value an even number?\nIs this integer value an odd number?\nDetermine if this value is equal to zero.\nCompute <code>self * rhs mod p</code>.\nCalculates <code>x1 ^ k1 * ... * xn ^ kn</code>.\nCalculates <code>x1 ^ k1 * ... * xn ^ kn</code>.\nCompute <code>-self mod p</code>.\nRaises to the <code>exponent</code> power.\nRaises to the <code>exponent</code> power, with <code>exponent_bits</code> …\nGenerate a cryptographically secure random value.\nGenerate a cryptographically secure random number which is …\nSplit this number in half, returning its high and low …\nSplit this number into parts, returning its high and low …\nComputes the same as <code>self.mul(self)</code>, but may be more …\nCompute <code>self - rhs mod p</code>.\nSerialize to a big-endian byte array.\nEncode to big endian bytes.\nSerialize to a little-endian byte array.\nEncode to little endian bytes.")
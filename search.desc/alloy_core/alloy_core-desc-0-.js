searchState.loadedDescShard("alloy_core", 0, "Alloy\nAddress.\nAn address.\nDynamically sized array.\nA dynamically-sized array of values.\nBoolean.\nA boolean.\nDynamic bytes.\nA dynamic-length byte array.\nWhether the ABI-encoded size is dynamic.\nWhether the ABI-encoded size is dynamic.\nA decoded dynamic ABI error.\nA decoded dynamic ABI event.\nThe <code>Decoder</code> wraps a byte slice with necessary info to …\nA dynamic-length sequence.\nA representation of a Solidity call\nA dynamic ABI error.\nA dynamic ABI event.\nA representation of a Solidity call’s returns.\nA dynamic Solidity type.\nA dynamic Solidity value.\nA dynamic token.\nThe statically-known ABI-encoded size of the type.\nEIP-712 domain attributes used in determining the domain …\nLength mismatch during encoding.\nAn ABI encoder.\nContains the error value\nError when parsing EIP-712 <code>encodeType</code> strings\nProvides error encoding and decoding for the <code>Error</code> type.\nProvides event encoding and decoding for the <code>Event</code> type.\nInvalid event signature.\nFixed-sized array.\nA fixed-size array of values.\nFixed-size bytes, up to 32.\nA fixed-length byte array. The second parameter is the …\nA Fixed Sequence.\nFunction.\nA function pointer.\nProvide ABI encoding and decoding for the <code>Function</code> type.\n<code>hex</code> error.\nSigned Integer.\nA signed integer. The second parameter is the number of …\nProvides ABI encoding and decoding functionality.\nThe name of the struct.\nContains the success value\nThe statically-known Non-standard Packed Mode ABI-encoded …\nA packed sequence (string or bytes).\nDynamic ABI result type.\nThe corresponding Rust type.\nThe name of this type in Solidity.\nSelector mismatch during function or error decoding.\nA Solidity type.\n<code>alloy_sol_types</code> error.\nTrait for items that can be resolved to <code>DynSol*</code>, i.e. they …\nString.\nA string.\nThe corresponding ABI token type.\nLength mismatch during event topic decoding.\nTuple.\nA tuple of values.\nType mismatch during encoding or coercion.\n<code>alloy_sol_type_parser</code> error.\nUnsigned Integer.\nAn unsigned integer. The second parameter is the number of …\nThe ABI word type.\nA single word.\nEthereum ABI codec implementation.\nDecode a <code>DynSolValue</code> from a byte slice. Fails if the value …\nDecodes this type’s value from an ABI blob by …\nDecodes this type’s value from an ABI blob by …\nABI-decodes the given data according to this item’s …\nABI decode the given data as function returns.\nABI-decodes the given data according to this functions’s …\nABI decode the given data as function return values.\nABI decode the given data as function return values.\nDecode a <code>DynSolValue</code> from a byte slice. Fails if the value …\nDecodes this type’s value from an ABI blob by …\nDecodes this type’s value from an ABI blob by …\nDecodes this type’s value from an ABI blob by …\nDecodes this type’s value from an ABI blob by …\nDecode a <code>DynSolValue</code> from a byte slice. Fails if the value …\nDecodes this type’s value from an ABI blob by …\nDecodes this type’s value from an ABI blob by …\nDecodes this type’s value from an ABI blob by …\nDecodes this type’s value from an ABI blob by …\nDecodes this type’s value from an ABI blob by …\nDecodes this type’s value from an ABI blob by …\nEncode this value into a byte array by wrapping it into a …\nTokenizes and ABI-encodes the given value by wrapping it …\nTokenizes and ABI-encodes the given value by wrapping it …\nABI-encodes the given values, prefixed by this item’s …\nABI encode the given values as function params.\nABI-encodes the given values, without prefixing the data …\nABI encode the given values as function params without …\nABI-encodes the given values.\nABI encode the given values as function return values.\nABI encode the given values as function return values.\nNon-standard Packed Mode ABI encoding.\nNon-standard Packed Mode ABI encoding.\nNon-standard Packed Mode ABI encoding.\nNon-standard Packed Mode ABI encoding.\nNon-standard Packed Mode ABI encoding.\nNon-standard Packed Mode ABI encoding.\nEncode this value into a byte array suitable for passing …\nTokenizes and ABI-encodes the given value as function …\nTokenizes and ABI-encodes the given value as function …\nIf this value is a fixed sequence, encode it into a byte …\nTokenizes and ABI-encodes the given value as a sequence.\nTokenizes and ABI-encodes the given value as a sequence.\nCalculate the ABI-encoded size of the data, counting both …\nCalculate the ABI-encoded size of the data, counting both …\nReturns the number of bytes that will be used to encode …\nReturns the length of this value when ABI-encoded in …\nReturns the length of this value when ABI-encoded in …\nReturns the length of this value when ABI-encoded in …\nShortcut for appending a token sequence.\nAppend a pointer to the current suffix offset.\nAppend a sequence of bytes as a packed sequence with a …\nAppend a sequence length.\nAppend a word to the encoder.\nFallible cast to the contents of a variant DynSolValue {.\nFallible cast to the contents of a variant.\nFallible cast to the contents of a variant.\nFallible cast to the contents of a variant.\nFallible cast to the contents of a variant.\nFallible cast to the contents of a variant.\nFallible cast into a dynamic sequence.\nFallible cast to the contents of a variant.\nFallible cast to the contents of a variant.\nFallible cast into a fixed sequence.\nFallible cast to a fixed-size array. Any of a <code>FixedArray</code>, …\nFallible cast to the contents of a variant.\nFallible cast into a packed sequence.\nFallible cast to a packed sequence. Any of a String, or a …\nFallible cast to the contents of a variant.\nFallible cast into a sequence, dynamic or fixed-size\nFallible cast to the contents of a variant.\nFallible cast to the contents of a variant.\nThe Solidity type. This returns the Solidity type …\nFallible cast to the contents of a variant.\nAttempt to cast to a word.\nFallible cast to a single word. Will succeed for any …\nError body types.\nGet the un-indexed types.\nThe decoded error body.\nThe un-indexed values, in order.\nBump the suffix offset by a given number of words.\nReturn a reference to the encoded bytes.\nThe EIP-155 chain ID. The user-agent should refuse signing …\nCreate a child decoder, starting at <code>offset</code> bytes from the …\nCoerces a string into a <code>DynSolValue</code> via this type.\nInstantiates a new error with a static str.\nDecodes a single token from the underlying buffer.\nDecode the error from the given data.\nDecode the error from the given data.\nDecodes the given log object according to this item’s …\nDecode the event from the given log info.\nDecodes the given log info according to this item’s …\nDecode the event from the given log info.\nDecodes a sequence of tokens from the underlying buffer.\nDetokenize this type’s value from the given token.\nDynamic detokenization.\nEncode this data according to EIP-712 <code>encodeData</code> rules, …\nEncode this data according to EIP-712 <code>encodeData</code> rules, …\nEncodes this domain using EIP-712 <code>encodeData</code>.\nEncodes this domain using EIP-712 <code>encodeData</code> into the …\nTransform a <code>Log</code> containing this event into a <code>Log</code> containing\nRe-encode the event into a <code>LogData</code>\nThe EIP-712-encoded type string.\nFinish the encoding process, returning the encoded words.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInstantiate a DynToken from a dynamic sequence of values.\nInstantiate a DynToken from a fixed sequence of values.\nReturns whether this type is contains a custom struct.\nReturns whether this type is contains a custom struct.\nHashes this domain according to EIP-712 <code>hashStruct</code>.\nAppend this data to the head of an in-progress blob via …\nGet the indexed types.\nThe indexed values, in order.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nFinish the encoding process, returning the encoded bytes.\nTrue if anonymous.\nTrue if anonymous. False if not.\nReturns <code>true</code> if this type is dynamically sized type.\nTrue if the type is dynamic, else false.\nReturns <code>true</code> if the value is an instance of a dynamically …\nReturns whether the remaining buffer is empty.\nReturns true if the value is a sequence type.\nTrust if this value is encoded as a single word. False …\nReturn true if the type is zero-sized, e.g. <code>()</code> or <code>T[0]</code>\nCheck that the given <code>DynSolValue</code> matches this type.\nCheck that this value has the same type as the given …\nCheck that the given <code>DynSolValue</code>s match these types.\nCheck that these values have the same type as the given …\nGet the method name of the call (if available)\nCalculate the minimum number of ABI words necessary to …\nCalculate the minimum number of words required to encode …\nThe user readable name of signing domain, i.e. the name of …\nCalculate the nesting depth of this type. Simple types …\nCreates a new error from a selector.\nCreates a new event.\nCreate a new <code>DynSolCall</code> with the given selector and types.\nCreate a new <code>DynSolReturns</code> with the given types.\nInstantiate a new empty encoder.\nInstantiate a new decoder from a byte slice and a …\nInstantiate a new EIP-712 domain.\nCreates a new error, without length-checking the body. …\nCreates a new event, without length-checking the indexed, …\nReturns the number of ABI words (32 bytes) that will be …\nReturns the current offset in the buffer.\nA Solidity panic.\nParses a Solidity type name string into a <code>DynSolType</code>.\nPeek into the buffer.\nPeek a slice of size <code>len</code> from the buffer without advancing …\nPeek a slice of size <code>len</code> from the buffer at a specific …\nPeek a <code>usize</code> from the buffer, without advancing the offset.\nPeek a <code>usize</code> from the buffer at a specific offset, without …\nPeek the next word from the buffer without advancing the …\nPeek a word from the buffer at a specific offset, without …\nRemoves the last offset and returns it.\nAppends a suffix offset.\nCreate a child decoder, starting at <code>offset</code> bytes from the …\nReturns the number of bytes in the remaining buffer.\nReturns a reference to the remaining bytes in the buffer.\nReturns the number of words in the remaining buffer.\nResolve the type into a value.\nGet the types of the call’s returns.\nRepresents a standard Solidity revert. These are thrown by …\nA disambiguating salt for the protocol. This can be used …\nError selector is the first 4 bytes of the keccak256 hash …\nGet the selector of the call.\nThe hashes event_signature (if any)\nCalculate the domain separator for the domain object.\nSets the current offset in the buffer.\nThe Solidity type name. This returns the Solidity type …\nThe Solidity type name. This returns the Solidity type …\nReturns the name of this type in Solidity.\nReturns the name of this type in Solidity.\nDetermine the current suffix offset.\nAppend this data to the tail of an in-progress blob via …\nReturn a child decoder by consuming a word, interpreting …\nTakes a <code>usize</code> offset from the buffer by consuming a word.\nTakes the offset from the child decoder and sets it as the …\nTakes a slice of bytes of the given length.\nTake a word from the buffer, advancing the offset.\nThe Solidity type name, as a <code>String</code>.\nTokenize this value into a <code>DynToken</code>.\nTokenizes the given value into this type’s token.\nTokenizes the given value into this type’s token.\nGet the selector for this event, if any.\nReturns an error if the given token cannot be detokenized …\nReturns an error if the given token cannot be detokenized …\nCalculates the EIP-712 <code>typeHash</code> for this domain.\nGet the types of the call.\nGet the types of the returns.\nReturns <code>true</code> if the given token can be detokenized with …\nThe address of the contract that will verify the signature.\nThe current major version of the signing domain. …\nInstantiate a new encoder with a given capacity in words.\nReturn a reference to the encoded words.\nThe contents of the dynamic sequence.\nThe actual type.\nThe actual length.\nThe actual length.\nThe actual selector.\nThe actual signature.\nThe expected type.\nThe expected length.\nThe expected length.\nThe expected selector.\nThe expected signature.\nTrue if the token represents a dynamically-sized type.\nThe <code>Decoder</code> wraps a byte slice with necessary info to …\nThe ABI encoding of an empty byte array (<code>bytes</code> or <code>string</code>).\nAn ABI encoder.\nTrue for tuples only.\nTrue for tuples only.\nTrue for tuples only.\nThe decoder recursion limit. This is currently hardcoded, …\nEthereum ABI tokens.\nA token composed of a sequence of other tokens.\nABI-decodes a token by wrapping it in a single-element …\nDecode a token from a decoder.\nABI-decodes top-level function args.\nDecodes ABI compliant vector of bytes into vector of …\nABI-decode the token sequence from the encoder.\nABI-encodes a single token.\nABI-encodes a tuple as ABI function params, suitable for …\nABI-encodes a token sequence.\nABI-encode the token sequence into the encoder.\nAppend head words to the encoder.\nCalculate the number of head words.\nAppend tail words to the encoder.\nCalculate the number of tail words.\nEthereum ABI tokens.\nCalculate the total number of head and tail words.\nCalculate the total number of head and tail words.\nCalculate the total number of head and tail words.\nTrue if the token represents a dynamically-sized type.\nA Dynamic Sequence - <code>T[]</code>\nA Fixed Sequence - <code>T[N]</code>\nTrue for tuples only.\nA Packed Sequence - <code>bytes</code> or <code>string</code>\nEthereum ABI tokens.\nA token composed of a sequence of other tokens.\nA single EVM word - T for any value type.\nReturns a reference to the array.\nReturns a reference to the word as a slice.\nReturns a reference to the array as a slice.\nReturns a reference to the backing slice.\nReturns a reference to the slice.\nDecode a token from a decoder.\nABI-decode the token sequence from the encoder.\nABI-encode the token sequence into the encoder.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAppend head words to the encoder.\nCalculate the number of head words.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTake the backing array, consuming the token.\nInstantiate a new <code>Bytes</code> by copying the underlying slice.\nInstantiate a new <code>Vec</code> by copying the underlying slice.\nCreate a new word token from a word.\nAppend tail words to the encoder.\nCalculate the number of tail words.\nCalculate the total number of head and tail words.\n<code>calldata</code>\nContains the error value\nParser error.\nThe regular expression for a Solidity identifier.\n<code>memory</code>\nNonpayable functions promise not to receive Ether.\nContains the success value\nRepresents a function parameter.\nRepresents a list of function parameters.\nPayable functions make no promises.\nPure functions promise not to read from or modify the …\nParser result\nRoot type.\nA root type, with no array suffixes. Corresponds to a …\nA JSON ABI function’s state mutability.\nStorage specifier.\n<code>storage</code>\nTuple type.\nA tuple specifier, with no array suffixes. Corresponds to …\nRepresents a type-name. Consists of an identifier and …\nA stem of a Solidity array type. It is either a root type, …\nView functions promise not to modify the state.\nFallible conversion to a root type\nReturns a string representation of the storage specifier.\nFallible conversion to a tuple type\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nWhether the parameter indexed.\nInner input being wrapped in state\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInstantiate an invalid identifier string error. Invalid …\nInstantiate an invalid size error. Invalid size errors are …\nInstantiate an invalid type string error. Invalid type …\nReturns true if this type is an array.\nReturns <code>true</code> if the given character is valid in a Solidity …\nReturns <code>true</code> if the given character is valid at the start …\nReturns <code>true</code> if the given string is a valid Solidity …\nThe name of the parameter.\nInstantiate a new error.\nCreate a new root type from a string without checking if it…\nThe parameters.\nParse a root type from a string.\nParse a type stem from a string.\nParse a tuple specifier from a string.\nParse a type specifier from a string.\nParse a parameter from a string.\nParse a parameter list from a string.\nParse a string storage specifier.\nInstantiate a new parser error.\n<code>serde</code> implementation for <code>StateMutability</code> for backwards …\nArray sizes, in innermost-to-outermost order. If the size …\nThe string underlying this type. The type name.\nReturns the type stem as a string.\nReturns the tuple specifier as a string.\nReturns the type stem as a string.\nThe full span of the tuple specifier.\nThe full span of the specifier.\nThe full span of the specifier.\nThe full span of the specifier.\nUser-provided state\nReturns the type stem.\nThe type stem, which is either a root type or a tuple type.\nThe storage specifier.\nReturns <code>Ok(())</code> if the type is a basic Solidity type.\nReturns true if the type is a basic Solidity type.\nReturns true if the type is a basic Solidity type.\nReturns true if the type is a basic Solidity type.\nThe type of the parameter.\nThe internal types.\nDeserializes a <code>StateMutability</code>, compatible with older JSON …\nSerializes a <code>StateMutability</code> as a single-field struct (…\nA JSON ABI item.\nAddress payable.\nA JSON ABI constructor function.\nA JSON ABI <code>Constructor</code>.\nContract.\nRepresents a generic contract’s ABI, bytecode and …\nEnum. Possibly of the form <code>contract.enum</code>.\nA JSON ABI error.\nA JSON ABI <code>Error</code>.\nA JSON ABI event.\nA JSON ABI <code>Event</code>.\nA Solidity Event parameter.\nA JSON ABI fallback function.\nA JSON ABI <code>Fallback</code>.\nA JSON ABI function.\nA JSON ABI <code>Function</code>.\nThe contract internal type. This could be a regular …\nAn iterator over items in an ABI.\nAn iterator over immutable references of items in an ABI.\nThe JSON contract ABI, as specified in the Solidity ABI …\nNonpayable functions promise not to receive Ether.\nOther. Possible of the form <code>contract.other</code>.\nJSON specification of a parameter.\nPayable functions make no promises.\nPure functions promise not to read from or modify the …\nA JSON ABI receive function.\nA JSON ABI <code>Receive</code>.\nA JSON ABI function’s state mutability.\nStruct. Possibly of the form <code>contract.struct</code>.\nConfiguration for <code>JsonAbi::to_sol</code>.\nView functions promise not to modify the state.\nThe contract ABI.\nWhether the event is anonymous. Anonymous events do not …\nFallible conversion to a variant.\nFallible conversion to a variant.\nReturns the string representation of the state mutability …\nFallible conversion to a variant.\nReturns the string representation of the state mutability.\nFallible conversion to a variant.\nThe contract bytecode.\nIf the parameter is a compound type (a struct or tuple), a …\nIf the parameter is a compound type (a struct or tuple), a …\nReturns an immutable reference to the constructor.\nThe constructor function.\nReturns a mutable reference to the constructor.\nThe struct specifier is a <code>TypeSpecifier</code> containing the …\nThe struct specifier is a <code>TypeSpecifier</code> containing the …\nReturn a <code>TypeSpecifier</code> describing the contract if this …\nReturns the debug name of the item.\nDeduplicates all functions, errors, and events which have …\nThe contract deployed bytecode.\nThe enum specifier is a <code>TypeSpecifier</code> containing the enum …\nThe enum specifier is a <code>TypeSpecifier</code> containing the enum …\nReturn a <code>TypeSpecifier</code> describing the enum if this type is …\nSets whether to print <code>enum</code>s as user-defined value types …\nReturns an immutable reference to the list of all the …\nReturns a mutable reference to the list of all the errors …\nReturns an iterator over immutable references to the …\nThe errors, indexed by the error name.\nReturns an iterator over mutable references to the errors.\nReturns an immutable reference to the list of all the …\nReturns an immutable reference to the event inputs of the …\nReturns a mutable reference to the event inputs of the …\nReturns a mutable reference to the list of all the events …\nReturns an iterator over immutable references to the …\nThe events, indexed by the event name.\nReturns an iterator over mutable references to the events.\nThe fallback function.\nSets whether to normalize the output for the <code>sol!</code> macro. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nFormats the canonical type of this parameter into the …\nFormats the canonical type of this parameter into the …\nReturns this function’s full signature including names …\nReturns this event’s full signature …\nReturns an immutable reference to the list of all the …\nReturns the <em>first</em> <code>Function</code> with a matching selector.\nReturns a mutable reference to the list of all the …\nReturns an iterator over immutable references to the …\nThe functions, indexed by the function name.\nReturns an iterator over mutable references to the …\nWhether the parameter is indexed. Indexed parameters have …\nReturns an immutable reference to the inputs of the item.\nThe input types of the constructor. May be empty.\nThe input types of the function. May be empty.\nA list of the event’s inputs, in order.\nA list of the error’s components, in order.\nReturns a mutable reference to the inputs of the item.\nThe internal type of the parameter.\nThe internal type of the parameter.\nThe internal type of the parameter. This type represents …\nThe internal type of the parameter. This type represents …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns an iterator over all of the items in the ABI.\nTrue if the instance is a <code>address payable</code> variant.\nTrue if the type is complex (tuple or struct)\nTrue if the type is complex (tuple or struct)\nTrue if the parameter is a contract.\nTrue if the parameter is a contract.\nTrue if the instance is a <code>contract</code> variant.\nReturns true if the ABI contains no items.\nTrue if the parameter is an enum.\nTrue if the parameter is an enum.\nTrue if the instance is a <code>enum</code> variant.\nTrue if the instance is a <code>other</code> variant.\nTrue if the type is simple\nTrue if the type is simple\nTrue if the parameter is a struct.\nTrue if the parameter is a struct.\nTrue if the instance is a <code>struct</code> variant.\nTrue if the parameter is a UDT (user-defined type).\nTrue if the parameter is a UDT (user-defined type).\nReturns an iterator over all of the items in the ABI.\nReturns the JSON type of the item as a string.\nReturns the total number of items (of any type).\nReturns an immutable reference to the name of the item.\nThe name of the parameter. This function always returns …\nThe name of the function.\nThe name of the event.\nThe name of the error.\nReturns a mutable reference to the name of the item.\nCreates an empty ABI object.\nValidate and create new instance of Param.\nValidate and create new instance of EventParam\nCreates a new configuration with default settings.\nComputes the number of this event’s indexed topics.\nIf set to <code>true</code>, any types part of some other …\nReturn a <code>TypeSpecifier</code> describing the other if this type …\nReturns an immutable reference to the outputs of the item.\nThe output types of the function. May be empty.\nReturns an immutable reference to the outputs of the item.\nParse a Human-Readable ABI string into a JSON object.\nParses a state mutability from a string.\nParses a Solidity constructor string: …\nParses a Solidity function signature string: …\nParses a Solidity event signature string: …\nParses a Solidity error signature string: …\nParses a single Human-Readable ABI string into an ABI item.\nParse a parameter from a Solidity parameter string.\nParse an event parameter from a Solidity parameter string.\nParse a string into an instance, taking ownership of data\nSets whether to print constructors. Default: <code>false</code>.\nThe receive function.\nComputes this error’s selector: …\nComputes this event’s selector: …\nComputes this error’s selector: …\nReturns the canonical type of this parameter.\nReturns the canonical type of this parameter.\nFormats the canonical type of this parameter into the …\nFormats the canonical type of this parameter into the …\nReturns this function’s signature: <code>$name($($inputs),*)</code>.\nReturns this event’s signature: <code>$name($($inputs),*)</code>.\nComputes this error’s signature: <code>$name($($inputs),*)</code>.\nReturns this function’s full signature: …\nReturns the state mutability of the item.\nThe state mutability of the constructor.\nThe state mutability of the fallback function.\nThe state mutability of the receive function.\nThe state mutability of the function.\nReturns a mutable reference to the state mutability of the …\nThe struct specifier is a <code>TypeSpecifier</code> containing the …\nThe struct specifier is a <code>TypeSpecifier</code> containing the …\nReturn a <code>TypeSpecifier</code> describing the struct if this type …\nFormats this JSON ABI as a Solidity interface.\nFormats this JSON ABI as a Solidity interface into the …\nThe UDT specifier is a <code>TypeSpecifier</code> containing the UDT …\nThe UDT specifier is a <code>TypeSpecifier</code> containing the UDT …\nContract qualifier, if any\nContract qualifier, if any\nContract qualifier, if any\nEnum name\nStruct name\nStruct name\n<code>calldata</code>\nContains the error value\nParser error.\nThe regular expression for a Solidity identifier.\n<code>memory</code>\nNonpayable functions promise not to receive Ether.\nContains the success value\nRepresents a function parameter.\nRepresents a list of function parameters.\nPayable functions make no promises.\nPure functions promise not to read from or modify the …\nParser result\nRoot type.\nA root type, with no array suffixes. Corresponds to a …\nA JSON ABI function’s state mutability.\nStorage specifier.\n<code>storage</code>\nTuple type.\nA tuple specifier, with no array suffixes. Corresponds to …\nRepresents a type-name. Consists of an identifier and …\nA stem of a Solidity array type. It is either a root type, …\nView functions promise not to modify the state.\nWhether the parameter indexed.\nInner input being wrapped in state\nReturns <code>true</code> if the given character is valid in a Solidity …\nReturns <code>true</code> if the given character is valid at the start …\nReturns <code>true</code> if the given string is a valid Solidity …\nThe name of the parameter.\nThe parameters.\n<code>serde</code> implementation for <code>StateMutability</code> for backwards …\nArray sizes, in innermost-to-outermost order. If the size …\nThe full span of the tuple specifier.\nThe full span of the specifier.\nThe full span of the specifier.\nThe full span of the specifier.\nUser-provided state\nThe type stem, which is either a root type or a tuple type.\nThe storage specifier.\nThe type of the parameter.\nThe internal types.\nDeserializes a <code>StateMutability</code>, compatible with older JSON …\nSerializes a <code>StateMutability</code> as a single-field struct (…\nAn Ethereum address, 20 bytes in length.\nStack-allocated buffer for efficiently computing address …\nError type for address checksum validation.\n16-byte fixed byte-array type.\n20-byte fixed byte-array type.\n32-byte fixed byte-array type.\n64-byte fixed byte-array type.\n8-byte fixed byte-array type.\nThe size of this integer type in bits.\nNumber of bits.\nNumber of bits to set per input in Ethereum bloom filter.\nSize of the bloom filter in bits\nSize of the bloom filter in bytes.\nThe size of this integer type in bytes. Note that some …\nThe size of this integer type in bytes. Note that some …\nThe error type that is returned when conversion to or from …\nA block hash.\nA block number.\nA block timestamp.\nEthereum 256 byte bloom filter.\nInput to the <code>Bloom::accrue</code> method.\nWrapper type around <code>bytes::Bytes</code> to support “0x” …\nA transaction that calls a contract or transfer.\nChain identifier type (introduced in EIP-155).\nA transaction that creates a contract.\nA byte array of fixed length (<code>[u8; N]</code>).\nError converting from bytes.\nError converting hex to bytes.\nAn Ethereum ABI function pointer, 24 bytes in length.\nAlready hashed input.\nError while decoding hex.\n128-bit signed integer type, consisting of 2, 64-bit limbs.\n16-bit signed integer type, consisting of 1, 64-bit limbs.\n160-bit signed integer type, consisting of 3, 64-bit limbs.\n256-bit signed integer type, consisting of 4, 64-bit limbs.\n32-bit signed integer type, consisting of 1, 64-bit limbs.\n64-bit signed integer type, consisting of 1, 64-bit limbs.\n8-bit signed integer type, consisting of 1, 64-bit limbs.\nError that occurs when the number is too large or too …\nTrait for an object that can be converted into a log data …\nInvalid ERC-55 checksum.\nInvalid parity.\nk256 error\nThe Keccak-256 hash of the empty string <code>&quot;&quot;</code>.\nSimple <code>Keccak-256</code> hasher.\nThe size of this integer type in 64-bit limbs.\nA log consists of an address, and some log data.\nAn Ethereum event log object.\nBit mask for the last limb.\nThe largest value that can be represented by this integer …\nThe maximum value.\nThe smallest value that can be represented by this integer …\nThe minimum value.\nMinus one (multiplicative inverse) of this type.\nLess than zero.\nThe value one. This is useful to have as a constant for …\nOne (multiplicative identity) of this type.\nThe error type that is returned when parsing a signed …\nGreater than or equal to zero.\nDeprecated alias for <code>Signature</code>.\nRaw input to be hashed.\nError that occurs when an invalid digit is encountered …\nSealeable objects.\nA consensus hashable item, with its memoized hash.\nSolidity contract functions are addressed using the first …\nEnum to represent the sign of a 256-bit signed integer.\nAn Ethereum ECDSA signature.\nErrors in signature parsing or verification.\nSigned integer wrapping a <code>ruint::Uint</code>.\nAn account storage key.\nAn account storage value.\nA transaction hash is a keccak hash of an RLP encoded …\nThe index of transaction in a block.\nThe <code>to</code> field of a transaction. Either a target address, or …\nThe nonce of a transaction.\nThe sequence number of all existing transactions.\n128-bit unsigned integer type, consisting of 2, 64-bit …\n16-bit unsigned integer type, consisting of 1, 64-bit …\n160-bit unsigned integer type, consisting of 3, 64-bit …\n256-bit unsigned integer type, consisting of 4, 64-bit …\n32-bit unsigned integer type, consisting of 1, 64-bit …\n512-bit unsigned integer type, consisting of 8, 64-bit …\n64-bit unsigned integer type, consisting of 1, 64-bit …\n8-bit unsigned integer type, consisting of 1, 64-bit limbs.\nThe ring of numbers modulo $2^{\\mathtt{BITS}}$.\nArray of Zero bytes.\nArray of Zero bytes.\nThe value zero. This is the only value that exists in all …\nArray of Zero bytes.\nArray of Zero bytes.\nZero (additive identity) of this type.\nComputes the absolute value of <code>self</code>.\nComputes the absolute difference between <code>self</code> and <code>other</code>.\nAccrues the input into the bloom filter.\nAccrues the input into the bloom filter.\nIngests a log into the bloom filter.\nIngests a raw log into the bloom filter.\nCompute $\\mod{\\mathtt{self} + \\mathtt{rhs}}_…\nThe address which emitted this log.\nConverts a sequence of string literals containing …\nType aliases for common primitive types.\nDouble precision logarithm.\nDouble precision decimal logarithm.\nDouble precision binary logarithm.\nConstruct from double precision binary logarithm.\nArithmetic shift right by <code>rhs</code> bits.\nReturns references to the address and selector of the …\nReturns the byte-array representation of this signature.\nReturns the sign character.\nReturns the ERC-2098 compact representation of this …\nConversion to i16 with overflow checking.\nConversion to i32 with overflow checking.\nConversion to i64 with overflow checking.\nConversion to i8 with overflow checking.\nConversion to isize with overflow checking.\nAccess the underlying store as a little-endian bytes.\nAccess the underlying store as a little-endian bytes with …\nAccess the underlying store as a little-endian slice of …\nAccess the underlying store as a mutable little-endian …\nView the array of limbs.\nView the array of limbs.\nAccess the array of limbs.\nReturns a mutable slice containing the entire array. …\nReturns the checksum of a formatted address.\nConverts from <code>&amp;Sealed&lt;T&gt;</code> to <code>Sealed&lt;&amp;T&gt;</code>.\nReturns a slice containing the entire array. Equivalent to …\nReturns the checksum of a formatted address.\nConversion to u16 with overflow checking.\nConversion to u32 with overflow checking.\nConversion to u64 with overflow checking.\nConversion to u8 with overflow checking.\nConversion to usize with overflow checking.\nArithmetic shift left operation. Computes <code>self &lt;&lt; rhs</code>, …\nArithmetic shift right operation. Computes <code>self &gt;&gt; rhs</code> …\nConverts a sequence of string literals containing …\nConverts a sequence of string literals containing …\nConverts a sequence of string literals containing …\nConverts a sequence of string literals containing …\nReturns whether a specific bit is set.\nReturns whether a specific bit is set.\nComputes the bitwise AND of two <code>FixedBytes</code>.\nComputes the bitwise AND of two <code>FixedBytes</code>.\nComputes the bitwise AND of two <code>FixedBytes</code>.\nComputes the bitwise AND of two <code>FixedBytes</code>.\nReturns the dynamic length of this number in bits, …\nComputes the bitwise OR of two <code>FixedBytes</code>.\nComputes the bitwise OR of two <code>FixedBytes</code>.\nComputes the bitwise OR of two <code>FixedBytes</code>.\nComputes the bitwise OR of two <code>FixedBytes</code>.\nComputes the bitwise XOR of two <code>FixedBytes</code>.\nComputes the bitwise XOR of two <code>FixedBytes</code>.\nComputes the bitwise XOR of two <code>FixedBytes</code>.\nComputes the bitwise XOR of two <code>FixedBytes</code>.\nReturns the bitwise <code>&amp;</code> of the two numbers.\nReturns the bitwise <code>|</code> of the two numbers.\nReturn the least number of bits needed to represent the …\nReturns the bitwise <code>^</code> of the two numbers.\nConverts a sequence of string literals containing …\nReturns a specific byte. The byte at index <code>0</code> is the least …\nReturns a specific byte. The byte at index <code>0</code> is the least …\nReturns the dynamic length of this number in bytes, …\nConverts a sequence of string literals containing …\nChecked absolute value. Computes <code>self.abs()</code>, returning <code>None</code>…\nComputes <code>self + rhs</code>, returning <code>None</code> if overflow occurred.\nChecked integer addition. Computes <code>self + rhs</code>, returning …\nReturns a specific byte, or <code>None</code> if <code>index</code> is out of range. …\nWrites the big-endian representation of the <code>Uint</code> to the …\nWrites the little-endian representation of the <code>Uint</code> to the …\nComputes <code>self / rhs</code>, returning <code>None</code> if <code>rhs == 0</code>.\nChecked integer division. Computes <code>self / rhs</code>, returning …\nChecked Euclidean division. Computes <code>self.div_euclid(rhs)</code>, …\nConstruct a new integer from little-endian a slice of …\nCreates a <code>Signed</code> from an absolute value and a negative …\nReturns the logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nComputes <code>self * rhs</code>, returning <code>None</code> if overflow occurred.\nChecked integer multiplication. Computes <code>self * rhs</code>, …\nComputes <code>-self</code>, returning <code>None</code> unless <code>self == 0</code>.\nChecked negation. Computes <code>-self</code>, returning <code>None</code> if …\nCalculates the smallest value greater than or equal to <code>self</code>…\nReturns the smallest power of two greater than or equal to …\nRaises self to the power of <code>exp</code>.\nChecked exponentiation. Computes <code>self.pow(exp)</code>, returning …\nComputes <code>self % rhs</code>, returning <code>None</code> if <code>rhs == 0</code>.\nChecked integer remainder. Computes <code>self % rhs</code>, returning …\nChecked Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>…\nChecked left shift by <code>rhs</code> bits.\nChecked shift left. Computes <code>self &lt;&lt; rhs</code>, returning <code>None</code> …\nChecked right shift by <code>rhs</code> bits.\nChecked shift right. Computes <code>self &gt;&gt; rhs</code>, returning <code>None</code> …\nComputes <code>self - rhs</code>, returning <code>None</code> if overflow occurred.\nChecked integer subtraction. Computes <code>self - rhs</code>, …\nClone the inner item.\nMaps a <code>Sealed&lt;&amp;T&gt;</code> to a <code>Sealed&lt;T&gt;</code> by cloning the inner …\nConcatenate two <code>FixedBytes</code>.\nCompile-time version of <code>contains</code>.\nReturns <code>true</code> if all bits set in <code>self</code> are also set in <code>b</code>.\nCompile-time equality. NOT constant-time equality.\nCompile-time equality. NOT constant-time equality.\nReturns <code>true</code> if <code>self</code> equals <code>other</code>.\nCompile-time equality. NOT constant-time equality.\nCompile-time equality. NOT constant-time equality.\nCompile-time equality. NOT constant-time equality.\nEquality at compile-time.\nReturns <code>true</code> if the value is zero.\nReturns <code>true</code> if no bits are set.\nReturns true if this bloom filter is a possible superset …\nReturns true if this bloom filter is a possible superset …\nTrue if the bloom filter contains a log with given address …\nTrue if the bloom filter contains a log with given address …\nWrites the big-endian representation of the <code>Uint</code> to the …\nCreates a new <code>Bytes</code> instance from a slice by copying it.\nWrites the little-endian representation of the <code>Uint</code> to the …\nReturns the number of ones in the binary representation of …\nReturns the number of ones in the binary representation of …\nReturns the number of zeros in the binary representation …\nReturns the number of zeros in the binary representation …\nReturns <code>true</code> if all bits set in <code>b</code> are also set in <code>self</code>.\nReturns <code>true</code> if all bits set in <code>b</code> are also set in <code>self</code>.\nReturns <code>true</code> if all bits set in <code>self</code> are also set in <code>b</code>.\nReturns <code>true</code> if all bits set in <code>b</code> are also set in <code>self</code>.\nComputes the <code>create</code> address for this address and nonce:\nComputes the <code>CREATE2</code> address of a smart contract as …\nComputes the <code>CREATE2</code> address of a smart contract as …\nComputes the address created by the <code>EOFCREATE</code> opcode, …\nReturns a reference to the underlying data.\nThe plain data.\nThe log data.\nReturns a mutable reference to the underlying data.\nDecode an RLP-encoded VRS signature. Accepts <code>decode_parity</code> …\nComputes <code>self / rhs</code> rounding up.\nCalculates the quotient of Euclidean division of <code>self</code> by …\nComputes <code>self / rhs</code> and <code>self % rhs</code>.\nHash a message according to EIP-191 (version <code>0x01</code>).\nCreates a new empty log.\nCreates a new empty log.\nCreate <code>10**n</code> as this type.\nPad and squeeze the state.\nPad and squeeze the state into <code>output</code>.\nPad and squeeze the state into <code>output</code>.\nPad and squeeze the state into <code>output</code>.\nConverts a sequence of string literals containing …\nCalculates the checksum of an address into the buffer.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstruct a new <code>Uint</code> from the value.\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nReturns the argument unchanged.\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nReturns the argument unchanged.\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nConverts a fixed-width unsigned integer into a fixed byte …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a <code>TxKind::Call</code> with the given address.\nCreates a <code>TxKind::Call</code> with the <code>Some</code> address, <code>None</code> …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nConstruct a new <code>Signed</code> from the value.\nReturns the argument unchanged.\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nConverts a fixed byte array into a fixed-width unsigned …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates an Ethereum function from an address and selector.\nConstructs the <code>Uint</code> from digits in the base <code>base</code> in …\nConstructs the <code>Signed</code> from digits in the base <code>base</code> in …\nConstructs the <code>Uint</code> from digits in the base <code>base</code> in …\nConverts a big-endian byte array of size exactly …\nConverts a big-endian byte array of size exactly …\nCreates a new integer from a big endian slice of bytes.\nParses a signature from a byte slice, with a v value\nConvert from a decimal string.\nDecode the signature from the ERC-2098 compact …\nConvert from a hex string.\nConverts a little-endian byte array of size exactly …\nConvert from an array in LE format\nCreates a new integer from a little endian slice of bytes.\nConstruct a new integer from little-endian a array of …\nConstruct a new integer from little-endian a array of …\nConstruct a new integer from little-endian a slice of …\nConverts an ECDSA signing key to its corresponding …\nConverts an ECDSA verifying key to its corresponding …\nCoerces an unsigned integer into a signed one. If the …\nParses a 65-byte long raw signature.\nParses a 65-byte long raw signature.\nInstantiate by hashing public key bytes.\nCreates a <code>Signature</code> from the serialized <code>r</code> and <code>s</code> scalar …\nInstantiate from a signature and recovery id\nCreate a new byte array from the given slice <code>src</code>.\nCreate a new byte array from the given slice <code>src</code>.\nCreate a new <code>FixedBytes</code> from the given slice <code>src</code>.\nCreate a new byte array from the given slice <code>src</code>.\nCreates a new <code>Bytes</code> from a static slice.\nParse a string into a <code>Uint</code>.\nCreates an Ethereum address from an EVM word’s upper 20 …\nCreates an Ethereum function from an EVM word’s lower 24 …\nCompute the greatest common divisor of two <code>Uint</code>s.\n⚠️ Compute the greatest common divisor and the Bézout …\nGet the hash.\nGet the hash.\nCalculate the seal hash, this may be slow.\nMacro for converting sequence of string literals …\nGet the inner item.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the inner bytes array.\nReturns the inner bytes array.\nReturns the inner bytes array.\nConsume the input, converting it to the hash.\nReturns the backing buffer.\nUnseal the inner item, discarding the hash.\nReturns the inner ECDSA signature.\nConvert to a array of limbs.\nConvert to a array of limbs.\nConsume and convert into a <code>LogData</code> object.\nDecompose into parts.\nReturns the signed integer as a unsigned integer. If the …\nSplits a Signed into its absolute value and negative flag.\nConsumes the type and returns the address of the contract …\nLeft-pads the address to 32 bytes (EVM word size).\nRight-pads the function to 32 bytes (EVM word size).\nCompute $\\mod{\\mathtt{self}^{-1}}_{\\mathtt{modulus}}$.\nComputes the inverse modulo $2^{\\mathtt{BITS}}$ of <code>self</code>, …\nReturns true if the transaction is a contract call.\nReturns true if the transaction is a contract creation.\nReturns <code>true</code> if <code>self</code> is negative and <code>false</code> if the number …\nReturns whether the sign is negative.\nDetermines if the integer is odd.\nReturns <code>true</code> if <code>self</code> is positive and <code>false</code> if the number …\nReturns whether the sign is positive.\nReturns <code>true</code> if and only if <code>self == 2^k</code> for some <code>k</code>.\nTrue if valid, false otherwise.\nReturns <code>true</code> if the value is zero.\nReturns <code>true</code> if no bits are set.\nReturns <code>true</code> if <code>self</code> is zero and <code>false</code> if the number is …\nSimple interface to the <code>Keccak-256</code> hash function.\nCompute the least common multiple of two <code>Uint</code>s or <code>None</code> if …\nReturns the number of leading ones in the binary …\nReturns the number of leading zeros in the binary …\nReturns the number of leading zeros in the binary …\nCreate a new byte array from the given slice <code>src</code>, …\nCreate a new byte array from the given slice <code>src</code>, …\nCreate a new <code>FixedBytes</code> from the given slice <code>src</code>, …\nCreate a new byte array from the given slice <code>src</code>, …\nReturns the size of this array in bytes.\nReturns the size of this array in bytes.\nReturns the size of this byte array (<code>N</code>).\nReturns the size of this array in bytes.\nReturns the logarithm of the number, rounded down.\nReturns the base 10 logarithm of the number, rounded down.\nReturns the base 2 logarithm of the number, rounded down.\nCompute the logs bloom filter for the given logs.\nLow word.\nLow word.\nLow word.\nLow word.\nLow word.\nLow word.\nLow word.\nLow word.\nLow word.\nLow word.\nSpecialised Bloom filter that sets three bits out of 2048, …\n<code>m3_2048</code> but with a pre-hashed input.\nRe-exports of map types and utilities.\nReturns the most significant 64 bits of the number and the …\nCompute $\\mod{\\mathtt{self} ⋅ \\mathtt{rhs}}_…\nMontgomery multiplication.\nWraps the given byte array in this type.\nCreates a new buffer.\nWraps the given byte array in this type.\nWraps the given byte array in <code>FixedBytes</code>.\nWraps the given byte array in this type.\nCreates a new empty <code>Bytes</code>.\nCreates a new log.\nCreates a new log.\nSeal the inner item.\nInstantiate a new signature from <code>r</code>, <code>s</code>, and <code>v</code> values.\nCreates a new <code>Keccak256</code> hasher.\nCreates a new log from an deserialized event.\nCreates a new log.\nSeal the inner item, by reference.\nSeal a reference to the inner item with some function.\nCreates a new log, without length-checking. This allows …\nCreates a new log.\nInstantiate without performing the hash. This should be …\nSeal the inner item with some function.\nCalculates the smallest value greater than or equal to …\nReturns the smallest power of two greater than or equal to …\nNormalizes the signature into “low S” form as …\nAttempts to normalize the v value to a boolean parity …\nNormalizes the signature into “low S” form as …\nInverts all the bits in the integer.\nComputes the absolute value of <code>self</code>.\nCalculates $\\mod{\\mathtt{self} + \\mathtt{rhs}}_{2^{BITS}}$.\nCalculates <code>self</code> + <code>rhs</code>\nCalculates <code>self</code> / <code>rhs</code>\nCalculates the quotient of Euclidean division …\nConstruct a new <code>Uint</code> from a little-endian slice of limbs. …\nCreates a <code>Signed</code> from a sign and an absolute value. …\nCalculates the multiplication of self and rhs.\nCalculates <code>self</code> * <code>rhs</code>\nCalculates $\\mod{-\\mathtt{self}}_{2^{BITS}}$.\nNegates self, overflowing if this is equal to the minimum …\nRaises self to the power of <code>exp</code> and if the result would …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nCalculates <code>self</code> % <code>rhs</code>\nOverflowing Euclidean remainder. Calculates …\nLeft shift by <code>rhs</code> bits with overflow detection.\nShifts self left by <code>rhs</code> bits.\nRight shift by <code>rhs</code> bits with underflow detection.\nShifts self right by <code>rhs</code> bits.\nCalculates $\\mod{\\mathtt{self} - \\mathtt{rhs}}_{2^{BITS}}$.\nCalculates <code>self</code> - <code>rhs</code>\nParse an Ethereum address, verifying its EIP-55 checksum.\nRaises self to the power of <code>exp</code>, wrapping around on …\nRaises self to the power of <code>exp</code>, using exponentiation by …\nCompute $\\mod{\\mathtt{self}^{\\mathtt{rhs}}}_…\nReturns the <code>r</code> component of this signature.\nReturns the recovery ID.\nRecovers an <code>Address</code> from this signature and the given …\nRecovers an <code>Address</code> from this signature and the given …\nRecovers a <code>VerifyingKey</code> from this signature and the given …\nRecovers a <code>VerifyingKey</code> from this signature and the given …\n⚠️ Compute $\\mod{\\mathtt{self}}_{\\mathtt{modulus}}$.\nCalculates the least nonnegative remainder of …\nCreates a new byte array where all bytes are set to <code>byte</code>.\nCreates a new byte array where all bytes are set to <code>byte</code>.\nCreates a new <code>FixedBytes</code> where all bytes are set to <code>byte</code>.\nCreates a new byte array where all bytes are set to <code>byte</code>.\nReserialize the data.\nReverses the order of bits in the integer. The least …\nCreate a new byte array from the given slice <code>src</code>, …\nCreate a new byte array from the given slice <code>src</code>, …\nCreate a new <code>FixedBytes</code> from the given slice <code>src</code>, …\nCreate a new byte array from the given slice <code>src</code>, …\nLength of RLP RS field encoding\nComputes the floor of the <code>degree</code>-th root of the number.\nShifts the bits to the left by a specified amount, <code>rhs</code>, …\nShifts the bits to the right by a specified amount, <code>rhs</code>, …\nReturns the <code>s</code> component of this signature.\nSaturating absolute value. Computes <code>self.abs()</code>, returning …\nComputes <code>self + rhs</code>, saturating at the numeric bounds …\nSaturating integer addition. Computes <code>self + rhs</code>, …\nSaturating integer division. Computes <code>self / rhs</code>, …\nConstruct a new <code>Uint</code> from the value saturating the value …\nConstruct a new <code>Uint</code> from a little-endian slice of limbs. …\nComputes <code>self * rhs</code>, saturating at the numeric bounds …\nSaturating integer multiplication. Computes <code>self * rhs</code>, …\nSaturating negation. Computes <code>-self</code>, returning <code>MAX</code> if …\nRaises self to the power of <code>exp</code>, saturating on overflow.\nSaturating integer exponentiation. Computes <code>self.pow(exp)</code>, …\nSaturating left shift by <code>rhs</code> bits.\nComputes <code>self - rhs</code>, saturating at the numeric bounds …\nSaturating integer subtraction. Computes <code>self - rhs</code>, …\nExamples\nGet the hash.\nSeal a borrowed object by calculating the hash. This may …\nInstantiate an unchecked seal. This should be used with …\nSeal the object by calculating the hash. This may be slow.\nInstantiate an unchecked seal. This should be used with …\nSets a specific bit to a value.\nSet the topic list, truncating to 4 topics.\nSet the topic list, without length-checking. This allows …\nReturns the sign of self.\nCalculates a heuristic for the in-memory size of this …\nReturns a slice of self for the provided range.\nReturns a slice of self that is equivalent to the given …\nConsumes the log data, returning the topic list and the …\nDecompose into parts. Alias for <code>Self::into_parts</code>.\nSplits the bytes into two at the given index.\nSplits the bytes into two at the given index.\nMontgomery squaring.\nPanics\nReturns the address of the contract that will be called or …\nPanics\nReturns the address and selector of the function.\nReturns an iterator over the base <code>base</code> digits of the …\nReturns an iterator over the base <code>base</code> digits of the …\nReturns an iterator over the base <code>base</code> digits of the …\nConverts the <code>Uint</code> to a big-endian byte array of size …\nConverts <code>self</code> to a big-endian byte array of size exactly …\nConverts the <code>Uint</code> to a big-endian byte vector with leading …\nConverts the <code>Uint</code> to a big-endian byte vector of size …\nEncodes an Ethereum address to its EIP-55 checksum into a …\nEncodes an Ethereum address to its EIP-55 checksum into a …\nEncodes an Ethereum address to its EIP-55 checksum into …\nConvert to a decimal string.\nApplies EIP-155.\nConvert to a hex string.\nReturns the inner ECDSA signature.\nConverts the <code>Uint</code> to a little-endian byte array of size …\nConverts <code>self</code> to a little-endian byte array of size exactly\nConverts the <code>Uint</code> to a little-endian byte vector with …\nConverts the <code>Uint</code> to a little-endian byte vector of size …\nConvert into a <code>LogData</code> object.\nReturns the checksum of a formatted address.\nGet the topic list.\nGet the topic list, mutably. This gives access to the …\nGet a mutable reference to the topic list. This allows …\nReturns the number of trailing ones in the binary …\nReturns the number of leading ones in the binary …\nReturns the number of trailing zeros in the binary …\nReturns the number of leading zeros in the binary …\nParses a 65-byte long raw signature.\nCreates a new integer from a big endian slice of bytes.\nCreates a new integer from a big endian slice of bytes.\nCreates a new integer from a little endian slice of bytes.\nCreates a new integer from a little endian slice of bytes.\nTries to create a <code>Vec</code> containing the arguments.\nCompute the two’s complement of this number.\nShortcut for <code>val.try_into().unwrap()</code>.\nShortcut for <code>self.try_into().unwrap()</code>.\nUnseal the inner item, discarding the hash. Alias for …\nComputes the absolute value of <code>self</code> without any wrapping …\nAbsorbs additional input. Can be called multiple times.\nCommon Ethereum utilities.\nReturns the recovery ID as a <code>bool</code>.\nCalculates the complete product <code>self * rhs</code> without the …\nCreates a new byte array with the last byte set to <code>x</code>.\nCreates a new byte array with the last byte set to <code>x</code>.\nCreates a new <code>FixedBytes</code> with the last byte set to <code>x</code>.\nCreates a new byte array with the last byte set to <code>x</code>.\nSets the recovery ID by normalizing a <code>v</code> value.\nWrap a fixed-size byte array in a newtype, delegating all …\nWrapping absolute value. Computes <code>self.abs()</code>, wrapping …\nComputes <code>self + rhs</code>, wrapping around at the boundary of …\nWrapping (modular) addition. Computes <code>self + rhs</code>, wrapping …\nComputes <code>self / rhs</code> rounding down.\nWrapping (modular) division. Computes <code>self / rhs</code>, wrapping …\nWrapping Euclidean division. Computes <code>self.div_euclid(rhs)</code>,\nConstruct a new <code>Uint</code> from the value saturating the value …\nConstruct a new <code>Uint</code> from a little-endian slice of limbs. …\nComputes <code>self * rhs</code>, wrapping around at the boundary of …\nWrapping (modular) multiplication. Computes <code>self * rhs</code>, …\nComputes <code>-self</code>, wrapping around at the boundary of the …\nWrapping (modular) negation. Computes <code>-self</code>, wrapping …\nRaises self to the power of <code>exp</code>, wrapping around on …\nRaises self to the power of <code>exp</code>, wrapping around at the …\nComputes <code>self % rhs</code>.\nWrapping (modular) remainder. Computes <code>self % rhs</code>, …\nWrapping Euclidean remainder. Computes <code>self.rem_euclid(rhs)</code>…\nLeft shift by <code>rhs</code> bits.\nWrapping shift left. Computes <code>self &lt;&lt; rhs</code>, returning 0 if …\nRight shift by <code>rhs</code> bits.\nWrapping shift right. Computes <code>self &gt;&gt; rhs</code>, returning 0 if …\nComputes <code>self - rhs</code>, wrapping around at the boundary of …\nWrapping (modular) subtraction. Computes <code>self - rhs</code>, …\nExamples\nWrite R and S to an RLP buffer in progress.\nWrite the VRS to the output.\n128-byte fixed byte-array type.\n16-byte fixed byte-array type.\n2-byte fixed byte-array type.\n24-byte fixed byte-array type.\n256-byte fixed byte-array type.\n28-byte fixed byte-array type.\n32-byte fixed byte-array type.\n4-byte fixed byte-array type.\n64-byte fixed byte-array type.\n8-byte fixed byte-array type.\n1-byte fixed byte-array type.\n12-byte fixed byte-array type.\nA block hash.\nA block number.\nA block timestamp.\nChain identifier type (introduced in EIP-155).\nThe 0-bit signed integer type, capable of representing 0.\nThe 1-bit signed integer type, capable of representing 0 …\n104-bit signed integer type, consisting of 2, 64-bit limbs.\n112-bit signed integer type, consisting of 2, 64-bit limbs.\n120-bit signed integer type, consisting of 2, 64-bit limbs.\n128-bit signed integer type, consisting of 2, 64-bit limbs.\n136-bit signed integer type, consisting of 3, 64-bit limbs.\n144-bit signed integer type, consisting of 3, 64-bit limbs.\n152-bit signed integer type, consisting of 3, 64-bit limbs.\n16-bit signed integer type, consisting of 1, 64-bit limbs.\n160-bit signed integer type, consisting of 3, 64-bit limbs.\n168-bit signed integer type, consisting of 3, 64-bit limbs.\n176-bit signed integer type, consisting of 3, 64-bit limbs.\n184-bit signed integer type, consisting of 3, 64-bit limbs.\n192-bit signed integer type, consisting of 3, 64-bit limbs.\n200-bit signed integer type, consisting of 4, 64-bit limbs.\n208-bit signed integer type, consisting of 4, 64-bit limbs.\n216-bit signed integer type, consisting of 4, 64-bit limbs.\n224-bit signed integer type, consisting of 4, 64-bit limbs.\n232-bit signed integer type, consisting of 4, 64-bit limbs.\n24-bit signed integer type, consisting of 1, 64-bit limbs.\n240-bit signed integer type, consisting of 4, 64-bit limbs.\n248-bit signed integer type, consisting of 4, 64-bit limbs.\n256-bit signed integer type, consisting of 4, 64-bit limbs.\n32-bit signed integer type, consisting of 1, 64-bit limbs.\n40-bit signed integer type, consisting of 1, 64-bit limbs.\n48-bit signed integer type, consisting of 1, 64-bit limbs.\n512-bit signed integer type, consisting of 8, 64-bit limbs.\n56-bit signed integer type, consisting of 1, 64-bit limbs.\n64-bit signed integer type, consisting of 1, 64-bit limbs.\n72-bit signed integer type, consisting of 2, 64-bit limbs.\n8-bit signed integer type, consisting of 1, 64-bit limbs.\n80-bit signed integer type, consisting of 2, 64-bit limbs.\n88-bit signed integer type, consisting of 2, 64-bit limbs.\n96-bit signed integer type, consisting of 2, 64-bit limbs.\nSolidity contract functions are addressed using the first …\nAn account storage key.\nAn account storage value.\nA transaction hash is a keccak hash of an RLP encoded …\nThe index of transaction in a block.\nThe nonce of a transaction.\nThe sequence number of all existing transactions.\n<code>Uint</code> for <code>0</code> bits. Always zero. Similar to <code>()</code>.\n<code>Uint</code> for <code>1</code> bit. Similar to <code>bool</code>.\n<code>Uint</code> for <code>1024</code> bits.\n104-bit unsigned integer type, consisting of 2, 64-bit …\n112-bit unsigned integer type, consisting of 2, 64-bit …\n120-bit unsigned integer type, consisting of 2, 64-bit …\n128-bit unsigned integer type, consisting of 2, 64-bit …\n136-bit unsigned integer type, consisting of 3, 64-bit …\n144-bit unsigned integer type, consisting of 3, 64-bit …\n152-bit unsigned integer type, consisting of 3, 64-bit …\n16-bit unsigned integer type, consisting of 1, 64-bit …\n160-bit unsigned integer type, consisting of 3, 64-bit …\n168-bit unsigned integer type, consisting of 3, 64-bit …\n176-bit unsigned integer type, consisting of 3, 64-bit …\n184-bit unsigned integer type, consisting of 3, 64-bit …\n192-bit unsigned integer type, consisting of 3, 64-bit …\n200-bit unsigned integer type, consisting of 4, 64-bit …\n<code>Uint</code> for <code>2048</code> bits.\n208-bit unsigned integer type, consisting of 4, 64-bit …\n216-bit unsigned integer type, consisting of 4, 64-bit …\n224-bit unsigned integer type, consisting of 4, 64-bit …\n232-bit unsigned integer type, consisting of 4, 64-bit …\n24-bit unsigned integer type, consisting of 1, 64-bit …\n240-bit unsigned integer type, consisting of 4, 64-bit …\n248-bit unsigned integer type, consisting of 4, 64-bit …\n256-bit unsigned integer type, consisting of 4, 64-bit …\n32-bit unsigned integer type, consisting of 1, 64-bit …\n<code>Uint</code> for <code>320</code> bits.\n<code>Uint</code> for <code>384</code> bits.\n40-bit unsigned integer type, consisting of 1, 64-bit …\n<code>Uint</code> for <code>4096</code> bits.\n<code>Uint</code> for <code>448</code> bits.\n48-bit unsigned integer type, consisting of 1, 64-bit …\n512-bit unsigned integer type, consisting of 8, 64-bit …\n56-bit unsigned integer type, consisting of 1, 64-bit …\n64-bit unsigned integer type, consisting of 1, 64-bit …\n72-bit unsigned integer type, consisting of 2, 64-bit …\n8-bit unsigned integer type, consisting of 1, 64-bit limbs.\n80-bit unsigned integer type, consisting of 2, 64-bit …\n88-bit unsigned integer type, consisting of 2, 64-bit …\n96-bit unsigned integer type, consisting of 2, 64-bit …\n<code>HashMap</code> optimized for hashing <code>Address</code>.\n<code>HashSet</code> optimized for hashing <code>Address</code>.\n<code>HashMap</code> optimized for hashing <code>B256</code>.\n<code>HashSet</code> optimized for hashing <code>B256</code>.\nThe default <code>BuildHasher</code> used by <code>HashMap</code> and <code>HashSet</code>.\nThe default <code>Hasher</code> used by <code>HashMap</code> and <code>HashSet</code>.\nA view into a single entry in a map, which may either be …\n<code>BuildHasher</code> optimized for hashing fixed-size byte arrays.\n<code>Hasher</code> optimized for hashing fixed-size byte arrays.\n<code>HashMap</code> optimized for hashing fixed-size byte arrays.\n<code>HashSet</code> optimized for hashing fixed-size byte arrays.\nA <code>HashMap</code> using the default hasher.\nA <code>HashSet</code> using the default hasher.\nAn occupied entry.\n<code>HashMap</code> optimized for hashing <code>Selector</code>.\n<code>HashSet</code> optimized for hashing <code>Selector</code>.\nA vacant entry.\nProvides in-place mutable access to an occupied entry …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nA hash map implemented with quadratic probing and SIMD …\nA hash set implemented as a <code>HashMap</code> where the value is <code>()</code>.\nSets the value of the entry, and returns an <code>OccupiedEntry</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns a reference to this entry’s key.\nEnsures a value is in the entry by inserting the default …\nEnsures a value is in the entry by inserting the default …\nEnsures a value is in the entry by inserting the result of …\nEnsures a value is in the entry by inserting, if empty, …\nThe default <code>Hasher</code> used by <code>RandomState</code>.\nA draining iterator over the entries of a <code>HashMap</code>.\nA view into a single entry in a map, which may either be …\nA draining, filtering iterator over the entries of a …\nA hash map implemented with quadratic probing and SIMD …\nAn owning iterator over the entries of a <code>HashMap</code>.\nAn owning iterator over the keys of a <code>HashMap</code>.\nAn owning iterator over the values of a <code>HashMap</code>.\nAn iterator over the entries of a <code>HashMap</code>.\nA mutable iterator over the entries of a <code>HashMap</code>.\nAn iterator over the keys of a <code>HashMap</code>.\nAn occupied entry.\nAn occupied entry.\nA view into an occupied entry in a <code>HashMap</code>. It is part of …\nThe error returned by <code>try_insert</code> when the key already …\n<code>RandomState</code> is the default state for <code>HashMap</code> types.\nA builder for computing where in a HashMap a key-value …\nA builder for computing where in a HashMap a key-value …\nA view into a single entry in a map, which may either be …\nA view into an occupied entry in a <code>HashMap</code>. It is part of …\nA view into a vacant entry in a <code>HashMap</code>. It is part of the …\nA vacant entry.\nA vacant entry.\nA view into a vacant entry in a <code>HashMap</code>. It is part of the …\nAn iterator over the values of a <code>HashMap</code>.\nA mutable iterator over the values of a <code>HashMap</code>.\nProvides in-place mutable access to an occupied entry …\nReturns the number of elements the map can hold without …\nClears the map, removing all key-value pairs. Keeps the …\nReturns <code>true</code> if the map contains a value for the specified …\nCreates an empty <code>HashMap&lt;K, V, S&gt;</code>, with the <code>Default</code> value …\nConstructs a new <code>RandomState</code>.\nCreates a new <code>DefaultHasher</code> using <code>new</code>. See its …\nClears the map, returning all key-value pairs as an …\nGets the given key’s corresponding entry in the map for …\nThe entry in the map that was already occupied.\nCreates an iterator which uses a closure to determine if …\nConverts a <code>[(K, V); N]</code> into a <code>HashMap&lt;K, V&gt;</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a <code>RawEntryMut</code> from the given hash.\nAccess an entry by hash.\nConstructs a <code>HashMap&lt;K, V&gt;</code> from an iterator of key-value …\nCreates a <code>RawEntryMut</code> from the given key.\nAccess an entry by key.\nCreates a <code>RawEntryMut</code> from the given key and its hash.\nAccess an entry by a key and its hash.\nReturns a reference to the value corresponding to the key.\nGets a reference to the value in the entry.\nGets a reference to the value in the entry.\nAttempts to get mutable references to <code>N</code> values in the map …\nAttempts to get mutable references to <code>N</code> values in the map …\nReturns the key-value pair corresponding to the supplied …\nGets a reference to the key and value in the entry.\nGets a mutable reference to the key and value in the entry.\nReturns a mutable reference to the value corresponding to …\nGets a mutable reference to the value in the entry.\nGets a mutable reference to the value in the entry.\nReturns a reference to the map’s <code>BuildHasher</code>.\nReturns a reference to the value corresponding to the …\nInserts a key-value pair into the map.\nSets the value of the entry, and returns the entry’s old …\nSets the value of the entry with the <code>VacantEntry</code>’s key, …\nSets the value of the entry, and returns the entry’s old …\nSets the value of the entry with the <code>VacantEntry</code>’s key, …\nSets the value of the entry with the <code>VacantEntry</code>’s key, …\nSets the value of the entry with the VacantEntry’s key, …\nSets the value of the entry, and returns the entry’s old …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a consuming iterator, that is, one that moves each …\nConverts the entry into a mutable reference to the key in …\nTake ownership of the key.\nConverts the <code>OccupiedEntry</code> into a mutable reference to the …\nCreates a consuming iterator visiting all the keys in …\nConverts the <code>OccupiedEntry</code> into a mutable reference to the …\nConverts the <code>OccupiedEntry</code> into a mutable reference to the …\nCreates a consuming iterator visiting all the values in …\nReturns <code>true</code> if the map contains no elements.\nAn iterator visiting all key-value pairs in arbitrary …\nAn iterator visiting all key-value pairs in arbitrary …\nGets a reference to the key in the entry.\nGets a reference to the key in the entry.\nGets a reference to the key that would be used when …\nGets a mutable reference to the key in the entry.\nAn iterator visiting all keys in arbitrary order. The …\nReturns the number of elements in the map.\nCreates an empty <code>HashMap</code>.\nConstructs a new <code>RandomState</code> that is initialized with …\nCreates a new <code>DefaultHasher</code>.\nEnsures a value is in the entry by inserting the default …\nEnsures a value is in the entry by inserting the result of …\nCreates a raw immutable entry builder for the <code>HashMap</code>.\nCreates a raw entry builder for the <code>HashMap</code>.\nRemoves a key from the map, returning the value at the key …\nTakes the value out of the entry, and returns it.\nTakes the value out of the entry, and returns it.\nRemoves a key from the map, returning the stored key and …\nTake the ownership of the key and value from the map.\nTake the ownership of the key and value from the map.\nReserves capacity for at least <code>additional</code> more elements to …\nRetains only the elements specified by the predicate.\nShrinks the capacity of the map with a lower limit. It …\nShrinks the capacity of the map as much as possible. It …\nTries to insert a key-value pair into the map, and returns …\nTries to reserve capacity for at least <code>additional</code> more …\nThe value which was not inserted, because the entry was …\nAn iterator visiting all values in arbitrary order. The …\nAn iterator visiting all values mutably in arbitrary order.\nCreates an empty <code>HashMap</code> with at least the specified …\nCreates an empty <code>HashMap</code> with at least the specified …\nCreates an empty <code>HashMap</code> which will use the given hash …\nA lazy iterator producing elements in the difference of …\nA draining iterator over the items of a <code>HashSet</code>.\nA view into a single entry in a set, which may either be …\nA draining, filtering iterator over the items of a <code>HashSet</code>.\nA hash set implemented as a <code>HashMap</code> where the value is <code>()</code>.\nA lazy iterator producing elements in the intersection of …\nAn owning iterator over the items of a <code>HashSet</code>.\nAn iterator over the items of a <code>HashSet</code>.\nAn occupied entry.\nA view into an occupied entry in a <code>HashSet</code>. It is part of …\nA lazy iterator producing elements in the symmetric …\nA lazy iterator producing elements in the union of <code>HashSet</code>…\nA vacant entry.\nA view into a vacant entry in a <code>HashSet</code>. It is part of the …\nReturns the intersection of <code>self</code> and <code>rhs</code> as a new …\nReturns the union of <code>self</code> and <code>rhs</code> as a new <code>HashSet&lt;T, S&gt;</code>.\nReturns the symmetric difference of <code>self</code> and <code>rhs</code> as a new …\nReturns the number of elements the set can hold without …\nClears the set, removing all values.\nOverwrites the contents of <code>self</code> with a clone of the …\nReturns <code>true</code> if the set contains a value.\nCreates an empty <code>HashSet&lt;T, S&gt;</code> with the <code>Default</code> value for …\nVisits the values representing the difference, i.e., the …\nClears the set, returning all elements as an iterator. …\nGets the given value’s corresponding entry in the set …\nCreates an iterator which uses a closure to determine if a …\nConverts a <code>[T; N]</code> into a <code>HashSet&lt;T&gt;</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns a reference to the value in the set, if any, that …\nReturns a reference to this entry’s value.\nGets a reference to the value in the entry.\nGets a reference to the value that would be used when …\nInserts the given <code>value</code> into the set if it is not present, …\nInserts a value computed from <code>f</code> into the set if the given …\nReturns a reference to the set’s <code>BuildHasher</code>.\nAdds a value to the set.\nSets the value of the entry, and returns an OccupiedEntry.\nSets the value of the entry with the VacantEntry’s value.\nVisits the values representing the intersection, i.e., the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a consuming iterator, that is, one that moves each …\nTake ownership of the value.\nReturns <code>true</code> if <code>self</code> has no elements in common with <code>other</code>. …\nReturns <code>true</code> if the set contains no elements.\nReturns <code>true</code> if the set is a subset of another, i.e., <code>other</code>…\nReturns <code>true</code> if the set is a superset of another, i.e., …\nAn iterator visiting all elements in arbitrary order. The …\nReturns the number of elements in the set.\nCreates an empty <code>HashSet</code>.\nEnsures a value is in the entry by inserting if it was …\nRemoves a value from the set. Returns whether the value was\nTakes the value out of the entry, and returns it. Keeps …\nAdds a value to the set, replacing the existing value, if …\nReserves capacity for at least <code>additional</code> more elements to …\nRetains only the elements specified by the predicate.\nShrinks the capacity of the set with a lower limit. It …\nShrinks the capacity of the set as much as possible. It …\nReturns the difference of <code>self</code> and <code>rhs</code> as a new …\nVisits the values representing the symmetric difference, …\nRemoves and returns the value in the set, if any, that is …\nTries to reserve capacity for at least <code>additional</code> more …\nVisits the values representing the union, i.e., all the …\nCreates an empty <code>HashSet</code> with at least the specified …\nCreates an empty <code>HashSet</code> with at least the specified …\nCreates a new empty hash set which will use the given …\nThe size of this integer type in bits.\nThe size of this integer type in bits.\nError for <code>from_base_le</code> and <code>from_base_be</code>.\nError from <code>Uint::from_base_be</code>.\nA newtype wrapper around <code>Uint</code> that restricts operations to …\nError for <code>TryFrom&lt;Uint&gt;</code>.\nThe requested number base <code>.0</code> is less than two.\nThe provided digit <code>.0</code> is out of range for requested base <code>.1</code>…\nInvalid digit in string.\nInvalid radix, up to base 64 is supported.\nThe size of this integer type in 64-bit limbs.\n‘Not a number’ (NaN) can not be represented as Uint\nNumber is equal or larger than the target field modulus.\nThe value is too large to fit the target type.\nThe Uint value is too large for the target type.\nError for <code>from_str_radix</code>.\nError for <code>TryFrom&lt;Uint&gt;</code> for <code>ark_ff</code> and others.\nError for <code>TryFrom&lt;T&gt;</code> for <code>Uint</code>.\nThe ring of numbers modulo $2^{\\mathtt{BITS}}$.\n⚠️ Workaround for Rust issue #50133. Use <code>TryFrom</code> …\n⚠️ Workaround for Rust issue #50133. Use <code>TryFrom</code> …\nNegative values can not be represented as Uint.\nValue is too large to fit the Uint.\nThe value zero. This is the only value that exists in all …\n⚠️ Collection of bignum algorithms.\nType aliases for common bit sizes of <code>Uint</code> and <code>Bits</code>.\nSee <code>Uint::as_le_bytes</code> for documentation.\nSee <code>Uint::as_limbs</code> for documentation.\nSee <code>Uint::as_limbs_mut</code> for documentation.\nReturns a reference to the inner Uint.\nReturns a mutable reference to the inner Uint.\nSee <code>Uint::checked_shl</code> for documentation.\nSee <code>Uint::checked_shr</code> for documentation.\nCompile time for loops with a <code>const</code> variable for testing.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nSee <code>Uint::from_be_bytes</code> for documentation.\nSee <code>Uint::from_le_bytes</code> for documentation.\nSee <code>Uint::from_limbs</code> for documentation.\nSee <code>Uint::from_str_radix</code> for documentation.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the inner Uint.\nSee <code>Uint::leading_ones</code> for documentation.\nSee <code>Uint::leading_zeros</code> for documentation.\nMask to apply to the highest limb to get the correct …\nNumber of bytes required to represent the given number of …\nNumber of <code>u64</code> limbs required to represent the given number …\nSee <code>Uint::overflowing_shl</code> for documentation.\nSee <code>Uint::overflowing_shr</code> for documentation.\nSee <code>Uint::reverse_bits</code> for documentation.\nSee <code>Uint::rotate_left</code> for documentation.\nSee <code>Uint::rotate_right</code> for documentation.\nSupport for external crates.\nSee <code>Uint::to_be_bytes</code> for documentation.\nSee <code>Uint::to_be_bytes_vec</code> for documentation.\nSee <code>Uint::to_le_bytes</code> for documentation.\nSee <code>Uint::trailing_ones</code> for documentation.\nSee <code>Uint::trailing_zeros</code> for documentation.\nSee <code>Uint::try_from_be_slice</code> for documentation.\nSee <code>Uint::try_from_le_slice</code> for documentation.\nSee <code>Uint::wrapping_shl</code> for documentation.\nSee <code>Uint::wrapping_shr</code> for documentation.\n⚠️ Lehmer update matrix\n⚠️ Computes <code>lhs += a</code> and returns the carry.\n⚠️ Computes <code>result += a * b</code> and checks for overflow.\n⚠️ Computes wrapping <code>result += a * b</code>, with a fast-path …\n⚠️ Computes <code>lhs += a * b</code> and returns the carry.\n⚠️ Applies the matrix to a <code>Uint</code>.\n⚠️ Applies the matrix to a <code>u128</code>.\n⚠️ Sub with borrow.\n⚠️ <code>lhs -= rhs - borrow</code>\n⚠️ Add with carry.\n⚠️ <code>lhs += rhs + carry</code>\n⚠️ Compare two limb slices in reverse order.\n⚠️ Returns the matrix product <code>self * other</code>.\n⚠️ Collection of division algorithms.\n⚠️ Division with remainder.\nReturns the argument unchanged.\n⚠️ Compute a Lehmer update matrix from two <code>Uint</code>s.\n⚠️ Compute the Lehmer update matrix in full 64 bit …\n⚠️ Compute the Lehmer update matrix for small values.\n⚠️ Compute the largest valid Lehmer update matrix for …\n⚠️ Lehmer’s GCD algorithms.\n⚠️ Lehmer’s extended GCD.\nCalls <code>U::from(self)</code>.\n⚠️ Modular inversion using extended GCD.\n⚠️ Computes <code>lhs *= a</code> and returns the carry.\n⚠️ Computes a * b * 2^(-BITS) mod modulus\n⚠️ Shift left small.\n⚠️ Shift right small.\n⚠️ Computes a^2 * 2^(-BITS) mod modulus\n⚠️ Computes <code>lhs -= a * b</code> and returns the borrow.\n⚠️ Division with remainder.\n⚠️ Compute single limb division.\n⚠️ Computes the quotient and remainder of a <code>u128</code> …\n⚠️ Computes the quotient and remainder of a <code>u128</code> …\n⚠️ Reference implementation for <code>div_2x1</code>.\n⚠️ Computes the quotient of a 192 bits divided by a …\n⚠️ Computes the quotient of a 192 bits divided by a …\n⚠️ Reference implementation for <code>div_3x2</code>.\n⚠️ Compute single limb division.\n⚠️ Compute single limb normalized division.\n⚠️ Compute double limb division.\n⚠️ Compute double limb normalized division.\n⚠️ In-place Knuth long division with implicit …\n⚠️ In-place Knuth normalized long division with …\n⚠️ Computes $\\floor{\\frac{2^{128} - 1}{\\mathsf{d}}} - …\n⚠️ Computes $\\floor{\\frac{2^{192} - 1}{\\mathsf{d}}} - …\n⚠️ Computes $\\floor{\\frac{2^{192} - 1}{\\mathsf{d}}} - …\n⚠️ Computes $\\floor{\\frac{2^{128} - 1}{\\mathsf{d}}} - …\n⚠️ Computes $\\floor{\\frac{2^{128} - 1}{\\mathtt{d}}} - …\n<code>Bits</code> for <code>0</code> bits.\n<code>Bits</code> for <code>1</code> bits.\n<code>Bits</code> for <code>1024</code> bits.\n<code>Bits</code> for <code>128</code> bits.\n<code>Bits</code> for <code>16</code> bits.\n<code>Bits</code> for <code>160</code> bits.\n<code>Bits</code> for <code>192</code> bits.\n<code>Bits</code> for <code>2048</code> bits.\n<code>Bits</code> for <code>256</code> bits.\n<code>Bits</code> for <code>32</code> bits.\n<code>Bits</code> for <code>320</code> bits.\n<code>Bits</code> for <code>384</code> bits.\n<code>Bits</code> for <code>4096</code> bits.\n<code>Bits</code> for <code>448</code> bits.\n<code>Bits</code> for <code>512</code> bits.\n<code>Bits</code> for <code>64</code> bits.\n<code>Bits</code> for <code>768</code> bits.\n<code>Bits</code> for <code>8</code> bits.\n<code>Uint</code> for <code>0</code> bits. Always zero. Similar to <code>()</code>.\n<code>Uint</code> for <code>1</code> bit. Similar to <code>bool</code>.\n<code>Uint</code> for <code>1024</code> bits.\n<code>Uint</code> for <code>128</code> bits. Similar to <code>u128</code>.\n<code>Uint</code> for <code>16</code> bits. Similar to <code>u16</code>.\n<code>Uint</code> for <code>160</code> bits.\n<code>Uint</code> for <code>192</code> bits.\n<code>Uint</code> for <code>2048</code> bits.\n<code>Uint</code> for <code>256</code> bits.\n<code>Uint</code> for <code>32</code> bits. Similar to <code>u32</code>.\n<code>Uint</code> for <code>320</code> bits.\n<code>Uint</code> for <code>384</code> bits.\n<code>Uint</code> for <code>4096</code> bits.\n<code>Uint</code> for <code>448</code> bits.\n<code>Uint</code> for <code>512</code> bits.\n<code>Uint</code> for <code>64</code> bits. Similar to <code>u64</code>.\n<code>Uint</code> for <code>768</code> bits.\n<code>Uint</code> for <code>8</code> bits. Similar to <code>u8</code>.\nUse comma as decimal separator\nDecimal separator for number formatting\nThe prefix used for hashing messages according to EIP-191.\nEther is equivalent to 1e18 wei.\nGwei is equivalent to 1e9 wei.\nSigned 256-bit integer.\nThe provided units are not recognized.\nThe Keccak-256 hash of the empty string <code>&quot;&quot;</code>.\nKwei is equivalent to 1e3 wei.\nSimple <code>Keccak-256</code> hasher.\nThe largest unit.\nThe smallest unit.\nMwei is equivalent to 1e6 wei.\nPwei is equivalent to 1e15 wei.\nOverflow when parsing a signed number.\nThis enum holds the numeric types that a possible to be …\nUse period as decimal separator\nTwei is equivalent to 1e12 wei.\nUnsigned 256-bit integer.\nEthereum unit. Always less than <code>77</code>.\nError type for <code>Unit</code>-related operations.\nWei is equivalent to 1 wei.\nAllocates memory on the heap then places <code>x</code> into it, …\nConstructs a new box with uninitialized contents on the …\nHash a message according to EIP-191 (version <code>0x01</code>).\nConstructs a message according to EIP-191 (version <code>0x01</code>).\nFormats the given number of Wei as an Ether amount.\nFormats the given number of Wei as the given unit.\nFormats the given number of Wei as the given unit.\nFormats the given number of Wei as the given unit with a …\nFormats the given number of Wei as the given unit.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the numeric value of the unit.\nReturns the absolute value of the number.\nReturns the signed value of the number.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the number is negative.\nReturns <code>true</code> if the number is positive.\nReturns <code>true</code> if the number is signed.\nReturns <code>true</code> if the number is unsigned.\nReturns <code>true</code> if the number is zero.\nSimple interface to the <code>Keccak-256</code> hash function.\nCreates a new <code>Unit</code> instance, checking for overflow.\nCreates a new <code>Unit</code> instance.\nConverts the input to a U256 and converts from Ether to …\nParses a decimal number and multiplies it with 10^units.\nParses a decimal number and multiplies it with 10^units.\nReturns the character used as decimal separator\nTries to collect the elements of an iterator into a <code>Vec</code>.\nTries to create a <code>Vec</code> with the given capacity.\nReturns <code>10^self</code>, which is the number of Wei in this unit.\nReturns <code>10^self</code>, which is the number of Wei in this unit.\nWhether the event is anonymous.\nThe ABI representation of this type.\nArray out of bounds access.\nUsed by the <code>assert()</code> builtin.\nTrailing bytes in deserialization buffer.\nThe number of variants in the enum.\nThe number of topics.\nThe number of variants.\nThe number of variants.\nA generic contract error.\nA detailed contract error, including a specific revert or …\nA detailed contract error, including a specific revert or …\nA contract’s custom error.\nA contract’s custom error.\nThe <code>TokenSeq</code> type corresponding to the tuple.\nThe underlying tuple type which represents this event’s …\nDivision or modulo by zero.\nThe statically-known ABI-encoded size of the type.\nEIP-712 domain attributes used in determining the domain …\nEmpty array pop.\nEnum conversion error.\nContains the error value\nABI Encoding and Decoding errors.\nA Solidity event topic.\nHex error.\nGeneric / unspecified error.\nA generic contract error.\nRepresents the reason for a revert in a generic contract …\nInvalid enum value.\nCalling invalid internal function.\nCould not decode an event from log topics.\nExtension trait for ABI representation.\nThe minimum length of the data for this type.\nThe name of this type.\nThe name of this type.\nThe struct name.\nContains the success value\nOther errors.\nOverran deserialization buffer.\nThe statically-known Non-standard Packed Mode ABI-encoded …\nA Solidity panic.\nA panic. See <code>Panic</code> for more information.\nA panic. See <code>Panic</code> for more information.\nRepresents a Solidity panic. Same as the Solidity …\nThe underlying tuple type which represents the error’s …\nThe underlying tuple type which represents this type’s …\nThe underlying tuple type which represents this type’s …\nRepresents a raw string message as the reason for the …\nRepresents a raw string message as the reason for the …\nABI Decoding recursion limit exceeded.\nValidation reserialization did not match input.\nAllocation failed.\nResource error (too large allocation or too large array).\nABI result type.\nThe function’s return struct.\nThe returns’ corresponding TokenSeq type.\nThe underlying tuple type which represents this type’s …\nRepresents a standard Solidity revert. These are thrown by …\nA generic revert. See <code>Revert</code> for more information.\nA generic revert. See <code>Revert</code> for more information.\nRepresents the reason for a revert in a smart contract.\nThe corresponding Rust type.\nThe error selector: <code>keccak256(SIGNATURE)[0..4]</code>\nThe function selector: <code>keccak256(SIGNATURE)[0..4]</code>\nThe error’s ABI signature.\nThe event’s ABI signature.\nThe function’s ABI signature.\nThe event’s ABI signature hash, or selector: …\nThe name of this type in Solidity.\nIterator over the function or error selectors of a …\nA Solidity function call.\nA Solidity constructor.\nA Solidity enum. This is always a wrapper around a <code>u8</code>.\nA Solidity custom error.\nSolidity event.\nA collection of <code>SolEvent</code>s.\nA collection of ABI-encodable call-like types. This …\nA Solidity struct.\nA Solidity type.\nThe Solidity type that this type corresponds to.\nA Solidity value.\nInvalid encoding in storage.\nThe corresponding <code>TokenSeq</code> type.\nThe arguments’ corresponding TokenSeq type.\nThe arguments’ corresponding TokenSeq type.\nThe corresponding ABI token type.\nA list of Solidity event topics.\nThe underlying tuple type which represents this event’s …\nA typecheck detected a word that does not match the data …\nArithmetic underflow or overflow.\nUnknown selector.\nThe ABI word type.\nEthereum ABI codec implementation.\nReturns the ABI representation of this type.\nABI decode the enum from the given buffer.\nABI decode this error’s arguments from the given slice, …\nABI decode this call’s arguments from the given slice, …\nABI-decodes the given data into one of the variants of <code>self</code>…\nABI-decode this type from the given data.\nABI-decodes the dynamic data of this event from the given …\nABI-decodes the dynamic data of this event from the given …\nABI-decode this type from the given data.\nABI-decode this type from the given data, with validation.\nABI-decodes the given data into one of the variants of <code>self</code>…\nABI decode this call’s arguments from the given slice, …\nABI decode this call’s arguments from the given slice, …\nABI-decodes the given data into one of the variants of <code>self</code>…\nABI decode this error’s arguments from the given slice, …\nABI decode this call’s arguments from the given slice, …\nABI decode this call’s return values from the given …\nABI decode this call’s return values from the given …\nABI-decode this type from the given data.\nABI-decode this type from the given data, with validation.\nABI decode the enum from the given buffer, with validation.\nABI decode this error’s arguments from the given slice, …\nABI decode this call’s arguments from the given slice, …\nABI-decodes the given data into one of the variants of <code>self</code>…\nABI-decode this type from the given data, with validation.\nABI encode the enum.\nABI encode the error to the given buffer <strong>with</strong> its selector.\nABI encode the call to the given buffer <strong>with</strong> its selector.\nABI encode the call to the given buffer.\nABI-encodes <code>self</code> into the given buffer.\nABI-encodes the value.\nNon-standard Packed Mode ABI encoding.\nNon-standard Packed Mode ABI encoding.\nEncodes an ABI sequence suitable for function parameters.\nABI-encodes <code>self</code> into the given buffer, <em>without</em> any …\nABI encode the enum into the given buffer.\nABI encode the error to the given buffer <strong>without</strong> its …\nABI encode the call to the given buffer <strong>without</strong> its …\nABI encode the call’s return value.\nABI encode the call’s return values.\nEncodes an ABI sequence.\nThe size of the encoded data, <em>without</em> any selectors.\nThe size of the error params when encoded in bytes, <strong>without</strong>…\nThe size of the ABI-encoded dynamic data in bytes.\nThe size of the encoded data in bytes, <strong>without</strong> its …\nThe size of the encoded data in bytes.\nCalculate the ABI-encoded size of the data.\nReturns the <code>ContractError</code> if this type is a …\nReturns an immutable reference to the inner custom error …\nReturns a mutable reference to the inner custom error if …\nReturns an immutable reference to the inner <code>Panic</code> if <code>self</code> …\nReturns a mutable reference to the inner <code>Panic</code> if <code>self</code> …\nReturns the raw string error message if this type is a …\nReturns an immutable reference to the inner <code>Revert</code> if <code>self</code> …\nReturns a mutable reference to the inner <code>Revert</code> if <code>self</code> …\nReturns the panic code’s string representation.\nThe EIP-155 chain ID. The user-agent should refuse signing …\nCheck that the event’s signature matches the given …\nThe Solidity panic code.\nInstantiates a new error with a static str.\nDecodes and retrieves the reason for a revert from the …\nDecode the event from the given log object.\nDecode the events from the given log object.\nDecode the event from the given log object.\nDecode the event from the given log object with validation.\nDecode the event from the given log object with validation.\nDecode the events from the given log info.\nDecode the event from the given log info.\nDecode the event from the given log info, with validation.\nDecodes and retrieves the reason for a revert from the …\nDecode the topics of this event from the given data.\nDetokenize the topics into a tuple of rust types.\nDetokenize this type’s value from the given token.\nDetokenize a value from the given token.\nReturns component EIP-712 types. These types are used to …\nEncode this data according to EIP-712 <code>encodeData</code> rules, …\nConvenience macro to instantiate an EIP-712 domain.\nEncodes this domain using EIP-712 <code>encodeData</code>.\nThe EIP-712-encoded type string.\nCalculates the EIP-712 <code>hashStruct</code> for this value.\nReturn the root EIP-712 type. This type is used to …\nCalculate the EIP-712 signing hash for this struct. Note …\nCalculates the EIP-712 <code>typeHash</code> for this struct.\nABI-encode the dynamic data of this event.\nABI-encode the dynamic data of this event into the given …\nTransform ca <code>Log</code> containing this event into a <code>Log</code> …\nEncode this event to a <code>LogData</code>.\nIndexed event parameter encoding.\nEncodes this type as preimage bytes which are then hashed …\nEncode the topics of this event.\nEncode the topics of this event into a fixed-size array.\nEncode the topics of this event into the given buffer.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the panic code for the given number if it is a …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if <code>self</code> matches <code>CustomError</code>.\nReturns <code>true</code> if <code>self</code> matches <code>CustomError</code>.\nReturns <code>true</code> if <code>self</code> matches <code>Panic</code>.\nReturns <code>true</code> if <code>self</code> matches <code>Panic</code>.\nReturns <code>true</code> if <code>self</code> matches <code>Revert</code>.\nReturns <code>true</code> if <code>self</code> matches <code>Revert</code>.\nReturns the PanicKind if this panic code is a known …\nThe user readable name of signing domain, i.e. the name of …\nConvert from the tuple type used for ABI encoding and …\nConvert decoded rust data to the event type.\nConvert from the tuple type used for ABI encoding and …\nConvert from the tuple type used for ABI encoding and …\nConvert decoded rust data to the event type.\nReturns the revert reason string, or <code>&quot;&lt;empty&gt;&quot;</code> if empty.\nThe reason string, provided by the Solidity contract.\nA disambiguating salt for the protocol. This can be used …\nThe selector of this instance.\nThe selector of this type at the given index, used in …\nReturns an iterator over the selectors of this type.\nGenerate types that implement <code>alloy-sol-types</code> traits, …\nSolidity types.\nThe name of the associated Solidity type.\nThe name of the associated Solidity type.\nReturns the reason for a revert as a string.\nConvert to the token type used for EIP-712 encoding and …\nTokenize the call’s arguments.\nTokenize the call’s arguments.\nTokenize the enum.\nTokenizes the given value into this type’s token.\nTokenize the event’s non-indexed parameters.\nTokenize the call’s return values.\nThe number of bytes this type occupies in another topic’…\nThe event’s topics.\nReturns an error if the given selector is not known to …\nInstantiates a new <code>Error::TypeCheckFail</code> with the provided …\nInstantiates a new <code>Error::TypeCheckFail</code> with the provided …\nInstantiates a new <code>Error::TypeCheckFail</code> with the provided …\nInstantiates a new <code>Error::UnknownSelector</code> with the …\nUtilities used by different modules.\nReturns <code>true</code> if the given selector is known to this type.\nReturns <code>true</code> if the given token can be detokenized with …\nThe address of the contract that will verify the signature.\nThe current major version of the signing domain. …\nHex-encoded data.\nThe Solidity type we failed to produce.\nThe invalid log.\nThe maximum valid value.\nThe name of the enum.\nThe name of the enum or event.\nThe type name.\nThe unknown selector.\nThe invalid value.\nTrue if the token represents a dynamically-sized type.\nThe <code>Decoder</code> wraps a byte slice with necessary info to …\nThe ABI encoding of an empty byte array (<code>bytes</code> or <code>string</code>).\nAn ABI encoder.\nThe decoder recursion limit. This is currently hardcoded, …\nEthereum ABI tokens.\nA token composed of a sequence of other tokens.\nABI-decodes a token by wrapping it in a single-element …\nDecode a token from a decoder.\nABI-decodes top-level function args.\nDecodes ABI compliant vector of bytes into vector of …\nABI-decode the token sequence from the encoder.\nABI-encodes a single token.\nABI-encodes a tuple as ABI function params, suitable for …\nABI-encodes a token sequence.\nABI-encode the token sequence into the encoder.\nAppend head words to the encoder.\nCalculate the number of head words.\nAppend tail words to the encoder.\nCalculate the number of tail words.\nEthereum ABI tokens.\nTrue if the token represents a dynamically-sized type.\nA Dynamic Sequence - <code>T[]</code>\nA Fixed Sequence - <code>T[N]</code>\nA Packed Sequence - <code>bytes</code> or <code>string</code>\nEthereum ABI tokens.\nA token composed of a sequence of other tokens.\nA single EVM word - T for any value type.\nDecode a token from a decoder.\nABI-decode the token sequence from the encoder.\nABI-encode the token sequence into the encoder.\nAppend head words to the encoder.\nCalculate the number of head words.\nAppend tail words to the encoder.\nCalculate the number of tail words.\nAddress - <code>address</code>\nArray - <code>T[]</code>\nThe number of bits in the integer: <code>BITS</code>\nThe number of bytes in the integer: <code>BITS / 8</code>\nBool - <code>bool</code>\nSpecifies the number of bytes in a <code>FixedBytes</code> array as a …\nBytes - <code>bytes</code>\nFixedArray - <code>T[M]</code>\nFixedBytes - <code>bytesX</code>\nFunction - <code>function</code>\nThe name of the <code>Int</code> type: <code>int&lt;N&gt;</code>\nInt - <code>intX</code>\nThe signed integer Rust representation.\nSpecifies the number of bits in an <code>Int</code> or <code>Uint</code> as a type.\nThe name of the <code>FixedBytes</code> type: <code>bytes&lt;N&gt;</code>\nThe difference between the representation’s and this …\nString - <code>string</code>\nStatically guarantees that a <code>FixedBytes</code> byte count is …\nStatically guarantees that a <code>Int</code> or <code>Uint</code> bit count is …\nThe name of the <code>Uint</code> type: <code>uint&lt;N&gt;</code>\nUint - <code>uintX</code>\nThe unsigned integer Rust representation.\nThe index of the most significant byte in the Word type.\nDetokenizes a signed integer.\nDetokenizes an unsigned integer.\nABI-encode a signed integer in packed mode.\nABI-encode an unsigned integer in packed mode.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTokenizes a signed integer.\nTokenizes an unsigned integer.\nSee <code>usize::next_multiple_of</code>.\nCalculates the padded length of a slice by rounding its …\nCalculates the padded length of a slice of a specific …")
searchState.loadedDescShard("k256", 0, "RustCrypto: secp256k1 (K-256) elliptic curve\nsecp256k1 curve point expressed in affine coordinates.\nCompressed SEC1-encoded secp256k1 (K-256) curve point.\nSEC1-encoded secp256k1 (K-256) curve point.\nsecp256k1 (K-256) field element serialized as bytes.\nBase point of secp256k1.\nBase point of secp256k1.\nAdditive identity of the group: the point at infinity.\nAdditive identity of the group: the point at infinity.\nNon-zero secp256k1 (K-256) scalar field element.\nMultiplicative identity.\nA point on the secp256k1 curve in projective coordinates.\nsecp256k1 (K-256) public key.\nScalars are elements in the finite field modulo n.\nsecp256k1 (K-256) elliptic curve.\nsecp256k1 (K-256) secret key.\n256-bit unsigned big integer.\nBytes used by a wide reduction: twice the width of ‚Ä¶\nZero scalar.\nReturns self + rhs mod n.\nDoubles this point.\nElliptic Curve Digital Signature Algorithm (ECDSA).\nCalculates SECP256k1 endomorphism: <code>self * lambda</code>.\nCheck whether <code>self</code> is equal to an affine point.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAttempts to parse the given <code>EncodedPoint</code> as an ‚Ä¶\nAttempts to parse the given byte array as an SEC1-encoded ‚Ä¶\nReturns a (nearly) uniformly-random scalar, generated in ‚Ä¶\nReturns a uniformly-random scalar, generated using ‚Ä¶\nReturns the base point of secp256k1.\nReturns the base point of SECP256k1.\nReturns the identity of the group: the point at infinity.\nReturns the additive identity of SECP256k1, also known as ‚Ä¶\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInverts the scalar.\nFast variable-time inversion using Stein‚Äôs algorithm.\nIs this point the identity point?\nChecks if the scalar is zero.\nModulo multiplies two scalars.\nCalculates <code>k * G</code>, where <code>G</code> is the generator.\nNegates the scalar.\nRight shifts the scalar.\nTonelli-Shank‚Äôs algorithm for q mod 16 = 1 ‚Ä¶\nModulo squares the scalar.\nReturns self - rhs mod n.\nReturns the affine representation of this point.\nReturns the SEC1 encoding of this scalar.\nConvert to curve representation.\nECDSA/secp256k1 signature (ASN.1 DER encoded)\nSignature errors.\nMaximum supported value for the recovery ID (inclusive).\nRecovery IDs, a.k.a. ‚Äúrecid‚Äù.\nECDSA/secp256k1 signature (fixed-size)\nECDSA/secp256k1 signing key\nECDSA/secp256k1 verification key (i.e. public key)\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert a <code>u8</code> into a <code>RecoveryId</code>.\nCreate a new error with an associated source.\nLow-level ECDSA primitives.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDid the affine x-coordinate of ùëò√óùëÆ overflow the ‚Ä¶\nIs the affine y-coordinate of ùëò√óùëÆ odd?\nCreate a new error with no associated source\nCreate a new <code>RecoveryId</code> from the following 1-bit arguments:\nConvert this <code>RecoveryId</code> into a <code>u8</code>.\nGiven a public key, message digest, and signature, use ‚Ä¶\nGiven a public key, message, and signature, use trial ‚Ä¶\nGiven a public key, message digest, and signature, use ‚Ä¶\nPreferred digest to use when computing ECDSA signatures ‚Ä¶\nBind a preferred <code>Digest</code> algorithm to an elliptic curve ‚Ä¶\nTry to sign the given prehashed message using ECDSA.\nVerify the given prehashed message using ECDSA.\nPartial implementation of the <code>bits2int</code> function as defined ‚Ä¶\nSign a prehashed message digest using the provided secret ‚Ä¶\nTry to sign the prehashed message.\nTry to sign the given message digest deterministically ‚Ä¶\nVerify message digest against the provided signature.\nVerify the prehashed message against the provided ECDSA ‚Ä¶\nVerify the prehashed message against the provided ECDSA ‚Ä¶")
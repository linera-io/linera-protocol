// Copyright (c) Zefchain Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

//! Conversions from types declared in [`linera_sdk`] to types generated by [`wit_bindgen_rust`].

use super::application;
use linera_sdk::{
    ApplicationCallResult, Destination, ExecutionResult, HashValue, Session, SessionCallResult,
};
use std::task::Poll;

impl From<HashValue> for application::HashValue {
    fn from(hash_value: HashValue) -> Self {
        let parts = <[u64; 8]>::from(hash_value);

        application::HashValue {
            part1: parts[0],
            part2: parts[1],
            part3: parts[2],
            part4: parts[3],
            part5: parts[4],
            part6: parts[5],
            part7: parts[6],
            part8: parts[7],
        }
    }
}

impl From<ApplicationCallResult> for application::ApplicationCallResult {
    fn from(result: ApplicationCallResult) -> Self {
        let create_sessions = result
            .create_sessions
            .into_iter()
            .map(application::Session::from)
            .collect();

        application::ApplicationCallResult {
            create_sessions,
            execution_result: result.execution_result.into(),
            value: result.value,
        }
    }
}

impl From<Session> for application::Session {
    fn from(new_session: Session) -> Self {
        application::Session {
            kind: new_session.kind,
            data: new_session.data,
        }
    }
}

impl From<SessionCallResult> for application::SessionCallResult {
    fn from(result: SessionCallResult) -> Self {
        application::SessionCallResult {
            inner: result.inner.into(),
            data: result.data,
        }
    }
}

impl From<ExecutionResult> for application::ExecutionResult {
    fn from(result: ExecutionResult) -> Self {
        let effects = result
            .effects
            .into_iter()
            .map(|(destination, effect)| (destination.into(), effect))
            .collect();

        let subscribe = result
            .subscribe
            .into_iter()
            .map(|(channel_id, chain_id)| (channel_id, chain_id.0.into()))
            .collect();

        let unsubscribe = result
            .unsubscribe
            .into_iter()
            .map(|(channel_id, chain_id)| (channel_id, chain_id.0.into()))
            .collect();

        application::ExecutionResult {
            effects,
            subscribe,
            unsubscribe,
        }
    }
}

impl From<Destination> for application::Destination {
    fn from(destination: Destination) -> Self {
        match destination {
            Destination::Recipient(chain_id) => {
                application::Destination::Recipient(chain_id.0.into())
            }
            Destination::Subscribers(channel_id) => {
                application::Destination::Subscribers(channel_id)
            }
        }
    }
}

impl From<Poll<Result<ExecutionResult, String>>> for application::PollExecutionResult {
    fn from(poll: Poll<Result<ExecutionResult, String>>) -> Self {
        use application::PollExecutionResult;
        match poll {
            Poll::Pending => PollExecutionResult::Pending,
            Poll::Ready(Ok(result)) => PollExecutionResult::Ready(Ok(result.into())),
            Poll::Ready(Err(message)) => PollExecutionResult::Ready(Err(message)),
        }
    }
}

impl From<Poll<Result<ApplicationCallResult, String>>> for application::PollCallApplication {
    fn from(poll: Poll<Result<ApplicationCallResult, String>>) -> Self {
        use application::PollCallApplication;
        match poll {
            Poll::Pending => PollCallApplication::Pending,
            Poll::Ready(Ok(result)) => PollCallApplication::Ready(Ok(result.into())),
            Poll::Ready(Err(message)) => PollCallApplication::Ready(Err(message)),
        }
    }
}

impl From<Poll<Result<SessionCallResult, String>>> for application::PollCallSession {
    fn from(poll: Poll<Result<SessionCallResult, String>>) -> Self {
        use application::PollCallSession;
        match poll {
            Poll::Pending => PollCallSession::Pending,
            Poll::Ready(Ok(result)) => PollCallSession::Ready(Ok(result.into())),
            Poll::Ready(Err(message)) => PollCallSession::Ready(Err(message)),
        }
    }
}

impl From<Poll<Result<Vec<u8>, String>>> for application::PollQuery {
    fn from(poll: Poll<Result<Vec<u8>, String>>) -> Self {
        use application::PollQuery;
        match poll {
            Poll::Pending => PollQuery::Pending,
            Poll::Ready(Ok(response)) => PollQuery::Ready(Ok(response)),
            Poll::Ready(Err(message)) => PollQuery::Ready(Err(message)),
        }
    }
}

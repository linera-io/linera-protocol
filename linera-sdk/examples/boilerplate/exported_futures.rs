// Copyright (c) Zefchain Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

//! Types for the exported futures for the application endpoints.
//!
//! Each type is called by the code generated by [`wit_bindgen_rust`] when the host calls the guest
//! WASM module's respective endpoint. This module contains the code to forward the call to the
//! application type that implements [`linera_sdk::Application`].

use super::{super::ApplicationState, application};
use linera_sdk::{
    Application, ApplicationCallResult, ExecutionResult, ExportedFuture, SessionCallResult,
    SessionId,
};
use wit_bindgen_guest_rust::Handle;

pub struct ExecuteOperation {
    future: ExportedFuture<Result<ExecutionResult, String>>,
}

impl application::ExecuteOperation for ExecuteOperation {
    fn new(context: application::OperationContext, operation: Vec<u8>) -> Handle<Self> {
        Handle::new(ExecuteOperation {
            future: ExportedFuture::new(async move {
                let mut application = ApplicationState::load_and_lock().await;
                let result = application
                    .execute_operation(&context.into(), &operation)
                    .await;
                if result.is_ok() {
                    application.store_and_unlock().await;
                }
                result.map_err(|error| error.to_string())
            }),
        })
    }

    fn poll(&self) -> application::PollExecutionResult {
        self.future.poll()
    }
}

pub struct ExecuteEffect {
    future: ExportedFuture<Result<ExecutionResult, String>>,
}

impl application::ExecuteEffect for ExecuteEffect {
    fn new(context: application::EffectContext, effect: Vec<u8>) -> Handle<Self> {
        Handle::new(ExecuteEffect {
            future: ExportedFuture::new(async move {
                let mut application = ApplicationState::load_and_lock().await;
                let result = application.execute_effect(&context.into(), &effect).await;
                if result.is_ok() {
                    application.store_and_unlock().await;
                }
                result.map_err(|error| error.to_string())
            }),
        })
    }

    fn poll(&self) -> application::PollExecutionResult {
        self.future.poll()
    }
}

pub struct CallApplication {
    future: ExportedFuture<Result<ApplicationCallResult, String>>,
}

impl application::CallApplication for CallApplication {
    fn new(
        context: application::CalleeContext,
        argument: Vec<u8>,
        forwarded_sessions: Vec<application::SessionId>,
    ) -> Handle<Self> {
        Handle::new(CallApplication {
            future: ExportedFuture::new(async move {
                let mut application = ApplicationState::load_and_lock().await;

                let forwarded_sessions = forwarded_sessions
                    .into_iter()
                    .map(SessionId::from)
                    .collect();

                let result = application
                    .call_application(&context.into(), &argument, forwarded_sessions)
                    .await;
                if result.is_ok() {
                    application.store_and_unlock().await;
                }
                result.map_err(|error| error.to_string())
            }),
        })
    }

    fn poll(&self) -> application::PollCallApplication {
        self.future.poll()
    }
}

pub struct CallSession {
    future: ExportedFuture<Result<SessionCallResult, String>>,
}

impl application::CallSession for CallSession {
    fn new(
        context: application::CalleeContext,
        session: application::Session,
        argument: Vec<u8>,
        forwarded_sessions: Vec<application::SessionId>,
    ) -> Handle<Self> {
        Handle::new(CallSession {
            future: ExportedFuture::new(async move {
                let mut application = ApplicationState::load_and_lock().await;

                let forwarded_sessions = forwarded_sessions
                    .into_iter()
                    .map(SessionId::from)
                    .collect();

                let result = application
                    .call_session(
                        &context.into(),
                        session.into(),
                        &argument,
                        forwarded_sessions,
                    )
                    .await;
                if result.is_ok() {
                    application.store_and_unlock().await;
                }
                result.map_err(|error| error.to_string())
            }),
        })
    }

    fn poll(&self) -> application::PollCallSession {
        self.future.poll()
    }
}

pub struct QueryApplication {
    future: ExportedFuture<Result<Vec<u8>, String>>,
}

impl application::QueryApplication for QueryApplication {
    fn new(context: application::QueryContext, argument: Vec<u8>) -> Handle<Self> {
        Handle::new(QueryApplication {
            future: ExportedFuture::new(async move {
                let application = ApplicationState::load().await;
                application
                    .query_application(&context.into(), &argument)
                    .await
                    .map_err(|error| error.to_string())
            }),
        })
    }

    fn poll(&self) -> application::PollQuery {
        self.future.poll()
    }
}

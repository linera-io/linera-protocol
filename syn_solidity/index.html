<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="syn-solidity"><title>syn_solidity - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-6c3ea77c.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="syn_solidity" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0 (05f9846f8 2025-03-31)" data-channel="1.86.0" data-search-js="search-581efc7a.js" data-settings-js="settings-6dad6058.js" ><script src="../static.files/storage-3a5871a4.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-4d63596a.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="icon" href="https://raw.githubusercontent.com/alloy-rs/core/main/assets/favicon.ico"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../syn_solidity/index.html"><img src="https://raw.githubusercontent.com/alloy-rs/core/main/assets/alloy.jpg" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../syn_solidity/index.html"><img src="https://raw.githubusercontent.com/alloy-rs/core/main/assets/alloy.jpg" alt="logo"></a><h2><a href="../syn_solidity/index.html">syn_<wbr>solidity</a><span class="version">1.3.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#syn-solidity" title="syn-solidity">syn-solidity</a><ul><li><a href="#design" title="Design">Design</a></li><li><a href="#known-limitations" title="Known limitations">Known limitations</a></li><li><a href="#examples" title="Examples">Examples</a></li></ul></li></ul><h3><a href="#reexports">Crate Items</a></h3><ul class="block"><li><a href="#reexports" title="Re-exports">Re-exports</a></li><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#macros" title="Macros">Macros</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>syn_solidity</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/syn_solidity/lib.rs.html#1-98">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="syn-solidity"><a class="doc-anchor" href="#syn-solidity">§</a>syn-solidity</h2>
<p><a href="https://github.com/dtolnay/syn"><code>syn</code></a>-powered parser for Solidity-like <a href="https://doc.rust-lang.org/proc_macro/struct.TokenStream.html"><code>TokenStream</code></a>s.</p>
<p>The parsed root element is the <a href="struct.File.html" title="struct syn_solidity::File"><code>File</code></a>, which contains a list of <a href="enum.Item.html" title="enum syn_solidity::Item"><code>Item</code></a>s.
<a href="enum.Item.html" title="enum syn_solidity::Item"><code>Item</code></a>s also support outer attributes, as shown below.</p>
<h3 id="design"><a class="doc-anchor" href="#design">§</a>Design</h3>
<p>This parser is specifically designed for Rust procedural macros. It aims to
mimic the behavior of the official Solidity compiler (Solc) when it comes to
parsing valid Solidity code. This means that all valid Solidity code, as
recognized by Solc v0.5.*<sup id="fnref1"><a href="#fn1">1</a></sup> and above, will also be recognized and parsed
correctly by <code>syn-solidity</code>.</p>
<p>However, <code>syn-solidity</code> is more permissive and lenient compared to the official
Solidity compiler and grammar specifications. Some examples of code patterns
that are valid in <code>syn-solidity</code> but not in the official compiler include:</p>
<ul>
<li>identifiers are Rust identifiers (<code>syn::Ident</code>), and as such cannot contain
the dollar sign (<code>$</code>), but can contain unicode characters</li>
<li>trailing punctuation, like commas (<code>,</code>) in function arguments or enums
definitions</li>
<li>certain variable and function attributes in certain contexts, like <code>internal</code>
functions or functions with implementations (<code>{ ... }</code>) in interfaces</li>
<li>parameter storage locations in item definitions, like <code>uint256[] memory</code> in
a struct or error definition</li>
<li>the tuple type <code>(T, U, ..)</code> is allowed wherever a type is expected, and can
optionally be preceded by the <code>tuple</code> keyword.
This is the same as <a href="https://docs.ethers.org/v5/api/utils/abi/formats/#abi-formats--human-readable-abi"><code>ethers.js</code>’s Human-Readable ABI</a></li>
</ul>
<p>This lenient behavior is intentionally designed to facilitate usage within
procedural macros, and to reduce general code complexity in the parser and AST.</p>
<h3 id="known-limitations"><a class="doc-anchor" href="#known-limitations">§</a>Known limitations</h3>
<p>This parser is limited to only valid Rust tokens, meaning that certain Solidity
constructs are not supported. Some examples include, but are not limited to:</p>
<ul>
<li>dollar signs (<code>$</code>) inside of identifiers</li>
<li>single quote strings</li>
<li><code>hex</code> and <code>unicode</code> string literal prefixes.
Literal prefixes are <a href="https://doc.rust-lang.org/edition-guide/rust-2021/reserving-syntax.html">reserved in Rust edition 2021 and above</a>.</li>
<li><code>"\uXXXX"</code> unicode escapes. Rust uses <code>"\u{XXXX}"</code> for unicode codepoints</li>
<li>invalid nested block comments. For example, <code>/*/*/</code> does not parse.</li>
</ul>
<p>For the most part, you can copy-paste Solidity code and expect it to parse
correctly most of the time. You can see a few examples of Solidity code that
parses correctly (after some very light patching) in the <a href="https://github.com/alloy-rs/core/tree/main/crates/syn-solidity/tests/contracts">tests</a> directory.</p>
<h3 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h3>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>quote::quote;
<span class="kw">use </span>syn_solidity::{Expr, File, Item, Lit, Stmt};

<span class="comment">// Create a Solidity `TokenStream`
</span><span class="kw">let </span>tokens = <span class="macro">quote!</span> {
    <span class="doccomment">/// @name HelloWorld
    /// @notice A hello world example in Solidity.
    </span>contract HelloWorld {
        <span class="doccomment">/// @notice Returns the string "Hello, World!".
        </span>function helloWorld() external pure returns (string memory) {
            <span class="kw">return </span><span class="string">"Hello, World!"</span>;
        }
    }
};

<span class="comment">// Parse the tokens into a `File`
</span><span class="kw">let </span>ast: File = syn_solidity::parse2(tokens)<span class="question-mark">?</span>;

<span class="kw">let </span>items: <span class="kw-2">&amp;</span>[Item] = <span class="kw-2">&amp;</span>ast.items;
<span class="kw">let </span><span class="prelude-val">Some</span>(Item::Contract(contract)) = items.first() <span class="kw">else </span>{
    <span class="macro">unreachable!</span>()
};
<span class="macro">assert_eq!</span>(contract.name, <span class="string">"HelloWorld"</span>);
<span class="macro">assert_eq!</span>(contract.attrs.len(), <span class="number">2</span>); <span class="comment">// doc comments

</span><span class="kw">let </span>body: <span class="kw-2">&amp;</span>[Item] = <span class="kw-2">&amp;</span>contract.body;
<span class="kw">let </span><span class="prelude-val">Some</span>(Item::Function(function)) = body.first() <span class="kw">else </span>{
    <span class="macro">unreachable!</span>()
};
<span class="macro">assert_eq!</span>(function.attrs.len(), <span class="number">1</span>); <span class="comment">// doc comment
</span><span class="macro">assert_eq!</span>(function.name.as_ref().unwrap(), <span class="string">"helloWorld"</span>);
<span class="macro">assert!</span>(function.parameters.is_empty()); <span class="comment">// ()
</span><span class="macro">assert_eq!</span>(function.attributes.len(), <span class="number">2</span>); <span class="comment">// external pure
</span><span class="macro">assert!</span>(function.returns.is_some());

<span class="kw">let </span><span class="prelude-val">Some</span>([Stmt::Return(ret)]) = function.body() <span class="kw">else </span>{
    <span class="macro">unreachable!</span>()
};
<span class="kw">let </span><span class="prelude-val">Some</span>(Expr::Lit(Lit::Str(s))) = <span class="kw-2">&amp;</span>ret.expr <span class="kw">else </span>{
    <span class="macro">unreachable!</span>()
};
<span class="macro">assert_eq!</span>(s.value(), <span class="string">"Hello, World!"</span>);</code></pre></div>
<div class="footnotes"><hr><ol><li id="fn1"><p>Older versions may still parse successfully, but this is not guaranteed.&nbsp;<a href="#fnref1">↩</a></p></li></ol></div></div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><dl class="item-table reexports"><dt id="reexport.Spanned"><code>pub use spanned::<a class="trait" href="spanned/trait.Spanned.html" title="trait syn_solidity::spanned::Spanned">Spanned</a>;</code></dt><dt id="reexport.Visit"><code>pub use visit::<a class="trait" href="visit/trait.Visit.html" title="trait syn_solidity::visit::Visit">Visit</a>;</code></dt><dt id="reexport.VisitMut"><code>pub use visit_mut::<a class="trait" href="visit_mut/trait.VisitMut.html" title="trait syn_solidity::visit_mut::VisitMut">VisitMut</a>;</code></dt></dl><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="kw/index.html" title="mod syn_solidity::kw">kw</a></dt><dd>Solidity keywords.</dd><dt><a class="mod" href="spanned/index.html" title="mod syn_solidity::spanned">spanned</a></dt><dd>Helper <a href="spanned/trait.Spanned.html" title="trait syn_solidity::spanned::Spanned">trait</a> and methods to manipulate syntax tree nodes’ spans.</dd><dt><a class="mod" href="visit/index.html" title="mod syn_solidity::visit">visit</a></dt><dd>Syntax tree traversal to walk a shared borrow of a syntax tree.</dd><dt><a class="mod" href="visit_mut/index.html" title="mod syn_solidity::visit_mut">visit_<wbr>mut</a></dt><dd>Syntax tree traversal to mutate an exclusive borrow of a syntax tree in
place.</dd></dl><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">§</a></h2><dl class="item-table"><dt><a class="macro" href="macro.sol_path.html" title="macro syn_solidity::sol_path">sol_<wbr>path</a></dt><dd>Create a <a href="struct.SolPath.html" title="struct syn_solidity::SolPath"><code>SolPath</code></a> from a list of identifiers.</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.ArgList.html" title="struct syn_solidity::ArgList">ArgList</a></dt><dd>A list of named or unnamed arguments: <code>{ foo: 42, bar: 64 }</code> or <code>(42, 64)</code>.</dd><dt><a class="struct" href="struct.AssemblyFlags.html" title="struct syn_solidity::AssemblyFlags">Assembly<wbr>Flags</a></dt><dd>A list of flags of an assembly statement.</dd><dt><a class="struct" href="struct.Block.html" title="struct syn_solidity::Block">Block</a></dt><dd>A curly-braced block of statements: <code>{ ... }</code>.</dd><dt><a class="struct" href="struct.CatchClause.html" title="struct syn_solidity::CatchClause">Catch<wbr>Clause</a></dt><dd>A catch clause of a <a href="struct.StmtTry.html" title="struct syn_solidity::StmtTry"><code>StmtTry</code></a>: <code>catch  { ... }</code>.</dd><dt><a class="struct" href="struct.EventParameter.html" title="struct syn_solidity::EventParameter">Event<wbr>Parameter</a></dt><dd>An event parameter.</dd><dt><a class="struct" href="struct.ExprArray.html" title="struct syn_solidity::ExprArray">Expr<wbr>Array</a></dt><dd>An array literal expression: <code>[a, b, c, d]</code>.</dd><dt><a class="struct" href="struct.ExprBinary.html" title="struct syn_solidity::ExprBinary">Expr<wbr>Binary</a></dt><dd>A binary operation: <code>a + b</code>, <code>a += b</code>.</dd><dt><a class="struct" href="struct.ExprCall.html" title="struct syn_solidity::ExprCall">Expr<wbr>Call</a></dt><dd>A function call expression: <code>foo(42)</code> or <code>foo({ bar: 42 })</code>.</dd><dt><a class="struct" href="struct.ExprCallOptions.html" title="struct syn_solidity::ExprCallOptions">Expr<wbr>Call<wbr>Options</a></dt><dd>Function call options: <code>foo.bar{ value: 1, gas: 2 }</code>.</dd><dt><a class="struct" href="struct.ExprDelete.html" title="struct syn_solidity::ExprDelete">Expr<wbr>Delete</a></dt><dd>A unary <code>delete</code> expression: <code>delete vector</code>.</dd><dt><a class="struct" href="struct.ExprIndex.html" title="struct syn_solidity::ExprIndex">Expr<wbr>Index</a></dt><dd>A square bracketed indexing expression: <code>vector[2]</code>.</dd><dt><a class="struct" href="struct.ExprMember.html" title="struct syn_solidity::ExprMember">Expr<wbr>Member</a></dt><dd>Access of a named member: <code>obj.k</code>.</dd><dt><a class="struct" href="struct.ExprNew.html" title="struct syn_solidity::ExprNew">ExprNew</a></dt><dd>A <code>new</code> expression: <code>new Contract</code>.</dd><dt><a class="struct" href="struct.ExprPayable.html" title="struct syn_solidity::ExprPayable">Expr<wbr>Payable</a></dt><dd>A <code>payable</code> expression: <code>payable(address(0x...))</code>.</dd><dt><a class="struct" href="struct.ExprPostfix.html" title="struct syn_solidity::ExprPostfix">Expr<wbr>Postfix</a></dt><dd>A postfix unary expression: <code>foo++</code>.</dd><dt><a class="struct" href="struct.ExprTernary.html" title="struct syn_solidity::ExprTernary">Expr<wbr>Ternary</a></dt><dd>A ternary (AKA conditional) expression: <code>foo ? bar : baz</code>.</dd><dt><a class="struct" href="struct.ExprTuple.html" title="struct syn_solidity::ExprTuple">Expr<wbr>Tuple</a></dt><dd>A tuple expression: <code>(a, b, c, d)</code>.</dd><dt><a class="struct" href="struct.ExprTypeCall.html" title="struct syn_solidity::ExprTypeCall">Expr<wbr>Type<wbr>Call</a></dt><dd>A <code>type()</code> expression: <code>type(uint256)</code></dd><dt><a class="struct" href="struct.ExprUnary.html" title="struct syn_solidity::ExprUnary">Expr<wbr>Unary</a></dt><dd>A unary operation: <code>!x</code>, <code>-x</code>.</dd><dt><a class="struct" href="struct.File.html" title="struct syn_solidity::File">File</a></dt><dd>A Solidity file. The root of the AST.</dd><dt><a class="struct" href="struct.FunctionAttributes.html" title="struct syn_solidity::FunctionAttributes">Function<wbr>Attributes</a></dt><dd>A list of unique function attributes. Used in
<a href="struct.ItemFunction.html" title="struct syn_solidity::ItemFunction">ItemFunction</a>.</dd><dt><a class="struct" href="struct.HexStr.html" title="struct syn_solidity::HexStr">HexStr</a></dt><dd>A hex string.</dd><dt><a class="struct" href="struct.ImportAlias.html" title="struct syn_solidity::ImportAlias">Import<wbr>Alias</a></dt><dd>An import alias.</dd><dt><a class="struct" href="struct.ImportAliases.html" title="struct syn_solidity::ImportAliases">Import<wbr>Aliases</a></dt><dd>A list of import aliases: <code>{ Foo as Bar, Baz } from "foo.sol"</code>.</dd><dt><a class="struct" href="struct.ImportDirective.html" title="struct syn_solidity::ImportDirective">Import<wbr>Directive</a></dt><dd>An import directive: <code>import "foo.sol";</code>.</dd><dt><a class="struct" href="struct.ImportGlob.html" title="struct syn_solidity::ImportGlob">Import<wbr>Glob</a></dt><dd>A glob import directive: <code>* as Foo from "foo.sol"</code>.</dd><dt><a class="struct" href="struct.ImportPlain.html" title="struct syn_solidity::ImportPlain">Import<wbr>Plain</a></dt><dd>A plain import directive: <code>import "foo.sol" as Foo;</code>.</dd><dt><a class="struct" href="struct.Inheritance.html" title="struct syn_solidity::Inheritance">Inheritance</a></dt><dd>A list of inheritance specifiers of an <a href="struct.ItemContract.html" title="struct syn_solidity::ItemContract"><code>ItemContract</code></a>:
<code>is ERC20("Token", "TKN"), Ownable</code>.</dd><dt><a class="struct" href="struct.ItemContract.html" title="struct syn_solidity::ItemContract">Item<wbr>Contract</a></dt><dd>A contract, abstract contract, interface, or library definition:
<code>contract Foo is Bar("foo"), Baz { ... }</code>.</dd><dt><a class="struct" href="struct.ItemEnum.html" title="struct syn_solidity::ItemEnum">Item<wbr>Enum</a></dt><dd>An enum definition: <code>enum Foo { A, B, C }</code>.</dd><dt><a class="struct" href="struct.ItemError.html" title="struct syn_solidity::ItemError">Item<wbr>Error</a></dt><dd>An error definition: <code>error Foo(uint256 a, uint256 b);</code>.</dd><dt><a class="struct" href="struct.ItemEvent.html" title="struct syn_solidity::ItemEvent">Item<wbr>Event</a></dt><dt><a class="struct" href="struct.ItemFunction.html" title="struct syn_solidity::ItemFunction">Item<wbr>Function</a></dt><dd>A function, constructor, fallback, receive, or modifier definition:
<code>function helloWorld() external pure returns(string memory);</code>.</dd><dt><a class="struct" href="struct.ItemStruct.html" title="struct syn_solidity::ItemStruct">Item<wbr>Struct</a></dt><dd>A struct definition: <code>struct Foo { uint256 bar; }</code>.</dd><dt><a class="struct" href="struct.ItemUdt.html" title="struct syn_solidity::ItemUdt">ItemUdt</a></dt><dd>A user-defined value type definition: <code>type Foo is uint256;</code>.</dd><dt><a class="struct" href="struct.LitDenominated.html" title="struct syn_solidity::LitDenominated">LitDenominated</a></dt><dt><a class="struct" href="struct.LitHexStr.html" title="struct syn_solidity::LitHexStr">LitHex<wbr>Str</a></dt><dt><a class="struct" href="struct.LitStr.html" title="struct syn_solidity::LitStr">LitStr</a></dt><dt><a class="struct" href="struct.LitUnicodeStr.html" title="struct syn_solidity::LitUnicodeStr">LitUnicode<wbr>Str</a></dt><dt><a class="struct" href="struct.Modifier.html" title="struct syn_solidity::Modifier">Modifier</a></dt><dd>A modifier invocation, or an inheritance specifier.</dd><dt><a class="struct" href="struct.NamedArg.html" title="struct syn_solidity::NamedArg">Named<wbr>Arg</a></dt><dd>A named argument in an argument list: <code>foo: uint256(42)</code>.</dd><dt><a class="struct" href="struct.NamedArgList.html" title="struct syn_solidity::NamedArgList">Named<wbr>ArgList</a></dt><dd>A named argument list: <code>{ foo: uint256(42), bar: true }</code>.</dd><dt><a class="struct" href="struct.Override.html" title="struct syn_solidity::Override">Override</a></dt><dd>The <code>override</code> attribute.</dd><dt><a class="struct" href="struct.Parameters.html" title="struct syn_solidity::Parameters">Parameters</a></dt><dd>A list of <a href="struct.VariableDeclaration.html" title="struct syn_solidity::VariableDeclaration">VariableDeclaration</a>s, separated by <code>P</code>.</dd><dt><a class="struct" href="struct.PragmaDirective.html" title="struct syn_solidity::PragmaDirective">Pragma<wbr>Directive</a></dt><dd>A pragma directive: <code>pragma solidity ^0.8.0;</code></dd><dt><a class="struct" href="struct.Returns.html" title="struct syn_solidity::Returns">Returns</a></dt><dd>The <code>returns</code> attribute of a function.</dd><dt><a class="struct" href="struct.SolIdent.html" title="struct syn_solidity::SolIdent">SolIdent</a></dt><dd>A Solidity identifier.</dd><dt><a class="struct" href="struct.SolPath.html" title="struct syn_solidity::SolPath">SolPath</a></dt><dd>A list of identifiers, separated by dots.</dd><dt><a class="struct" href="struct.StmtAssembly.html" title="struct syn_solidity::StmtAssembly">Stmt<wbr>Assembly</a></dt><dd>An assembly block, with optional flags: <code>assembly "evmasm" { ... }</code>.</dd><dt><a class="struct" href="struct.StmtBreak.html" title="struct syn_solidity::StmtBreak">Stmt<wbr>Break</a></dt><dd>A break statement: <code>break;</code>.</dd><dt><a class="struct" href="struct.StmtContinue.html" title="struct syn_solidity::StmtContinue">Stmt<wbr>Continue</a></dt><dd>A continue statement: <code>continue;</code>.</dd><dt><a class="struct" href="struct.StmtDoWhile.html" title="struct syn_solidity::StmtDoWhile">Stmt<wbr>DoWhile</a></dt><dd>A do-while statement: <code>do { ... } while (condition);</code>.</dd><dt><a class="struct" href="struct.StmtEmit.html" title="struct syn_solidity::StmtEmit">Stmt<wbr>Emit</a></dt><dd>An emit statement: <code>emit FooBar(42);</code>.</dd><dt><a class="struct" href="struct.StmtExpr.html" title="struct syn_solidity::StmtExpr">Stmt<wbr>Expr</a></dt><dd>An expression with a trailing semicolon.</dd><dt><a class="struct" href="struct.StmtFor.html" title="struct syn_solidity::StmtFor">StmtFor</a></dt><dd>A for statement: <code>for (uint256 i; i &lt; 42; ++i) { ... }</code>.</dd><dt><a class="struct" href="struct.StmtIf.html" title="struct syn_solidity::StmtIf">StmtIf</a></dt><dd>An <code>if</code> statement with an optional <code>else</code> block: <code>if (expr) { ... } else { ... }</code>.</dd><dt><a class="struct" href="struct.StmtReturn.html" title="struct syn_solidity::StmtReturn">Stmt<wbr>Return</a></dt><dd>A return statement: <code>return 42;</code>.</dd><dt><a class="struct" href="struct.StmtRevert.html" title="struct syn_solidity::StmtRevert">Stmt<wbr>Revert</a></dt><dd>A revert statement: <code>revert("error");</code>.</dd><dt><a class="struct" href="struct.StmtTry.html" title="struct syn_solidity::StmtTry">StmtTry</a></dt><dd>A try statement: <code>try fooBar(42) catch { ... }</code>.</dd><dt><a class="struct" href="struct.StmtVarDecl.html" title="struct syn_solidity::StmtVarDecl">Stmt<wbr>VarDecl</a></dt><dd>A variable declaration statement: <code>uint256 foo = 42;</code>.</dd><dt><a class="struct" href="struct.StmtWhile.html" title="struct syn_solidity::StmtWhile">Stmt<wbr>While</a></dt><dd>A while statement: <code>while (i &lt; 42) { ... }</code>.</dd><dt><a class="struct" href="struct.TypeArray.html" title="struct syn_solidity::TypeArray">Type<wbr>Array</a></dt><dd>An array type.</dd><dt><a class="struct" href="struct.TypeFunction.html" title="struct syn_solidity::TypeFunction">Type<wbr>Function</a></dt><dd>A function type: <code>function() returns (string memory)</code>.</dd><dt><a class="struct" href="struct.TypeMapping.html" title="struct syn_solidity::TypeMapping">Type<wbr>Mapping</a></dt><dd>A mapping type: <code>mapping(uint key =&gt; string value)</code></dd><dt><a class="struct" href="struct.TypeTuple.html" title="struct syn_solidity::TypeTuple">Type<wbr>Tuple</a></dt><dd>A tuple type.</dd><dt><a class="struct" href="struct.UncheckedBlock.html" title="struct syn_solidity::UncheckedBlock">Unchecked<wbr>Block</a></dt><dd>An unchecked block: <code>unchecked { ... }</code>.</dd><dt><a class="struct" href="struct.UnicodeStr.html" title="struct syn_solidity::UnicodeStr">Unicode<wbr>Str</a></dt><dd>A unicode string.</dd><dt><a class="struct" href="struct.UsingDirective.html" title="struct syn_solidity::UsingDirective">Using<wbr>Directive</a></dt><dd>A <code>using</code> directive: <code>using { A, B.mul as * } for uint256 global;</code>.</dd><dt><a class="struct" href="struct.UsingListItem.html" title="struct syn_solidity::UsingListItem">Using<wbr>List<wbr>Item</a></dt><dt><a class="struct" href="struct.VarDeclTuple.html" title="struct syn_solidity::VarDeclTuple">VarDecl<wbr>Tuple</a></dt><dd>A declaration of variables in a tuple: <code>(,,uint256 foo,string memory bar)</code>.</dd><dt><a class="struct" href="struct.VariableAttributes.html" title="struct syn_solidity::VariableAttributes">Variable<wbr>Attributes</a></dt><dd>A list of unique variable attributes.</dd><dt><a class="struct" href="struct.VariableDeclaration.html" title="struct syn_solidity::VariableDeclaration">Variable<wbr>Declaration</a></dt><dd>A variable declaration: <code>string memory hello</code>.</dd><dt><a class="struct" href="struct.VariableDefinition.html" title="struct syn_solidity::VariableDefinition">Variable<wbr>Definition</a></dt><dt><a class="struct" href="struct.Variant.html" title="struct syn_solidity::Variant">Variant</a></dt><dd>An enum variant.</dd><dt><a class="struct" href="struct.WalrusToken.html" title="struct syn_solidity::WalrusToken">Walrus<wbr>Token</a></dt><dd>Represents the walrus operator <code>:=</code>.</dd><dt><a class="struct" href="struct.YulBlock.html" title="struct syn_solidity::YulBlock">YulBlock</a></dt><dd>A Yul block contains <code>YulStmt</code> between curly braces.</dd><dt><a class="struct" href="struct.YulCaseBranch.html" title="struct syn_solidity::YulCaseBranch">YulCase<wbr>Branch</a></dt><dd>Represents a non-default case of a Yul switch statement.</dd><dt><a class="struct" href="struct.YulFnCall.html" title="struct syn_solidity::YulFnCall">YulFn<wbr>Call</a></dt><dd>Yul function call.</dd><dt><a class="struct" href="struct.YulFor.html" title="struct syn_solidity::YulFor">YulFor</a></dt><dd>Yul for loop e.g <code>for {let i := 0} lt(i,10) {i := add(i,1)} {mstore(i,7)}</code>.</dd><dt><a class="struct" href="struct.YulFunctionDef.html" title="struct syn_solidity::YulFunctionDef">YulFunction<wbr>Def</a></dt><dd>Yul function definition: <code>function f() -&gt; a, b { ... }</code>.</dd><dt><a class="struct" href="struct.YulIdent.html" title="struct syn_solidity::YulIdent">YulIdent</a></dt><dd>A Yul identifier.</dd><dt><a class="struct" href="struct.YulIf.html" title="struct syn_solidity::YulIf">YulIf</a></dt><dd>A Yul if statement: <code>if lt(a, b) { sstore(0, 1) }</code>.</dd><dt><a class="struct" href="struct.YulPath.html" title="struct syn_solidity::YulPath">YulPath</a></dt><dd>In inline assembly, only dot-less identifiers can be declared, but dotted
paths can reference declarations made outside the assembly block.</dd><dt><a class="struct" href="struct.YulReturns.html" title="struct syn_solidity::YulReturns">YulReturns</a></dt><dd>The return attribute of a Yul function definition.</dd><dt><a class="struct" href="struct.YulSwitch.html" title="struct syn_solidity::YulSwitch">YulSwitch</a></dt><dd>A Yul switch statement can consist of only a default-case or one
or more non-default cases optionally followed by a default-case.</dd><dt><a class="struct" href="struct.YulSwitchDefault.html" title="struct syn_solidity::YulSwitchDefault">YulSwitch<wbr>Default</a></dt><dd>Represents the default case of a Yul switch statement.</dd><dt><a class="struct" href="struct.YulVarAssign.html" title="struct syn_solidity::YulVarAssign">YulVar<wbr>Assign</a></dt><dd>Yul variable assignment. <code>x := 0</code> or <code>x, y := foo()</code>.
Assigning values to multiple variables requires a function call.</dd><dt><a class="struct" href="struct.YulVarDecl.html" title="struct syn_solidity::YulVarDecl">YulVar<wbr>Decl</a></dt><dd>Declares Yul variables, which may or may not have initial values. E.x.
<code>let x := 0</code>
<code>let x</code>
<code>let x, y := foo()</code>
<code>let x, y, z</code></dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.ArgListImpl.html" title="enum syn_solidity::ArgListImpl">ArgList<wbr>Impl</a></dt><dd>A list of either unnamed or named arguments.</dd><dt><a class="enum" href="enum.BinOp.html" title="enum syn_solidity::BinOp">BinOp</a></dt><dd>A binary operator: <code>+</code>, <code>+=</code>, <code>&amp;</code>.</dd><dt><a class="enum" href="enum.ContractKind.html" title="enum syn_solidity::ContractKind">Contract<wbr>Kind</a></dt><dd>The kind of contract.</dd><dt><a class="enum" href="enum.Expr.html" title="enum syn_solidity::Expr">Expr</a></dt><dd>An expression.</dd><dt><a class="enum" href="enum.ForInitStmt.html" title="enum syn_solidity::ForInitStmt">ForInit<wbr>Stmt</a></dt><dd>A for statement initializer.</dd><dt><a class="enum" href="enum.FunctionAttribute.html" title="enum syn_solidity::FunctionAttribute">Function<wbr>Attribute</a></dt><dd>A function attribute.</dd><dt><a class="enum" href="enum.FunctionBody.html" title="enum syn_solidity::FunctionBody">Function<wbr>Body</a></dt><dd>The body of a function.</dd><dt><a class="enum" href="enum.FunctionKind.html" title="enum syn_solidity::FunctionKind">Function<wbr>Kind</a></dt><dd>The kind of function.</dd><dt><a class="enum" href="enum.ImportPath.html" title="enum syn_solidity::ImportPath">Import<wbr>Path</a></dt><dd>The path of an import directive.</dd><dt><a class="enum" href="enum.Item.html" title="enum syn_solidity::Item">Item</a></dt><dd>An AST item. A more expanded version of a <a href="https://docs.soliditylang.org/en/latest/grammar.html#a4.SolidityParser.sourceUnit">Solidity source unit</a>.</dd><dt><a class="enum" href="enum.Lit.html" title="enum syn_solidity::Lit">Lit</a></dt><dd>A Solidity literal such as a string or integer or boolean.</dd><dt><a class="enum" href="enum.LitNumber.html" title="enum syn_solidity::LitNumber">LitNumber</a></dt><dd>An integer or fixed-point number literal: <code>1</code> or <code>1.0</code>.</dd><dt><a class="enum" href="enum.Mutability.html" title="enum syn_solidity::Mutability">Mutability</a></dt><dd>A mutability attribute.</dd><dt><a class="enum" href="enum.PostUnOp.html" title="enum syn_solidity::PostUnOp">Post<wbr>UnOp</a></dt><dd>Postfix unary operators.</dd><dt><a class="enum" href="enum.PragmaTokens.html" title="enum syn_solidity::PragmaTokens">Pragma<wbr>Tokens</a></dt><dt><a class="enum" href="enum.Stmt.html" title="enum syn_solidity::Stmt">Stmt</a></dt><dd>A statement, usually ending in a semicolon.</dd><dt><a class="enum" href="enum.Storage.html" title="enum syn_solidity::Storage">Storage</a></dt><dd>A storage location.</dd><dt><a class="enum" href="enum.SubDenomination.html" title="enum syn_solidity::SubDenomination">SubDenomination</a></dt><dd>A sub-denomination suffix for a number literal.</dd><dt><a class="enum" href="enum.Type.html" title="enum syn_solidity::Type">Type</a></dt><dd>A type name.</dd><dt><a class="enum" href="enum.UnOp.html" title="enum syn_solidity::UnOp">UnOp</a></dt><dd>Unary operators.</dd><dt><a class="enum" href="enum.UserDefinableOperator.html" title="enum syn_solidity::UserDefinableOperator">User<wbr>Definable<wbr>Operator</a></dt><dd>A user-definable operator: <code>+</code>, <code>*</code>, <code>|</code>, etc.</dd><dt><a class="enum" href="enum.UsingList.html" title="enum syn_solidity::UsingList">Using<wbr>List</a></dt><dt><a class="enum" href="enum.UsingType.html" title="enum syn_solidity::UsingType">Using<wbr>Type</a></dt><dt><a class="enum" href="enum.VarDeclDecl.html" title="enum syn_solidity::VarDeclDecl">VarDecl<wbr>Decl</a></dt><dd>The declaration of the variable(s) in a variable declaration statement.</dd><dt><a class="enum" href="enum.VariableAttribute.html" title="enum syn_solidity::VariableAttribute">Variable<wbr>Attribute</a></dt><dd>A variable attribute.</dd><dt><a class="enum" href="enum.Visibility.html" title="enum syn_solidity::Visibility">Visibility</a></dt><dd>A visibility attribute.</dd><dt><a class="enum" href="enum.YulEVMBuiltIn.html" title="enum syn_solidity::YulEVMBuiltIn">YulEVM<wbr>Built<wbr>In</a></dt><dd>Representation of an EVM builtin opcode.</dd><dt><a class="enum" href="enum.YulExpr.html" title="enum syn_solidity::YulExpr">YulExpr</a></dt><dd>A Yul expression.</dd><dt><a class="enum" href="enum.YulFnType.html" title="enum syn_solidity::YulFnType">YulFn<wbr>Type</a></dt><dd>What type of function is called.</dd><dt><a class="enum" href="enum.YulStmt.html" title="enum syn_solidity::YulStmt">YulStmt</a></dt><dd>A Yul statement.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.parse.html" title="fn syn_solidity::parse">parse</a></dt><dd>Parse a Solidity <a href="https://doc.rust-lang.org/1.86.0/proc_macro/struct.TokenStream.html" title="struct proc_macro::TokenStream"><code>proc_macro::TokenStream</code></a> into a <a href="struct.File.html" title="struct syn_solidity::File"><code>File</code></a>.</dd><dt><a class="fn" href="fn.parse2.html" title="fn syn_solidity::parse2">parse2</a></dt><dd>Parse a Solidity <a href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream"><code>proc_macro2::TokenStream</code></a> into a <a href="struct.File.html" title="struct syn_solidity::File"><code>File</code></a>.</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><dl class="item-table"><dt><a class="type" href="type.FieldList.html" title="type syn_solidity::FieldList">Field<wbr>List</a></dt><dd>A list of semicolon-separated <a href="struct.VariableDeclaration.html" title="struct syn_solidity::VariableDeclaration">VariableDeclaration</a>s.</dd><dt><a class="type" href="type.ParameterList.html" title="type syn_solidity::ParameterList">Parameter<wbr>List</a></dt><dd>A list of comma-separated <a href="struct.VariableDeclaration.html" title="struct syn_solidity::VariableDeclaration">VariableDeclaration</a>s.</dd></dl></section></div></main></body></html>
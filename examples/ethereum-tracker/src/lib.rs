// Copyright (c) Zefchain Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

/*!
A Linera application that reads events emitted by the `simple_token.sol` example from
`linera-ethereum` and tracks the balances. This shows how Wasm contracts on Linera can
consume information generated by EVM contracts on Ethereum.
*/

use alloy_primitives::U256;
use async_graphql::{scalar, Request, Response, SimpleObject};
use linera_sdk::{
    graphql::GraphQLMutationRoot,
    linera_base_types::{ContractAbi, ServiceAbi},
};
use serde::{Deserialize, Serialize};
pub struct EthereumTrackerAbi;

impl ContractAbi for EthereumTrackerAbi {
    type Operation = Operation;
    type Response = ();
}

impl ServiceAbi for EthereumTrackerAbi {
    type Query = Request;
    type QueryResponse = Response;
}

/// The possible operation for the node
#[derive(Debug, Deserialize, Serialize, GraphQLMutationRoot)]
pub enum Operation {
    /// Update the database by querying an Ethereum node
    /// up to an exclusive block number
    Update { to_block: u64 },
}

/// The instantiation argument used for the contract.
#[derive(Clone, Debug, Default, Deserialize, Serialize, SimpleObject)]
pub struct InstantiationArgument {
    /// The Ethereum endpoint being used
    pub ethereum_endpoint: String,
    /// The address of the contract
    pub contract_address: String,
    /// The block height at which the EVM contract was created
    pub start_block: u64,
}

#[derive(Clone, Default, Deserialize, Serialize)]
pub struct U256Cont {
    pub value: U256,
}
scalar!(U256Cont);

impl From<U256> for U256Cont {
    fn from(value: U256) -> Self {
        U256Cont { value }
    }
}

#[cfg(not(target_arch = "wasm32"))]
pub mod formats {
    use linera_sdk::formats::{BcsApplication, Formats};
    use serde_reflection::{Samples, Tracer, TracerConfig};

    use super::{EthereumTrackerAbi, InstantiationArgument, Operation};

    /// The EthereumTracker application.
    pub struct EthereumTrackerApplication;

    impl BcsApplication for EthereumTrackerApplication {
        type Abi = EthereumTrackerAbi;

        fn formats() -> serde_reflection::Result<Formats> {
            let mut tracer = Tracer::new(
                TracerConfig::default()
                    .record_samples_for_newtype_structs(true)
                    .record_samples_for_tuple_structs(true),
            );
            let samples = Samples::new();

            // Trace the ABI types
            let (operation, _) = tracer.trace_type::<Operation>(&samples)?;
            let (response, _) = tracer.trace_type::<()>(&samples)?;
            let (message, _) = tracer.trace_type::<()>(&samples)?;
            let (event_value, _) = tracer.trace_type::<()>(&samples)?;

            // Trace additional supporting types (notably all enums) to populate the registry
            tracer.trace_type::<InstantiationArgument>(&samples)?;

            let registry = tracer.registry()?;

            Ok(Formats {
                registry,
                operation,
                response,
                message,
                event_value,
            })
        }
    }
}

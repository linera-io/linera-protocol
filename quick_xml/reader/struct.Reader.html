<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A low level encoding-agnostic XML event reader."><title>Reader in quick_xml::reader - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-6c3ea77c.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="quick_xml" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0 (05f9846f8 2025-03-31)" data-channel="1.86.0" data-search-js="search-581efc7a.js" data-settings-js="settings-6dad6058.js" ><script src="../../static.files/storage-3a5871a4.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-4d63596a.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../quick_xml/index.html">quick_<wbr>xml</a><span class="version">0.37.5</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Reader</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#examples" title="Examples">Examples</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.buffer_position" title="buffer_position">buffer_position</a></li><li><a href="#method.config" title="config">config</a></li><li><a href="#method.config_mut" title="config_mut">config_mut</a></li><li><a href="#method.decoder" title="decoder">decoder</a></li><li><a href="#method.error_position" title="error_position">error_position</a></li><li><a href="#method.from_file" title="from_file">from_file</a></li><li><a href="#method.from_reader" title="from_reader">from_reader</a></li><li><a href="#method.from_str" title="from_str">from_str</a></li><li><a href="#method.get_mut" title="get_mut">get_mut</a></li><li><a href="#method.get_ref" title="get_ref">get_ref</a></li><li><a href="#method.into_inner" title="into_inner">into_inner</a></li><li><a href="#method.read_event" title="read_event">read_event</a></li><li><a href="#method.read_event_into" title="read_event_into">read_event_into</a></li><li><a href="#method.read_text" title="read_text">read_text</a></li><li><a href="#method.read_to_end" title="read_to_end">read_to_end</a></li><li><a href="#method.read_to_end_into" title="read_to_end_into">read_to_end_into</a></li><li><a href="#method.stream" title="stream">stream</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Clone-for-Reader%3CR%3E" title="Clone">Clone</a></li><li><a href="#impl-Debug-for-Reader%3CR%3E" title="Debug">Debug</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-Reader%3CR%3E" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-Reader%3CR%3E" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send-for-Reader%3CR%3E" title="Send">Send</a></li><li><a href="#impl-Sync-for-Reader%3CR%3E" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-Reader%3CR%3E" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-Reader%3CR%3E" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-ToOwned-for-T" title="ToOwned">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In quick_<wbr>xml::<wbr>reader</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">quick_xml</a>::<wbr><a href="index.html">reader</a></div><h1>Struct <span class="struct">Reader</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/quick_xml/reader/mod.rs.html#687-692">Source</a> </span></div><pre class="rust item-decl"><code>pub struct Reader&lt;R&gt; { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A low level encoding-agnostic XML event reader.</p>
<p>Consumes bytes and streams XML <a href="../events/enum.Event.html" title="enum quick_xml::events::Event"><code>Event</code></a>s.</p>
<p>This reader does not manage namespace declarations and not able to resolve
prefixes. If you want these features, use the <a href="struct.NsReader.html" title="struct quick_xml::reader::NsReader"><code>NsReader</code></a>.</p>
<h2 id="examples"><a class="doc-anchor" href="#examples">ยง</a>Examples</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>quick_xml::events::Event;
<span class="kw">use </span>quick_xml::reader::Reader;

<span class="kw">let </span>xml = <span class="string">r#"&lt;tag1 att1 = "test"&gt;
                &lt;tag2&gt;&lt;!--Test comment--&gt;Test&lt;/tag2&gt;
                &lt;tag2&gt;Test 2&lt;/tag2&gt;
             &lt;/tag1&gt;"#</span>;
<span class="kw">let </span><span class="kw-2">mut </span>reader = Reader::from_str(xml);
reader.config_mut().trim_text(<span class="bool-val">true</span>);

<span class="kw">let </span><span class="kw-2">mut </span>count = <span class="number">0</span>;
<span class="kw">let </span><span class="kw-2">mut </span>txt = Vec::new();
<span class="kw">let </span><span class="kw-2">mut </span>buf = Vec::new();

<span class="comment">// The `Reader` does not implement `Iterator` because it outputs borrowed data (`Cow`s)
</span><span class="kw">loop </span>{
    <span class="comment">// NOTE: this is the generic case when we don't know about the input BufRead.
    // when the input is a &amp;str or a &amp;[u8], we don't actually need to use another
    // buffer, we could directly call `reader.read_event()`
    </span><span class="kw">match </span>reader.read_event_into(<span class="kw-2">&amp;mut </span>buf) {
        <span class="prelude-val">Err</span>(e) =&gt; <span class="macro">panic!</span>(<span class="string">"Error at position {}: {:?}"</span>, reader.error_position(), e),
        <span class="comment">// exits the loop when reaching end of file
        </span><span class="prelude-val">Ok</span>(Event::Eof) =&gt; <span class="kw">break</span>,

        <span class="prelude-val">Ok</span>(Event::Start(e)) =&gt; {
            <span class="kw">match </span>e.name().as_ref() {
                <span class="string">b"tag1" </span>=&gt; <span class="macro">println!</span>(<span class="string">"attributes values: {:?}"</span>,
                                    e.attributes().map(|a| a.unwrap().value)
                                    .collect::&lt;Vec&lt;<span class="kw">_</span>&gt;&gt;()),
                <span class="string">b"tag2" </span>=&gt; count += <span class="number">1</span>,
                <span class="kw">_ </span>=&gt; (),
            }
        }
        <span class="prelude-val">Ok</span>(Event::Text(e)) =&gt; txt.push(e.unescape().unwrap().into_owned()),

        <span class="comment">// There are several other `Event`s we do not consider here
        </span><span class="kw">_ </span>=&gt; (),
    }
    <span class="comment">// if we don't keep a borrow elsewhere, we can clear the buffer to keep memory usage low
    </span>buf.clear();
}</code></pre></div>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">ยง</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Reader%3CR%3E" class="impl"><a class="src rightside" href="../../src/quick_xml/reader/buffered_reader.rs.html#247-390">Source</a><a href="#impl-Reader%3CR%3E" class="anchor">ยง</a><h3 class="code-header">impl&lt;R: <a class="trait" href="https://doc.rust-lang.org/1.86.0/std/io/trait.BufRead.html" title="trait std::io::BufRead">BufRead</a>&gt; <a class="struct" href="struct.Reader.html" title="struct quick_xml::reader::Reader">Reader</a>&lt;R&gt;</h3><div class="docblock"><p>This is an implementation for reading from a <a href="https://doc.rust-lang.org/1.86.0/std/io/trait.BufRead.html" title="trait std::io::BufRead"><code>BufRead</code></a> as underlying byte stream.</p>
</div></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.read_event_into" class="method"><a class="src rightside" href="../../src/quick_xml/reader/buffered_reader.rs.html#293-295">Source</a><h4 class="code-header">pub fn <a href="#method.read_event_into" class="fn">read_event_into</a>&lt;'b&gt;(&amp;mut self, buf: &amp;'b mut <a class="struct" href="https://doc.rust-lang.org/1.86.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.86.0/std/primitive.u8.html">u8</a>&gt;) -&gt; <a class="type" href="../errors/type.Result.html" title="type quick_xml::errors::Result">Result</a>&lt;<a class="enum" href="../events/enum.Event.html" title="enum quick_xml::events::Event">Event</a>&lt;'b&gt;&gt;</h4></section></summary><div class="docblock"><p>Reads the next <code>Event</code>.</p>
<p>This is the main entry point for reading XML <code>Event</code>s.</p>
<p><code>Event</code>s borrow <code>buf</code> and can be converted to own their data if needed (uses <code>Cow</code>
internally).</p>
<p>Having the possibility to control the internal buffers gives you some additional benefits
such as:</p>
<ul>
<li>Reduce the number of allocations by reusing the same buffer. For constrained systems,
you can call <code>buf.clear()</code> once you are done with processing the event (typically at the
end of your loop).</li>
<li>Reserve the buffer length if you know the file size (using <code>Vec::with_capacity</code>).</li>
</ul>
<h5 id="examples-1"><a class="doc-anchor" href="#examples-1">ยง</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>quick_xml::events::Event;
<span class="kw">use </span>quick_xml::reader::Reader;

<span class="kw">let </span>xml = <span class="string">r#"&lt;tag1 att1 = "test"&gt;
                &lt;tag2&gt;&lt;!--Test comment--&gt;Test&lt;/tag2&gt;
                &lt;tag2&gt;Test 2&lt;/tag2&gt;
             &lt;/tag1&gt;"#</span>;
<span class="kw">let </span><span class="kw-2">mut </span>reader = Reader::from_str(xml);
reader.config_mut().trim_text(<span class="bool-val">true</span>);
<span class="kw">let </span><span class="kw-2">mut </span>count = <span class="number">0</span>;
<span class="kw">let </span><span class="kw-2">mut </span>buf = Vec::new();
<span class="kw">let </span><span class="kw-2">mut </span>txt = Vec::new();
<span class="kw">loop </span>{
    <span class="kw">match </span>reader.read_event_into(<span class="kw-2">&amp;mut </span>buf) {
        <span class="prelude-val">Ok</span>(Event::Start(<span class="kw">_</span>)) =&gt; count += <span class="number">1</span>,
        <span class="prelude-val">Ok</span>(Event::Text(e)) =&gt; txt.push(e.unescape().unwrap().into_owned()),
        <span class="prelude-val">Err</span>(e) =&gt; <span class="macro">panic!</span>(<span class="string">"Error at position {}: {:?}"</span>, reader.error_position(), e),
        <span class="prelude-val">Ok</span>(Event::Eof) =&gt; <span class="kw">break</span>,
        <span class="kw">_ </span>=&gt; (),
    }
    buf.clear();
}
<span class="macro">assert_eq!</span>(count, <span class="number">3</span>);
<span class="macro">assert_eq!</span>(txt, <span class="macro">vec!</span>[<span class="string">"Test"</span>.to_string(), <span class="string">"Test 2"</span>.to_string()]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read_to_end_into" class="method"><a class="src rightside" href="../../src/quick_xml/reader/buffered_reader.rs.html#385-389">Source</a><h4 class="code-header">pub fn <a href="#method.read_to_end_into" class="fn">read_to_end_into</a>(
    &amp;mut self,
    end: <a class="struct" href="../name/struct.QName.html" title="struct quick_xml::name::QName">QName</a>&lt;'_&gt;,
    buf: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.86.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.86.0/std/primitive.u8.html">u8</a>&gt;,
) -&gt; <a class="type" href="../errors/type.Result.html" title="type quick_xml::errors::Result">Result</a>&lt;<a class="type" href="type.Span.html" title="type quick_xml::reader::Span">Span</a>&gt;</h4></section></summary><div class="docblock"><p>Reads until end element is found using provided buffer as intermediate
storage for events content. This function is supposed to be called after
you already read a <a href="../events/enum.Event.html#variant.Start" title="variant quick_xml::events::Event::Start"><code>Start</code></a> event.</p>
<p>Returns a span that cover content between <code>&gt;</code> of an opening tag and <code>&lt;</code> of
a closing tag or an empty slice, if <a href="struct.Config.html#structfield.expand_empty_elements" title="field quick_xml::reader::Config::expand_empty_elements"><code>expand_empty_elements</code></a> is set and
this method was called after reading expanded <a href="../events/enum.Event.html#variant.Start" title="variant quick_xml::events::Event::Start"><code>Start</code></a> event.</p>
<p>Manages nested cases where parent and child elements have the <em>literally</em>
same name.</p>
<p>If a corresponding <a href="../events/enum.Event.html#variant.End" title="variant quick_xml::events::Event::End"><code>End</code></a> event is not found, an error of type <a href="../errors/enum.Error.html#variant.IllFormed" title="variant quick_xml::errors::Error::IllFormed"><code>Error::IllFormed</code></a>
will be returned. In particularly, that error will be returned if you call
this method without consuming the corresponding <a href="../events/enum.Event.html#variant.Start" title="variant quick_xml::events::Event::Start"><code>Start</code></a> event first.</p>
<p>If your reader created from a string slice or byte array slice, it is
better to use <a href="struct.Reader.html#method.read_to_end" title="method quick_xml::reader::Reader::read_to_end"><code>read_to_end()</code></a> method, because it will not copy bytes
into intermediate buffer.</p>
<p>The provided <code>buf</code> buffer will be filled only by one event content at time.
Before reading of each event the buffer will be cleared. If you know an
appropriate size of each event, you can preallocate the buffer to reduce
number of reallocations.</p>
<p>The <code>end</code> parameter should contain name of the end element <em>in the reader
encoding</em>. It is good practice to always get that parameter using
<a href="../events/struct.BytesStart.html#method.to_end" title="method quick_xml::events::BytesStart::to_end"><code>BytesStart::to_end()</code></a> method.</p>
<p>The correctness of the skipped events does not checked, if you disabled
the <a href="struct.Config.html#structfield.check_end_names" title="field quick_xml::reader::Config::check_end_names"><code>check_end_names</code></a> option.</p>
<h5 id="namespaces"><a class="doc-anchor" href="#namespaces">ยง</a>Namespaces</h5>
<p>While the <code>Reader</code> does not support namespace resolution, namespaces
does not change the algorithm for comparing names. Although the names
<code>a:name</code> and <code>b:name</code> where both prefixes <code>a</code> and <code>b</code> resolves to the
same namespace, are semantically equivalent, <code>&lt;/b:name&gt;</code> cannot close
<code>&lt;a:name&gt;</code>, because according to <a href="https://www.w3.org/TR/xml11/#dt-etag">the specification</a></p>
<blockquote>
<p>The end of every element that begins with a <strong>start-tag</strong> MUST be marked
by an <strong>end-tag</strong> containing a name that echoes the elementโs type as
given in the <strong>start-tag</strong></p>
</blockquote>
<h5 id="examples-2"><a class="doc-anchor" href="#examples-2">ยง</a>Examples</h5>
<p>This example shows, how you can skip XML content after you read the
start event.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>quick_xml::events::{BytesStart, Event};
<span class="kw">use </span>quick_xml::reader::Reader;

<span class="kw">let </span><span class="kw-2">mut </span>reader = Reader::from_str(<span class="string">r#"
    &lt;outer&gt;
        &lt;inner&gt;
            &lt;inner&gt;&lt;/inner&gt;
            &lt;inner/&gt;
            &lt;outer&gt;&lt;/outer&gt;
            &lt;outer/&gt;
        &lt;/inner&gt;
    &lt;/outer&gt;
"#</span>);
reader.config_mut().trim_text(<span class="bool-val">true</span>);
<span class="kw">let </span><span class="kw-2">mut </span>buf = Vec::new();

<span class="kw">let </span>start = BytesStart::new(<span class="string">"outer"</span>);
<span class="kw">let </span>end   = start.to_end().into_owned();

<span class="comment">// First, we read a start event...
</span><span class="macro">assert_eq!</span>(reader.read_event_into(<span class="kw-2">&amp;mut </span>buf).unwrap(), Event::Start(start));

<span class="comment">// ...then, we could skip all events to the corresponding end event.
// This call will correctly handle nested &lt;outer&gt; elements.
// Note, however, that this method does not handle namespaces.
</span>reader.read_to_end_into(end.name(), <span class="kw-2">&amp;mut </span>buf).unwrap();

<span class="comment">// At the end we should get an Eof event, because we ate the whole XML
</span><span class="macro">assert_eq!</span>(reader.read_event_into(<span class="kw-2">&amp;mut </span>buf).unwrap(), Event::Eof);</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Reader%3CBufReader%3CFile%3E%3E" class="impl"><a class="src rightside" href="../../src/quick_xml/reader/buffered_reader.rs.html#392-399">Source</a><a href="#impl-Reader%3CBufReader%3CFile%3E%3E" class="anchor">ยง</a><h3 class="code-header">impl <a class="struct" href="struct.Reader.html" title="struct quick_xml::reader::Reader">Reader</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.86.0/std/io/buffered/bufreader/struct.BufReader.html" title="struct std::io::buffered::bufreader::BufReader">BufReader</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.86.0/std/fs/struct.File.html" title="struct std::fs::File">File</a>&gt;&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_file" class="method"><a class="src rightside" href="../../src/quick_xml/reader/buffered_reader.rs.html#394-398">Source</a><h4 class="code-header">pub fn <a href="#method.from_file" class="fn">from_file</a>&lt;P: <a class="trait" href="https://doc.rust-lang.org/1.86.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.86.0/std/path/struct.Path.html" title="struct std::path::Path">Path</a>&gt;&gt;(path: P) -&gt; <a class="type" href="../errors/type.Result.html" title="type quick_xml::errors::Result">Result</a>&lt;Self&gt;</h4></section></summary><div class="docblock"><p>Creates an XML reader from a file path.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Reader%3C%26%5Bu8%5D%3E" class="impl"><a class="src rightside" href="../../src/quick_xml/reader/slice_reader.rs.html#23-238">Source</a><a href="#impl-Reader%3C%26%5Bu8%5D%3E" class="anchor">ยง</a><h3 class="code-header">impl&lt;'a&gt; <a class="struct" href="struct.Reader.html" title="struct quick_xml::reader::Reader">Reader</a>&lt;&amp;'a [<a class="primitive" href="https://doc.rust-lang.org/1.86.0/std/primitive.u8.html">u8</a>]&gt;</h3><div class="docblock"><p>This is an implementation for reading from a <code>&amp;[u8]</code> as underlying byte stream.
This implementation supports not using an intermediate buffer as the byte slice
itself can be used to borrow from.</p>
</div></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_str" class="method"><a class="src rightside" href="../../src/quick_xml/reader/slice_reader.rs.html#26-37">Source</a><h4 class="code-header">pub fn <a href="#method.from_str" class="fn">from_str</a>(s: &amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.86.0/std/primitive.str.html">str</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates an XML reader from a string slice.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read_event" class="method"><a class="src rightside" href="../../src/quick_xml/reader/slice_reader.rs.html#74-76">Source</a><h4 class="code-header">pub fn <a href="#method.read_event" class="fn">read_event</a>(&amp;mut self) -&gt; <a class="type" href="../errors/type.Result.html" title="type quick_xml::errors::Result">Result</a>&lt;<a class="enum" href="../events/enum.Event.html" title="enum quick_xml::events::Event">Event</a>&lt;'a&gt;&gt;</h4></section></summary><div class="docblock"><p>Read an event that borrows from the input rather than a buffer.</p>
<p>There is no asynchronous <code>read_event_async()</code> version of this function,
because it is not necessary โ the contents are already in memory and no IO
is needed, therefore there is no potential for blocking.</p>
<h5 id="examples-3"><a class="doc-anchor" href="#examples-3">ยง</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>quick_xml::events::Event;
<span class="kw">use </span>quick_xml::reader::Reader;

<span class="kw">let </span><span class="kw-2">mut </span>reader = Reader::from_str(<span class="string">r#"
    &lt;tag1 att1 = "test"&gt;
       &lt;tag2&gt;&lt;!--Test comment--&gt;Test&lt;/tag2&gt;
       &lt;tag2&gt;Test 2&lt;/tag2&gt;
    &lt;/tag1&gt;
"#</span>);
reader.config_mut().trim_text(<span class="bool-val">true</span>);

<span class="kw">let </span><span class="kw-2">mut </span>count = <span class="number">0</span>;
<span class="kw">let </span><span class="kw-2">mut </span>txt = Vec::new();
<span class="kw">loop </span>{
    <span class="kw">match </span>reader.read_event().unwrap() {
        Event::Start(e) =&gt; count += <span class="number">1</span>,
        Event::Text(e) =&gt; txt.push(e.unescape().unwrap().into_owned()),
        Event::Eof =&gt; <span class="kw">break</span>,
        <span class="kw">_ </span>=&gt; (),
    }
}
<span class="macro">assert_eq!</span>(count, <span class="number">3</span>);
<span class="macro">assert_eq!</span>(txt, <span class="macro">vec!</span>[<span class="string">"Test"</span>.to_string(), <span class="string">"Test 2"</span>.to_string()]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read_to_end" class="method"><a class="src rightside" href="../../src/quick_xml/reader/slice_reader.rs.html#158-160">Source</a><h4 class="code-header">pub fn <a href="#method.read_to_end" class="fn">read_to_end</a>(&amp;mut self, end: <a class="struct" href="../name/struct.QName.html" title="struct quick_xml::name::QName">QName</a>&lt;'_&gt;) -&gt; <a class="type" href="../errors/type.Result.html" title="type quick_xml::errors::Result">Result</a>&lt;<a class="type" href="type.Span.html" title="type quick_xml::reader::Span">Span</a>&gt;</h4></section></summary><div class="docblock"><p>Reads until end element is found. This function is supposed to be called
after you already read a <a href="../events/enum.Event.html#variant.Start" title="variant quick_xml::events::Event::Start"><code>Start</code></a> event.</p>
<p>Returns a span that cover content between <code>&gt;</code> of an opening tag and <code>&lt;</code> of
a closing tag or an empty slice, if <a href="struct.Config.html#structfield.expand_empty_elements" title="field quick_xml::reader::Config::expand_empty_elements"><code>expand_empty_elements</code></a> is set and
this method was called after reading expanded <a href="../events/enum.Event.html#variant.Start" title="variant quick_xml::events::Event::Start"><code>Start</code></a> event.</p>
<p>Manages nested cases where parent and child elements have the <em>literally</em>
same name.</p>
<p>If a corresponding <a href="../events/enum.Event.html#variant.End" title="variant quick_xml::events::Event::End"><code>End</code></a> event is not found, an error of type <a href="../errors/enum.Error.html#variant.IllFormed" title="variant quick_xml::errors::Error::IllFormed"><code>Error::IllFormed</code></a>
will be returned. In particularly, that error will be returned if you call
this method without consuming the corresponding <a href="../events/enum.Event.html#variant.Start" title="variant quick_xml::events::Event::Start"><code>Start</code></a> event first.</p>
<p>The <code>end</code> parameter should contain name of the end element <em>in the reader
encoding</em>. It is good practice to always get that parameter using
<a href="../events/struct.BytesStart.html#method.to_end" title="method quick_xml::events::BytesStart::to_end"><code>BytesStart::to_end()</code></a> method.</p>
<p>The correctness of the skipped events does not checked, if you disabled
the <a href="struct.Config.html#structfield.check_end_names" title="field quick_xml::reader::Config::check_end_names"><code>check_end_names</code></a> option.</p>
<p>There is no asynchronous <code>read_to_end_async()</code> version of this function,
because it is not necessary โ the contents are already in memory and no IO
is needed, therefore there is no potential for blocking.</p>
<h5 id="namespaces-1"><a class="doc-anchor" href="#namespaces-1">ยง</a>Namespaces</h5>
<p>While the <code>Reader</code> does not support namespace resolution, namespaces
does not change the algorithm for comparing names. Although the names
<code>a:name</code> and <code>b:name</code> where both prefixes <code>a</code> and <code>b</code> resolves to the
same namespace, are semantically equivalent, <code>&lt;/b:name&gt;</code> cannot close
<code>&lt;a:name&gt;</code>, because according to <a href="https://www.w3.org/TR/xml11/#dt-etag">the specification</a></p>
<blockquote>
<p>The end of every element that begins with a <strong>start-tag</strong> MUST be marked
by an <strong>end-tag</strong> containing a name that echoes the elementโs type as
given in the <strong>start-tag</strong></p>
</blockquote>
<h5 id="examples-4"><a class="doc-anchor" href="#examples-4">ยง</a>Examples</h5>
<p>This example shows, how you can skip XML content after you read the
start event.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>quick_xml::events::{BytesStart, Event};
<span class="kw">use </span>quick_xml::reader::Reader;

<span class="kw">let </span><span class="kw-2">mut </span>reader = Reader::from_str(<span class="string">r#"
    &lt;outer&gt;
        &lt;inner&gt;
            &lt;inner&gt;&lt;/inner&gt;
            &lt;inner/&gt;
            &lt;outer&gt;&lt;/outer&gt;
            &lt;outer/&gt;
        &lt;/inner&gt;
    &lt;/outer&gt;
"#</span>);
reader.config_mut().trim_text(<span class="bool-val">true</span>);

<span class="kw">let </span>start = BytesStart::new(<span class="string">"outer"</span>);
<span class="kw">let </span>end   = start.to_end().into_owned();

<span class="comment">// First, we read a start event...
</span><span class="macro">assert_eq!</span>(reader.read_event().unwrap(), Event::Start(start));

<span class="comment">// ...then, we could skip all events to the corresponding end event.
// This call will correctly handle nested &lt;outer&gt; elements.
// Note, however, that this method does not handle namespaces.
</span>reader.read_to_end(end.name()).unwrap();

<span class="comment">// At the end we should get an Eof event, because we ate the whole XML
</span><span class="macro">assert_eq!</span>(reader.read_event().unwrap(), Event::Eof);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read_text" class="method"><a class="src rightside" href="../../src/quick_xml/reader/slice_reader.rs.html#228-237">Source</a><h4 class="code-header">pub fn <a href="#method.read_text" class="fn">read_text</a>(&amp;mut self, end: <a class="struct" href="../name/struct.QName.html" title="struct quick_xml::name::QName">QName</a>&lt;'_&gt;) -&gt; <a class="type" href="../errors/type.Result.html" title="type quick_xml::errors::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.86.0/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="https://doc.rust-lang.org/1.86.0/std/primitive.str.html">str</a>&gt;&gt;</h4></section></summary><div class="docblock"><p>Reads content between start and end tags, including any markup. This
function is supposed to be called after you already read a <a href="../events/enum.Event.html#variant.Start" title="variant quick_xml::events::Event::Start"><code>Start</code></a> event.</p>
<p>Manages nested cases where parent and child elements have the <em>literally</em>
same name.</p>
<p>This method does not unescape read data, instead it returns content
โas isโ of the XML document. This is because it has no idea what text
it reads, and if, for example, it contains CDATA section, attempt to
unescape it content will spoil data.</p>
<p>Any text will be decoded using the XML current <a href="struct.Reader.html#method.decoder" title="method quick_xml::reader::Reader::decoder"><code>decoder()</code></a>.</p>
<p>Actually, this method perform the following code:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">โ</a><pre class="rust rust-example-rendered"><code><span class="kw">let </span>span = reader.read_to_end(end)<span class="question-mark">?</span>;
<span class="kw">let </span>text = reader.decoder().decode(<span class="kw-2">&amp;</span>reader.inner_slice[span]);</code></pre></div>
<h5 id="examples-5"><a class="doc-anchor" href="#examples-5">ยง</a>Examples</h5>
<p>This example shows, how you can read a HTML content from your XML document.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>quick_xml::events::{BytesStart, Event};
<span class="kw">use </span>quick_xml::reader::Reader;

<span class="kw">let </span><span class="kw-2">mut </span>reader = Reader::from_str(<span class="string">"
    &lt;html&gt;
        &lt;title&gt;This is a HTML text&lt;/title&gt;
        &lt;p&gt;Usual XML rules does not apply inside it
        &lt;p&gt;For example, elements not needed to be &amp;quot;closed&amp;quot;
    &lt;/html&gt;
"</span>);
reader.config_mut().trim_text(<span class="bool-val">true</span>);

<span class="kw">let </span>start = BytesStart::new(<span class="string">"html"</span>);
<span class="kw">let </span>end   = start.to_end().into_owned();

<span class="comment">// First, we read a start event...
</span><span class="macro">assert_eq!</span>(reader.read_event().unwrap(), Event::Start(start));
<span class="comment">// ...and disable checking of end names because we expect HTML further...
</span>reader.config_mut().check_end_names = <span class="bool-val">false</span>;

<span class="comment">// ...then, we could read text content until close tag.
// This call will correctly handle nested &lt;html&gt; elements.
</span><span class="kw">let </span>text = reader.read_text(end.name()).unwrap();
<span class="macro">assert_eq!</span>(text, Cow::Borrowed(<span class="string">r#"
        &lt;title&gt;This is a HTML text&lt;/title&gt;
        &lt;p&gt;Usual XML rules does not apply inside it
        &lt;p&gt;For example, elements not needed to be &amp;quot;closed&amp;quot;
    "#</span>));
<span class="macro">assert!</span>(<span class="macro">matches!</span>(text, Cow::Borrowed(<span class="kw">_</span>)));

<span class="comment">// Now we can enable checks again
</span>reader.config_mut().check_end_names = <span class="bool-val">true</span>;

<span class="comment">// At the end we should get an Eof event, because we ate the whole XML
</span><span class="macro">assert_eq!</span>(reader.read_event().unwrap(), Event::Eof);</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Reader%3CR%3E-1" class="impl"><a class="src rightside" href="../../src/quick_xml/reader/mod.rs.html#695-713">Source</a><a href="#impl-Reader%3CR%3E-1" class="anchor">ยง</a><h3 class="code-header">impl&lt;R&gt; <a class="struct" href="struct.Reader.html" title="struct quick_xml::reader::Reader">Reader</a>&lt;R&gt;</h3><div class="docblock"><p>Builder methods</p>
</div></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_reader" class="method"><a class="src rightside" href="../../src/quick_xml/reader/mod.rs.html#697-702">Source</a><h4 class="code-header">pub fn <a href="#method.from_reader" class="fn">from_reader</a>(reader: R) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a <code>Reader</code> that reads from a given reader.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.config" class="method"><a class="src rightside" href="../../src/quick_xml/reader/mod.rs.html#705-707">Source</a><h4 class="code-header">pub const fn <a href="#method.config" class="fn">config</a>(&amp;self) -&gt; &amp;<a class="struct" href="struct.Config.html" title="struct quick_xml::reader::Config">Config</a></h4></section></summary><div class="docblock"><p>Returns reference to the parser configuration</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.config_mut" class="method"><a class="src rightside" href="../../src/quick_xml/reader/mod.rs.html#710-712">Source</a><h4 class="code-header">pub fn <a href="#method.config_mut" class="fn">config_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="struct.Config.html" title="struct quick_xml::reader::Config">Config</a></h4></section></summary><div class="docblock"><p>Returns mutable reference to the parser configuration</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Reader%3CR%3E-2" class="impl"><a class="src rightside" href="../../src/quick_xml/reader/mod.rs.html#716-890">Source</a><a href="#impl-Reader%3CR%3E-2" class="anchor">ยง</a><h3 class="code-header">impl&lt;R&gt; <a class="struct" href="struct.Reader.html" title="struct quick_xml::reader::Reader">Reader</a>&lt;R&gt;</h3><div class="docblock"><p>Getters</p>
</div></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into_inner" class="method"><a class="src rightside" href="../../src/quick_xml/reader/mod.rs.html#771-773">Source</a><h4 class="code-header">pub fn <a href="#method.into_inner" class="fn">into_inner</a>(self) -&gt; R</h4></section></summary><div class="docblock"><p>Consumes <code>Reader</code> returning the underlying reader</p>
<p>Can be used to compute line and column of a parsing error position</p>
<h5 id="examples-6"><a class="doc-anchor" href="#examples-6">ยง</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::{str, io::Cursor};
<span class="kw">use </span>quick_xml::events::Event;
<span class="kw">use </span>quick_xml::reader::Reader;

<span class="kw">let </span>xml = <span class="string">r#"&lt;tag1 att1 = "test"&gt;
                &lt;tag2&gt;&lt;!--Test comment--&gt;Test&lt;/tag2&gt;
                &lt;tag3&gt;Test 2&lt;/tag3&gt;
             &lt;/tag1&gt;"#</span>;
<span class="kw">let </span><span class="kw-2">mut </span>reader = Reader::from_reader(Cursor::new(xml.as_bytes()));
<span class="kw">let </span><span class="kw-2">mut </span>buf = Vec::new();

<span class="kw">fn </span>into_line_and_column(reader: Reader&lt;Cursor&lt;<span class="kw-2">&amp;</span>[u8]&gt;&gt;) -&gt; (usize, usize) {
    <span class="comment">// We known that size cannot exceed usize::MAX because we created parser from single &amp;[u8]
    </span><span class="kw">let </span>end_pos = reader.buffer_position() <span class="kw">as </span>usize;
    <span class="kw">let </span><span class="kw-2">mut </span>cursor = reader.into_inner();
    <span class="kw">let </span>s = String::from_utf8(cursor.into_inner()[<span class="number">0</span>..end_pos].to_owned())
        .expect(<span class="string">"can't make a string"</span>);
    <span class="kw">let </span><span class="kw-2">mut </span>line = <span class="number">1</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>column = <span class="number">0</span>;
    <span class="kw">for </span>c <span class="kw">in </span>s.chars() {
        <span class="kw">if </span>c == <span class="string">'\n' </span>{
            line += <span class="number">1</span>;
            column = <span class="number">0</span>;
        } <span class="kw">else </span>{
            column += <span class="number">1</span>;
        }
    }
    (line, column)
}

<span class="kw">loop </span>{
    <span class="kw">match </span>reader.read_event_into(<span class="kw-2">&amp;mut </span>buf) {
        <span class="prelude-val">Ok</span>(Event::Start(<span class="kw-2">ref </span>e)) =&gt; <span class="kw">match </span>e.name().as_ref() {
            <span class="string">b"tag1" </span>| <span class="string">b"tag2" </span>=&gt; (),
            tag =&gt; {
                <span class="macro">assert_eq!</span>(<span class="string">b"tag3"</span>, tag);
                <span class="macro">assert_eq!</span>((<span class="number">3</span>, <span class="number">22</span>), into_line_and_column(reader));
                <span class="kw">break</span>;
            }
        },
        <span class="prelude-val">Ok</span>(Event::Eof) =&gt; <span class="macro">unreachable!</span>(),
        <span class="kw">_ </span>=&gt; (),
    }
    buf.clear();
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_ref" class="method"><a class="src rightside" href="../../src/quick_xml/reader/mod.rs.html#776-778">Source</a><h4 class="code-header">pub const fn <a href="#method.get_ref" class="fn">get_ref</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.86.0/std/primitive.reference.html">&amp;R</a></h4></section></summary><div class="docblock"><p>Gets a reference to the underlying reader.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_mut" class="method"><a class="src rightside" href="../../src/quick_xml/reader/mod.rs.html#787-789">Source</a><h4 class="code-header">pub fn <a href="#method.get_mut" class="fn">get_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.86.0/std/primitive.reference.html">&amp;mut R</a></h4></section></summary><div class="docblock"><p>Gets a mutable reference to the underlying reader.</p>
<p>Avoid read from this reader because this will not update readerโs position
and will lead to incorrect positions of errors. If you want to read, use
<a href="struct.Reader.html#method.stream" title="method quick_xml::reader::Reader::stream"><code>stream()</code></a> instead.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.buffer_position" class="method"><a class="src rightside" href="../../src/quick_xml/reader/mod.rs.html#792-800">Source</a><h4 class="code-header">pub const fn <a href="#method.buffer_position" class="fn">buffer_position</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.86.0/std/primitive.u64.html">u64</a></h4></section></summary><div class="docblock"><p>Gets the current byte position in the input data.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.error_position" class="method"><a class="src rightside" href="../../src/quick_xml/reader/mod.rs.html#813-815">Source</a><h4 class="code-header">pub const fn <a href="#method.error_position" class="fn">error_position</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.86.0/std/primitive.u64.html">u64</a></h4></section></summary><div class="docblock"><p>Gets the last error byte position in the input data. If there is no errors
yet, returns <code>0</code>.</p>
<p>Unlike <code>buffer_position</code> it will point to the place where it is rational
to report error to the end user. For example, all <a href="../errors/enum.SyntaxError.html" title="enum quick_xml::errors::SyntaxError"><code>SyntaxError</code></a>s are
reported when the parser sees EOF inside of some kind of markup. The
<code>buffer_position()</code> will point to the last byte of input which is not
very useful. <code>error_position()</code> will point to the start of corresponding
markup element (i. e. to the <code>&lt;</code> character).</p>
<p>This position is always <code>&lt;= buffer_position()</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.decoder" class="method"><a class="src rightside" href="../../src/quick_xml/reader/mod.rs.html#827-829">Source</a><h4 class="code-header">pub const fn <a href="#method.decoder" class="fn">decoder</a>(&amp;self) -&gt; <a class="struct" href="../encoding/struct.Decoder.html" title="struct quick_xml::encoding::Decoder">Decoder</a></h4></section></summary><div class="docblock"><p>Get the decoder, used to decode bytes, read by this reader, to the strings.</p>
<p>If <a href="../index.html#encoding"><code>encoding</code></a> feature is enabled, the used encoding may change after
parsing the XML declaration, otherwise encoding is fixed to UTF-8.</p>
<p>If <a href="../index.html#encoding"><code>encoding</code></a> feature is enabled and no encoding is specified in declaration,
defaults to UTF-8.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.stream" class="method"><a class="src rightside" href="../../src/quick_xml/reader/mod.rs.html#884-889">Source</a><h4 class="code-header">pub fn <a href="#method.stream" class="fn">stream</a>(&amp;mut self) -&gt; <a class="struct" href="struct.BinaryStream.html" title="struct quick_xml::reader::BinaryStream">BinaryStream</a>&lt;'_, R&gt; <a href="#" class="tooltip" data-notable-ty="BinaryStream&lt;&#39;_, R&gt;">โ</a></h4></section></summary><div class="docblock"><p>Get the direct access to the underlying reader, but tracks the amount of
read data and update <a href="struct.Reader.html#method.buffer_position" title="method quick_xml::reader::Reader::buffer_position"><code>Reader::buffer_position()</code></a> accordingly.</p>
<p>Note, that this method gives you access to the internal reader and read
data will not be returned in any subsequent events read by <code>read_event</code>
family of methods.</p>
<h5 id="example"><a class="doc-anchor" href="#example">ยง</a>Example</h5>
<p>This example demonstrates how to read stream raw bytes from an XML document.
This could be used to implement streaming read of text, or to read raw binary
bytes embedded in an XML document. (Documents with embedded raw bytes are not
valid XML, but XML-derived file formats exist where such documents are valid).</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::io::{BufRead, Read};
<span class="kw">use </span>quick_xml::events::{BytesEnd, BytesStart, Event};
<span class="kw">use </span>quick_xml::reader::Reader;

<span class="kw">let </span><span class="kw-2">mut </span>reader = Reader::from_str(<span class="string">"&lt;tag&gt;binary &lt;&lt; data&amp;&gt;&lt;/tag&gt;"</span>);
<span class="comment">//                                 ^    ^               ^     ^
//                                 0    5              21    27

</span><span class="macro">assert_eq!</span>(
    (reader.read_event().unwrap(), reader.buffer_position()),
    <span class="comment">// 5 - end of the `&lt;tag&gt;`
    </span>(Event::Start(BytesStart::new(<span class="string">"tag"</span>)), <span class="number">5</span>)
);

<span class="comment">// Reading directly from underlying reader will not update position
// let mut inner = reader.get_mut();

// Reading from the stream() advances position
</span><span class="kw">let </span><span class="kw-2">mut </span>inner = reader.stream();

<span class="comment">// Read binary data. We must know its size
</span><span class="kw">let </span><span class="kw-2">mut </span>binary = [<span class="number">0u8</span>; <span class="number">16</span>];
inner.read_exact(<span class="kw-2">&amp;mut </span>binary).unwrap();
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>binary, <span class="string">b"binary &lt;&lt; data&amp;&gt;"</span>);
<span class="comment">// 21 - end of the `binary &lt;&lt; data&amp;&gt;`
</span><span class="macro">assert_eq!</span>(inner.offset(), <span class="number">21</span>);
<span class="macro">assert_eq!</span>(reader.buffer_position(), <span class="number">21</span>);

<span class="macro">assert_eq!</span>(
    (reader.read_event().unwrap(), reader.buffer_position()),
    <span class="comment">// 27 - end of the `&lt;/tag&gt;`
    </span>(Event::End(BytesEnd::new(<span class="string">"tag"</span>)), <span class="number">27</span>)
);

<span class="macro">assert_eq!</span>(reader.read_event().unwrap(), Event::Eof);</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">ยง</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-Reader%3CR%3E" class="impl"><a class="src rightside" href="../../src/quick_xml/reader/mod.rs.html#686">Source</a><a href="#impl-Clone-for-Reader%3CR%3E" class="anchor">ยง</a><h3 class="code-header">impl&lt;R: <a class="trait" href="https://doc.rust-lang.org/1.86.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.86.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.Reader.html" title="struct quick_xml::reader::Reader">Reader</a>&lt;R&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../../src/quick_xml/reader/mod.rs.html#686">Source</a><a href="#method.clone" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.86.0/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.Reader.html" title="struct quick_xml::reader::Reader">Reader</a>&lt;R&gt;</h4></section></summary><div class='docblock'>Returns a copy of the value. <a href="https://doc.rust-lang.org/1.86.0/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> ยท <a class="src" href="https://doc.rust-lang.org/1.86.0/src/core/clone.rs.html#174">Source</a></span><a href="#method.clone_from" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.86.0/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.86.0/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-Reader%3CR%3E" class="impl"><a class="src rightside" href="../../src/quick_xml/reader/mod.rs.html#686">Source</a><a href="#impl-Debug-for-Reader%3CR%3E" class="anchor">ยง</a><h3 class="code-header">impl&lt;R: <a class="trait" href="https://doc.rust-lang.org/1.86.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.86.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.Reader.html" title="struct quick_xml::reader::Reader">Reader</a>&lt;R&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../../src/quick_xml/reader/mod.rs.html#686">Source</a><a href="#method.fmt" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.86.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.86.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.86.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.86.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">ยง</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-Reader%3CR%3E" class="impl"><a href="#impl-Freeze-for-Reader%3CR%3E" class="anchor">ยง</a><h3 class="code-header">impl&lt;R&gt; <a class="trait" href="https://doc.rust-lang.org/1.86.0/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.Reader.html" title="struct quick_xml::reader::Reader">Reader</a>&lt;R&gt;<div class="where">where
    R: <a class="trait" href="https://doc.rust-lang.org/1.86.0/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a>,</div></h3></section><section id="impl-RefUnwindSafe-for-Reader%3CR%3E" class="impl"><a href="#impl-RefUnwindSafe-for-Reader%3CR%3E" class="anchor">ยง</a><h3 class="code-header">impl&lt;R&gt; <a class="trait" href="https://doc.rust-lang.org/1.86.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Reader.html" title="struct quick_xml::reader::Reader">Reader</a>&lt;R&gt;<div class="where">where
    R: <a class="trait" href="https://doc.rust-lang.org/1.86.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,</div></h3></section><section id="impl-Send-for-Reader%3CR%3E" class="impl"><a href="#impl-Send-for-Reader%3CR%3E" class="anchor">ยง</a><h3 class="code-header">impl&lt;R&gt; <a class="trait" href="https://doc.rust-lang.org/1.86.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Reader.html" title="struct quick_xml::reader::Reader">Reader</a>&lt;R&gt;<div class="where">where
    R: <a class="trait" href="https://doc.rust-lang.org/1.86.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,</div></h3></section><section id="impl-Sync-for-Reader%3CR%3E" class="impl"><a href="#impl-Sync-for-Reader%3CR%3E" class="anchor">ยง</a><h3 class="code-header">impl&lt;R&gt; <a class="trait" href="https://doc.rust-lang.org/1.86.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Reader.html" title="struct quick_xml::reader::Reader">Reader</a>&lt;R&gt;<div class="where">where
    R: <a class="trait" href="https://doc.rust-lang.org/1.86.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,</div></h3></section><section id="impl-Unpin-for-Reader%3CR%3E" class="impl"><a href="#impl-Unpin-for-Reader%3CR%3E" class="anchor">ยง</a><h3 class="code-header">impl&lt;R&gt; <a class="trait" href="https://doc.rust-lang.org/1.86.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Reader.html" title="struct quick_xml::reader::Reader">Reader</a>&lt;R&gt;<div class="where">where
    R: <a class="trait" href="https://doc.rust-lang.org/1.86.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,</div></h3></section><section id="impl-UnwindSafe-for-Reader%3CR%3E" class="impl"><a href="#impl-UnwindSafe-for-Reader%3CR%3E" class="anchor">ยง</a><h3 class="code-header">impl&lt;R&gt; <a class="trait" href="https://doc.rust-lang.org/1.86.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Reader.html" title="struct quick_xml::reader::Reader">Reader</a>&lt;R&gt;<div class="where">where
    R: <a class="trait" href="https://doc.rust-lang.org/1.86.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a>,</div></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">ยง</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.86.0/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">ยง</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.86.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.86.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.86.0/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.86.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.86.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.86.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.86.0/src/core/borrow.rs.html#209">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">ยง</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.86.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.86.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.86.0/src/core/borrow.rs.html#211">Source</a><a href="#method.borrow" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.86.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.86.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.86.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.86.0/src/core/borrow.rs.html#217">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">ยง</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.86.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.86.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.86.0/src/core/borrow.rs.html#218">Source</a><a href="#method.borrow_mut" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.86.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.86.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.86.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.86.0/src/core/clone.rs.html#273">Source</a><a href="#impl-CloneToUninit-for-T" class="anchor">ยง</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.86.0/core/clone/trait.CloneToUninit.html" title="trait core::clone::CloneToUninit">CloneToUninit</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.86.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.86.0/src/core/clone.rs.html#275">Source</a><a href="#method.clone_to_uninit" class="anchor">ยง</a><h4 class="code-header">unsafe fn <a href="https://doc.rust-lang.org/1.86.0/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit" class="fn">clone_to_uninit</a>(&amp;self, dst: <a class="primitive" href="https://doc.rust-lang.org/1.86.0/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/1.86.0/std/primitive.u8.html">u8</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">๐ฌ</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dst</code>. <a href="https://doc.rust-lang.org/1.86.0/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.86.0/src/core/convert/mod.rs.html#767">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">ยง</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.86.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.86.0/src/core/convert/mod.rs.html#770">Source</a><a href="#method.from" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.86.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.86.0/src/core/convert/mod.rs.html#750-752">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">ยง</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.86.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.86.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.86.0/src/core/convert/mod.rs.html#760">Source</a><a href="#method.into" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.86.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.86.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.86.0/src/alloc/borrow.rs.html#82-84">Source</a><a href="#impl-ToOwned-for-T" class="anchor">ยง</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.86.0/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.86.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.86.0/src/alloc/borrow.rs.html#86">Source</a><a href="#associatedtype.Owned" class="anchor">ยง</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.86.0/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.86.0/src/alloc/borrow.rs.html#87">Source</a><a href="#method.to_owned" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.86.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.86.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.86.0/src/alloc/borrow.rs.html#91">Source</a><a href="#method.clone_into" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.86.0/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.86.0/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.86.0/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.86.0/src/core/convert/mod.rs.html#807-809">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">ยง</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.86.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.86.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.86.0/src/core/convert/mod.rs.html#811">Source</a><a href="#associatedtype.Error-1" class="anchor">ยง</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.86.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.86.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.86.0/src/core/convert/mod.rs.html#814">Source</a><a href="#method.try_from" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.86.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.86.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.86.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.86.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.86.0/src/core/convert/mod.rs.html#792-794">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">ยง</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.86.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.86.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.86.0/src/core/convert/mod.rs.html#796">Source</a><a href="#associatedtype.Error" class="anchor">ยง</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.86.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.86.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.86.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.86.0/src/core/convert/mod.rs.html#799">Source</a><a href="#method.try_into" class="anchor">ยง</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.86.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.86.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.86.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.86.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div><script type="text/json" id="notable-traits-data">{"BinaryStream<'_, R>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.BinaryStream.html\" title=\"struct quick_xml::reader::BinaryStream\">BinaryStream</a>&lt;'r, R&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'r, R&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.86.0/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for <a class=\"struct\" href=\"struct.BinaryStream.html\" title=\"struct quick_xml::reader::BinaryStream\">BinaryStream</a>&lt;'r, R&gt;<div class=\"where\">where\n    R: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.86.0/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a>,</div></div>"}</script></section></div></main></body></html>
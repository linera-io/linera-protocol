<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="`seize`"><title>seize - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-6c3ea77c.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="seize" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0 (05f9846f8 2025-03-31)" data-channel="1.86.0" data-search-js="search-581efc7a.js" data-settings-js="settings-6dad6058.js" ><script src="../static.files/storage-3a5871a4.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-4d63596a.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../seize/index.html">seize</a><span class="version">0.4.9</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#seize" title="`seize`"><code>seize</code></a><ul><li><a href="#background" title="Background">Background</a></li><li><a href="#implementation" title="Implementation">Implementation</a></li></ul></li></ul><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>seize</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/seize/lib.rs.html#1-18">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="seize"><a class="doc-anchor" href="#seize">§</a><code>seize</code></h2>
<p><a href="https://crates.io/crates/seize"><img alt="crates.io" src="https://img.shields.io/crates/v/seize?style=for-the-badge" height="25"></a>
<a href="https://github.com/ibraheemdev/seize"><img alt="github" src="https://img.shields.io/badge/github-seize-blue?style=for-the-badge" height="25"></a>
<a href="https://docs.rs/seize"><img alt="docs.rs" src="https://img.shields.io/docsrs/seize?style=for-the-badge" height="25"></a></p>
<p>Fast, efficient, and robust memory reclamation for concurrent data structures.</p>
<p>See the <a href="https://docs.rs/seize/latest/seize/guide/index.html">quick-start guide</a> to get started.</p>
<h3 id="background"><a class="doc-anchor" href="#background">§</a>Background</h3>
<p>Concurrent data structures are faced with the problem of deciding when it is
safe to free memory. Although an object might have been logically removed, other
threads that previously loaded it may still be accessing it, and thus it is
not safe to free immediately. Over the years, many algorithms have been devised
to solve this problem. However, most traditional memory reclamation schemes make
the tradeoff between performance, efficiency, and robustness. For example,
<a href="https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-579.pdf">epoch based reclamation</a> is fast and lightweight but lacks robustness in that a
stalled thread can prevent the reclamation of <em>all</em> retired objects. <a href="https://www.cs.otago.ac.nz/cosc440/readings/hazard-pointers.pdf">Hazard
pointers</a>, another popular scheme, tracks individual pointers, making it efficient
and robust but generally much slower.</p>
<p>Another problem that is often not considered is workload balancing. In most
reclamation schemes, the thread that retires an object is the one that reclaims
it. This leads to unbalanced reclamation in read-dominated workloads; parallelism
is reduced when only a fraction of threads are writing, degrading memory efficiency.</p>
<h3 id="implementation"><a class="doc-anchor" href="#implementation">§</a>Implementation</h3>
<p>Seize is based on the <a href="https://arxiv.org/pdf/1905.07903.pdf">hyaline reclamation scheme</a>, which uses reference counting
to determine when it is safe to free memory. However, reference counters are only
used for already retired objects, allowing it to avoid the high overhead incurred
by traditional reference counting schemes where every memory access requires modifying
shared memory. Reclamation is naturally balanced as the thread with the last reference
to an object is the one that frees it. This removes the need to check whether other
threads have made progress, leading to predictable latency without sacrificing performance.
Epochs can also be tracked to protect against stalled threads, making reclamation truly
lock-free.</p>
<p>Seize provides performance competitive with that of epoch based schemes, while memory efficiency
is similar to that of hazard pointers. Seize is compatible with all modern hardware that
supports single-word atomic operations such as FAA and CAS.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="guide/index.html" title="mod seize::guide">guide</a></dt><dd>A quick-start guide for working with <code>seize</code>.</dd><dt><a class="mod" href="reclaim/index.html" title="mod seize::reclaim">reclaim</a></dt><dd>Common memory reclaimers.</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Collector.html" title="struct seize::Collector">Collector</a></dt><dd>Fast, efficient, and robust memory reclamation.</dd><dt><a class="struct" href="struct.Deferred.html" title="struct seize::Deferred">Deferred</a></dt><dd>A batch of pointers to be reclaimed in the future.</dd><dt><a class="struct" href="struct.Link.html" title="struct seize::Link">Link</a></dt><dd>A link to the collector.</dd><dt><a class="struct" href="struct.Linked.html" title="struct seize::Linked">Linked</a></dt><dd>A value linked to a collector.</dd><dt><a class="struct" href="struct.LocalGuard.html" title="struct seize::LocalGuard">Local<wbr>Guard</a></dt><dd>A guard that keeps the current thread marked as active.</dd><dt><a class="struct" href="struct.OwnedGuard.html" title="struct seize::OwnedGuard">Owned<wbr>Guard</a></dt><dd>A guard that protects objects for it’s lifetime, independent of the current
thread.</dd><dt><a class="struct" href="struct.UnprotectedGuard.html" title="struct seize::UnprotectedGuard">Unprotected<wbr>Guard</a></dt><dd>A dummy guard object.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.AsLink.html" title="trait seize::AsLink">AsLink</a></dt><dd>A type that can be pointer-cast to and from a <a href="struct.Link.html" title="struct seize::Link"><code>Link</code></a>.</dd><dt><a class="trait" href="trait.Guard.html" title="trait seize::Guard">Guard</a></dt><dd>A guard that enables protected loads of concurrent objects.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.unprotected.html" title="fn seize::unprotected">unprotected</a><sup title="unsafe function">⚠</sup></dt><dd>Returns a dummy guard object.</dd></dl></section></div></main></body></html>
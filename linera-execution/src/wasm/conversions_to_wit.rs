// Copyright (c) Zefchain Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

//! Conversions to types generated by `wit-bindgen`.
//!
//! Allows converting types used in `linera-execution` to types that can be sent to the guest Wasm
//! module.

#![allow(clippy::duplicate_mod)]

use linera_base::{
    crypto::{CryptoHash, PublicKey},
    data_types::Amount,
    identifiers::{Account, ChainId, Owner},
    ownership::{ChainOwnership, TimeoutConfig},
};

use super::{contract_system_api, service_system_api};
use crate::{MessageId, UserApplicationId};

impl From<MessageId> for service_system_api::MessageId {
    fn from(host: MessageId) -> Self {
        service_system_api::MessageId {
            chain_id: host.chain_id.into(),
            height: host.height.0,
            index: host.index,
        }
    }
}

impl From<MessageId> for contract_system_api::MessageId {
    fn from(host: MessageId) -> Self {
        contract_system_api::MessageId {
            chain_id: host.chain_id.into(),
            height: host.height.0,
            index: host.index,
        }
    }
}

impl From<UserApplicationId> for service_system_api::ApplicationId {
    fn from(host: UserApplicationId) -> Self {
        service_system_api::ApplicationId {
            bytecode_id: host.bytecode_id.message_id.into(),
            creation: host.creation.into(),
        }
    }
}

impl From<UserApplicationId> for contract_system_api::ApplicationId {
    fn from(host: UserApplicationId) -> Self {
        contract_system_api::ApplicationId {
            bytecode_id: host.bytecode_id.message_id.into(),
            creation: host.creation.into(),
        }
    }
}

impl From<ChainId> for service_system_api::ChainId {
    fn from(chain_id: ChainId) -> Self {
        chain_id.0.into()
    }
}

impl From<ChainId> for contract_system_api::ChainId {
    fn from(chain_id: ChainId) -> Self {
        chain_id.0.into()
    }
}

impl From<CryptoHash> for service_system_api::CryptoHash {
    fn from(crypto_hash: CryptoHash) -> Self {
        let [part1, part2, part3, part4]: [u64; 4] = crypto_hash.into();
        service_system_api::CryptoHash {
            part1,
            part2,
            part3,
            part4,
        }
    }
}

impl From<CryptoHash> for contract_system_api::CryptoHash {
    fn from(crypto_hash: CryptoHash) -> Self {
        let [part1, part2, part3, part4]: [u64; 4] = crypto_hash.into();
        contract_system_api::CryptoHash {
            part1,
            part2,
            part3,
            part4,
        }
    }
}

impl From<Amount> for service_system_api::Amount {
    fn from(host: Amount) -> Self {
        service_system_api::Amount {
            lower_half: host.lower_half(),
            upper_half: host.upper_half(),
        }
    }
}

impl From<Amount> for contract_system_api::Amount {
    fn from(host: Amount) -> Self {
        contract_system_api::Amount {
            lower_half: host.lower_half(),
            upper_half: host.upper_half(),
        }
    }
}

impl From<PublicKey> for contract_system_api::PublicKey {
    fn from(host: PublicKey) -> Self {
        let [part1, part2, part3, part4] = host.into();
        Self {
            part1,
            part2,
            part3,
            part4,
        }
    }
}

impl From<TimeoutConfig> for contract_system_api::TimeoutConfig {
    fn from(host: TimeoutConfig) -> Self {
        let TimeoutConfig {
            fast_round_duration,
            base_timeout,
            timeout_increment,
        } = host;
        Self {
            fast_round_duration_us: fast_round_duration.map(|duration| duration.as_micros()),
            base_timeout_us: base_timeout.as_micros(),
            timeout_increment_us: timeout_increment.as_micros(),
        }
    }
}

impl From<ChainOwnership> for contract_system_api::ChainOwnershipResult {
    fn from(host: ChainOwnership) -> Self {
        let ChainOwnership {
            super_owners,
            owners,
            multi_leader_rounds,
            timeout_config,
        } = host;
        Self {
            super_owners: super_owners.into_values().map(Into::into).collect(),
            owners: owners
                .into_values()
                .map(|(pub_key, weight)| (pub_key.into(), weight))
                .collect(),
            multi_leader_rounds,
            timeout_config: timeout_config.into(),
        }
    }
}

impl From<Account> for contract_system_api::Account {
    fn from(account: Account) -> Self {
        contract_system_api::Account {
            chain_id: account.chain_id.into(),
            owner: account.owner.map(|owner| owner.into()),
        }
    }
}

impl From<Owner> for contract_system_api::CryptoHash {
    fn from(owner: Owner) -> Self {
        contract_system_api::CryptoHash::from(owner.0)
    }
}

impl From<Owner> for service_system_api::CryptoHash {
    fn from(owner: Owner) -> Self {
        service_system_api::CryptoHash::from(owner.0)
    }
}

// Copyright (c) Zefchain Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

//! Conversions from types generated by `wit-bindgen`.
//!
//! Allows converting types returned from a Wasm module into types that can be used with the rest
//! of the crate.

#![allow(clippy::duplicate_mod)]

use std::time::Duration;

use super::{contract, contract_system_api, service_system_api};
use crate::{
    ApplicationCallOutcome, ChannelName, Destination, MessageKind, RawExecutionOutcome,
    RawOutgoingMessage, SessionCallOutcome, SessionId, UserApplicationId,
};
use linera_base::{
    crypto::{CryptoHash, PublicKey},
    data_types::{Amount, BlockHeight, Resources},
    identifiers::{Account, BytecodeId, ChainId, MessageId, Owner},
    ownership::{ChainOwnership, TimeoutConfig},
};

impl From<contract::SessionCallOutcome> for (SessionCallOutcome, Vec<u8>) {
    fn from(outcome: contract::SessionCallOutcome) -> Self {
        let session_call_outcome = SessionCallOutcome {
            inner: outcome.inner.into(),
            close_session: outcome.new_state.is_some(),
        };

        let updated_session_state = outcome.new_state.unwrap_or_default();

        (session_call_outcome, updated_session_state)
    }
}

impl From<contract::ApplicationCallOutcome> for ApplicationCallOutcome {
    fn from(outcome: contract::ApplicationCallOutcome) -> Self {
        ApplicationCallOutcome {
            create_sessions: outcome.create_sessions,
            execution_outcome: outcome.execution_outcome.into(),
            value: outcome.value,
        }
    }
}

impl From<contract::Resources> for Resources {
    fn from(value: contract::Resources) -> Self {
        Self {
            fuel: value.fuel,
            read_operations: value.read_operations,
            write_operations: value.write_operations,
            bytes_to_read: value.bytes_to_read,
            bytes_to_write: value.bytes_to_write,
            messages: value.messages,
            message_size: value.message_size,
            storage_size_delta: value.storage_size_delta,
        }
    }
}

impl From<contract::OutgoingMessage> for RawOutgoingMessage<Vec<u8>, Resources> {
    fn from(message: contract::OutgoingMessage) -> Self {
        Self {
            destination: message.destination.into(),
            authenticated: message.authenticated,
            grant: message.resources.into(),
            kind: if message.is_tracked {
                MessageKind::Tracked
            } else {
                MessageKind::Simple
            },
            message: message.message,
        }
    }
}

impl From<contract::ExecutionOutcome> for RawExecutionOutcome<Vec<u8>, Resources> {
    fn from(outcome: contract::ExecutionOutcome) -> Self {
        let messages = outcome
            .messages
            .into_iter()
            .map(RawOutgoingMessage::from)
            .collect();

        let subscribe = outcome
            .subscribe
            .into_iter()
            .map(|(subscription, chain_id)| (subscription.into(), chain_id.into()))
            .collect();

        let unsubscribe = outcome
            .unsubscribe
            .into_iter()
            .map(|(subscription, chain_id)| (subscription.into(), chain_id.into()))
            .collect();

        RawExecutionOutcome {
            authenticated_signer: None,
            refund_grant_to: None,
            messages,
            subscribe,
            unsubscribe,
        }
    }
}

impl From<contract::Destination> for Destination {
    fn from(guest: contract::Destination) -> Self {
        match guest {
            contract::Destination::Recipient(chain_id) => Destination::Recipient(chain_id.into()),
            contract::Destination::Subscribers(subscription) => {
                Destination::Subscribers(subscription.into())
            }
        }
    }
}

impl From<contract::ChannelName> for ChannelName {
    fn from(guest: contract::ChannelName) -> Self {
        guest.name.into()
    }
}

impl From<contract::CryptoHash> for CryptoHash {
    fn from(guest: contract::CryptoHash) -> Self {
        let integers = [guest.part1, guest.part2, guest.part3, guest.part4];
        CryptoHash::from(integers)
    }
}

impl From<contract::ChainId> for ChainId {
    fn from(guest: contract::ChainId) -> Self {
        ChainId(guest.into())
    }
}

impl From<contract_system_api::SessionId> for SessionId {
    fn from(guest: contract_system_api::SessionId) -> Self {
        SessionId {
            application_id: guest.application_id.into(),
            index: guest.index,
        }
    }
}

impl From<contract_system_api::ApplicationId> for UserApplicationId {
    fn from(guest: contract_system_api::ApplicationId) -> Self {
        UserApplicationId {
            bytecode_id: guest.bytecode_id.into(),
            creation: guest.creation.into(),
        }
    }
}

impl From<contract_system_api::MessageId> for BytecodeId {
    fn from(guest: contract_system_api::MessageId) -> Self {
        BytecodeId::new(guest.into())
    }
}

impl From<contract_system_api::MessageId> for MessageId {
    fn from(guest: contract_system_api::MessageId) -> Self {
        MessageId {
            chain_id: guest.chain_id.into(),
            height: BlockHeight(guest.height),
            index: guest.index,
        }
    }
}

impl From<contract_system_api::CryptoHash> for ChainId {
    fn from(guest: contract_system_api::CryptoHash) -> Self {
        ChainId(guest.into())
    }
}

impl From<contract_system_api::CryptoHash> for CryptoHash {
    fn from(guest: contract_system_api::CryptoHash) -> Self {
        let integers = [guest.part1, guest.part2, guest.part3, guest.part4];
        CryptoHash::from(integers)
    }
}

impl From<contract_system_api::PublicKey> for PublicKey {
    fn from(guest: contract_system_api::PublicKey) -> PublicKey {
        let contract_system_api::PublicKey {
            part1,
            part2,
            part3,
            part4,
        } = guest;
        [part1, part2, part3, part4].into()
    }
}

impl From<contract_system_api::TimeoutConfig> for TimeoutConfig {
    fn from(guest: contract_system_api::TimeoutConfig) -> TimeoutConfig {
        let contract_system_api::TimeoutConfig {
            fast_round_duration_ms,
            base_timeout_ms,
            timeout_increment_ms,
        } = guest;
        TimeoutConfig {
            fast_round_duration: fast_round_duration_ms.map(Duration::from_millis),
            base_timeout: Duration::from_millis(base_timeout_ms),
            timeout_increment: Duration::from_millis(timeout_increment_ms),
        }
    }
}

impl<'a> From<contract_system_api::ChainOwnershipParam<'a>> for ChainOwnership {
    fn from(guest: contract_system_api::ChainOwnershipParam<'a>) -> ChainOwnership {
        let contract_system_api::ChainOwnershipParam {
            super_owners,
            owners,
            multi_leader_rounds,
            timeout_config,
        } = guest;
        let super_owners = super_owners.iter().map(|le| {
            let pub_key = PublicKey::from(le.get());
            (Owner::from(pub_key), pub_key)
        });
        let owners = owners.iter().map(|le| {
            let (pub_key, weight) = le.get();
            let pub_key = PublicKey::from(pub_key);
            (Owner::from(pub_key), (pub_key, weight))
        });
        ChainOwnership {
            super_owners: super_owners.collect(),
            owners: owners.collect(),
            multi_leader_rounds,
            timeout_config: timeout_config.into(),
        }
    }
}

impl From<contract_system_api::CryptoHash> for Owner {
    fn from(guest: contract_system_api::CryptoHash) -> Self {
        let integers = [guest.part1, guest.part2, guest.part3, guest.part4];
        Owner(CryptoHash::from(integers))
    }
}

impl From<contract_system_api::Account> for Account {
    fn from(account: contract_system_api::Account) -> Self {
        Account {
            chain_id: account.chain_id.into(),
            owner: account.owner.map(|owner| owner.into()),
        }
    }
}

impl From<contract_system_api::Amount> for Amount {
    fn from(amount: contract_system_api::Amount) -> Self {
        let value = ((amount.upper_half as u128) << 64) | (amount.lower_half as u128);
        Amount::from_attos(value)
    }
}

impl From<service_system_api::ApplicationId> for UserApplicationId {
    fn from(guest: service_system_api::ApplicationId) -> Self {
        UserApplicationId {
            bytecode_id: guest.bytecode_id.into(),
            creation: guest.creation.into(),
        }
    }
}

impl From<service_system_api::MessageId> for BytecodeId {
    fn from(guest: service_system_api::MessageId) -> Self {
        BytecodeId::new(guest.into())
    }
}

impl From<service_system_api::MessageId> for MessageId {
    fn from(guest: service_system_api::MessageId) -> Self {
        MessageId {
            chain_id: guest.chain_id.into(),
            height: BlockHeight(guest.height),
            index: guest.index,
        }
    }
}

impl From<service_system_api::CryptoHash> for ChainId {
    fn from(guest: service_system_api::CryptoHash) -> Self {
        ChainId(guest.into())
    }
}

impl From<service_system_api::CryptoHash> for CryptoHash {
    fn from(guest: service_system_api::CryptoHash) -> Self {
        let integers = [guest.part1, guest.part2, guest.part3, guest.part4];
        CryptoHash::from(integers)
    }
}

impl From<service_system_api::CryptoHash> for Owner {
    fn from(guest: service_system_api::CryptoHash) -> Self {
        let integers = [guest.part1, guest.part2, guest.part3, guest.part4];
        Owner(CryptoHash::from(integers))
    }
}

<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This crate contains parser combinators, roughly based on the Haskell libraries parsec and attoparsec."><title>combine - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-6c3ea77c.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="combine" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0 (05f9846f8 2025-03-31)" data-channel="1.86.0" data-search-js="search-581efc7a.js" data-settings-js="settings-6dad6058.js" ><script src="../static.files/storage-3a5871a4.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-4d63596a.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../combine/index.html">combine</a><span class="version">4.6.7</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#overview" title="Overview">Overview</a></li><li><a href="#examples" title="Examples">Examples</a></li></ul><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#macros" title="Macros">Macros</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>combine</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/combine/lib.rs.html#1-1006">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This crate contains parser combinators, roughly based on the Haskell libraries
<a href="http://hackage.haskell.org/package/parsec">parsec</a> and
<a href="https://hackage.haskell.org/package/attoparsec">attoparsec</a>.</p>
<p>A parser in this library can be described as a function which takes some input and if it
is successful, returns a value together with the remaining input.
A parser combinator is a function which takes one or more parsers and returns a new parser.
For instance the <a href="parser/repeat/fn.many.html"><code>many</code></a> parser can be used to convert a parser for single digits into one that
parses multiple digits. By modeling parsers in this way it becomes easy to compose complex
parsers in an almost declarative way.</p>
<h2 id="overview"><a class="doc-anchor" href="#overview">§</a>Overview</h2>
<p><code>combine</code> limits itself to creating <a href="https://en.wikipedia.org/wiki/LL_parser">LL(1) parsers</a>
(it is possible to opt-in to LL(k) parsing using the <a href="parser/combinator/fn.attempt.html"><code>attempt</code></a> combinator) which makes the
parsers easy to reason about in both function and performance while sacrificing
some generality. In addition to you being able to reason better about the parsers you
construct <code>combine</code> the library also takes the knowledge of being an LL parser and uses it to
automatically construct good error messages.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern crate </span>combine;
<span class="kw">use </span>combine::{Parser, EasyParser};
<span class="kw">use </span>combine::stream::position;
<span class="kw">use </span>combine::parser::char::{digit, letter};
<span class="kw">const </span>MSG: <span class="kw-2">&amp;</span><span class="lifetime">'static </span>str = <span class="string">r#"Parse error at line: 1, column: 1
Unexpected `|`
Expected digit or letter
"#</span>;

<span class="kw">fn </span>main() {
    <span class="comment">// Wrapping a `&amp;str` with `State` provides automatic line and column tracking. If `State`
    // was not used the positions would instead only be pointers into the `&amp;str`
    </span><span class="kw">if let </span><span class="prelude-val">Err</span>(err) = digit().or(letter()).easy_parse(position::Stream::new(<span class="string">"|"</span>)) {
        <span class="macro">assert_eq!</span>(MSG, <span class="macro">format!</span>(<span class="string">"{}"</span>, err));
    }
}</code></pre></div>
<p>This library is currently split into a few core modules:</p>
<ul>
<li>
<p><a href="parser/index.html"><code>parser</code></a> is where you will find all the parsers that combine provides. It contains the core
<a href="parser/trait.Parser.html"><code>Parser</code></a> trait as well as several submodules such as <code>sequence</code> or <code>choice</code> which each
contain several parsers aimed at a specific niche.</p>
</li>
<li>
<p><a href="stream/trait.Stream.html"><code>stream</code></a> contains the second most important trait next to <a href="parser/trait.Parser.html"><code>Parser</code></a>. Streams represent the
data source which is being parsed such as <code>&amp;[u8]</code>, <code>&amp;str</code> or iterators.</p>
</li>
<li>
<p><a href="easy/index.html"><code>easy</code></a> contains combine’s default “easy” error and stream handling. If you use the
<code>easy_parse</code> method to start your parsing these are the types that are used.</p>
</li>
<li>
<p><a href="error/index.html"><code>error</code></a> contains the types and traits that make up combine’s error handling. Unless you
need to customize the errors your parsers return you should not need to use this module much.</p>
</li>
</ul>
<h2 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern crate </span>combine;
<span class="kw">use </span>combine::parser::char::{spaces, digit, char};
<span class="kw">use </span>combine::{many1, sep_by, Parser, EasyParser};
<span class="kw">use </span>combine::stream::easy;

<span class="kw">fn </span>main() {
    <span class="comment">//Parse spaces first and use the with method to only keep the result of the next parser
    </span><span class="kw">let </span>integer = spaces()
        <span class="comment">//parse a string of digits into an i32
        </span>.with(many1(digit()).map(|string: String| string.parse::&lt;i32&gt;().unwrap()));

    <span class="comment">//Parse integers separated by commas, skipping whitespace
    </span><span class="kw">let </span><span class="kw-2">mut </span>integer_list = sep_by(integer, spaces().skip(char(<span class="string">','</span>)));

    <span class="comment">//Call parse with the input to execute the parser
    </span><span class="kw">let </span>input = <span class="string">"1234, 45,78"</span>;
    <span class="kw">let </span>result: <span class="prelude-ty">Result</span>&lt;(Vec&lt;i32&gt;, <span class="kw-2">&amp;</span>str), easy::ParseError&lt;<span class="kw-2">&amp;</span>str&gt;&gt; =
        integer_list.easy_parse(input);
    <span class="kw">match </span>result {
        <span class="prelude-val">Ok</span>((value, _remaining_input)) =&gt; <span class="macro">println!</span>(<span class="string">"{:?}"</span>, value),
        <span class="prelude-val">Err</span>(err) =&gt; <span class="macro">println!</span>(<span class="string">"{}"</span>, err)
    }
}</code></pre></div>
<p>If we need a parser that is mutually recursive or if we want to export a reusable parser the
<a href="macro.parser.html"><code>parser!</code></a> macro can be used. In effect it makes it possible to return a parser without naming
the type of the parser (which can be very large due to combine’s trait based approach). While
it is possible to do avoid naming the type without the macro those solutions require either
allocation (<code>Box&lt;dyn Parser&lt; Input, Output = O, PartialState = P&gt;&gt;</code>) or via <code>impl Trait</code> in the
return position. The macro thus threads the needle and makes it possible to have
non-allocating, anonymous parsers on stable rust.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[macro_use]
</span><span class="kw">extern crate </span>combine;
<span class="kw">use </span>combine::parser::char::{char, letter, spaces};
<span class="kw">use </span>combine::{between, choice, many1, parser, sep_by, Parser, EasyParser};
<span class="kw">use </span>combine::error::{ParseError, StdParseResult};
<span class="kw">use </span>combine::stream::{Stream, Positioned};
<span class="kw">use </span>combine::stream::position;

<span class="attr">#[derive(Debug, PartialEq)]
</span><span class="kw">pub enum </span>Expr {
    Id(String),
    Array(Vec&lt;Expr&gt;),
    Pair(Box&lt;Expr&gt;, Box&lt;Expr&gt;)
}

<span class="comment">// `impl Parser` can be used to create reusable parsers with zero overhead
</span><span class="kw">fn </span>expr_&lt;Input&gt;() -&gt; <span class="kw">impl </span>Parser&lt; Input, Output = Expr&gt;
    <span class="kw">where </span>Input: Stream&lt;Token = char&gt;,
{
    <span class="kw">let </span>word = many1(letter());

    <span class="comment">// A parser which skips past whitespace.
    // Since we aren't interested in knowing that our expression parser
    // could have accepted additional whitespace between the tokens we also silence the error.
    </span><span class="kw">let </span>skip_spaces = || spaces().silent();

    <span class="comment">//Creates a parser which parses a char and skips any trailing whitespace
    </span><span class="kw">let </span>lex_char = |c| char(c).skip(skip_spaces());

    <span class="kw">let </span>comma_list = sep_by(expr(), lex_char(<span class="string">','</span>));
    <span class="kw">let </span>array = between(lex_char(<span class="string">'['</span>), lex_char(<span class="string">']'</span>), comma_list);

    <span class="comment">//We can use tuples to run several parsers in sequence
    //The resulting type is a tuple containing each parsers output
    </span><span class="kw">let </span>pair = (lex_char(<span class="string">'('</span>),
                expr(),
                lex_char(<span class="string">','</span>),
                expr(),
                lex_char(<span class="string">')'</span>))
                   .map(|t| Expr::Pair(Box::new(t.<span class="number">1</span>), Box::new(t.<span class="number">3</span>)));

    choice((
        word.map(Expr::Id),
        array.map(Expr::Array),
        pair,
    ))
        .skip(skip_spaces())
}

<span class="comment">// As this expression parser needs to be able to call itself recursively `impl Parser` can't
// be used on its own as that would cause an infinitely large type. We can avoid this by using
// the `parser!` macro which erases the inner type and the size of that type entirely which
// lets it be used recursively.
//
// (This macro does not use `impl Trait` which means it can be used in rust &lt; 1.26 as well to
// emulate `impl Parser`)
</span><span class="macro">parser!</span>{
    <span class="kw">fn </span>expr[Input]()(Input) -&gt; Expr
    <span class="kw">where </span>[Input: Stream&lt;Token = char&gt;]
    {
        expr_()
    }
}

<span class="kw">fn </span>main() {
    <span class="kw">let </span>result = expr()
        .parse(<span class="string">"[[], (hello, world), [rust]]"</span>);
    <span class="kw">let </span>expr = Expr::Array(<span class="macro">vec!</span>[
          Expr::Array(Vec::new())
        , Expr::Pair(Box::new(Expr::Id(<span class="string">"hello"</span>.to_string())),
                     Box::new(Expr::Id(<span class="string">"world"</span>.to_string())))
        , Expr::Array(<span class="macro">vec!</span>[Expr::Id(<span class="string">"rust"</span>.to_string())])
    ]);
    <span class="macro">assert_eq!</span>(result, <span class="prelude-val">Ok</span>((expr, <span class="string">""</span>)));
}</code></pre></div>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="easy/index.html" title="mod combine::easy">easy</a></dt><dd>Stream wrapper which provides an informative and easy to use error type.</dd><dt><a class="mod" href="error/index.html" title="mod combine::error">error</a></dt><dd>Error types and traits which define what kind of errors combine parsers may emit</dd><dt><a class="mod" href="parser/index.html" title="mod combine::parser">parser</a></dt><dd>A collection of both concrete parsers as well as parser combinators.</dd><dt><a class="mod" href="stream/index.html" title="mod combine::stream">stream</a></dt><dd>Streams are similar to the <code>Iterator</code> trait in that they represent some sequential set of items
which can be retrieved one by one. Where <code>Stream</code>s differ is that they are allowed to return
errors instead of just <code>None</code> and if they implement the <code>RangeStreamOnce</code> trait they are also
capable of returning multiple items at the same time, usually in the form of a slice.</dd></dl><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">§</a></h2><dl class="item-table"><dt><a class="macro" href="macro.choice.html" title="macro combine::choice">choice</a></dt><dd>Takes a number of parsers and tries to apply them each in order.
Fails if all the parsers fails or if an applied parser fails after it has committed to its
parse.</dd><dt><a class="macro" href="macro.decode.html" title="macro combine::decode">decode</a></dt><dd>Parses an instance of <code>std::io::Read</code> as a <code>&amp;[u8]</code> without reading the entire file into
memory.</dd><dt><a class="macro" href="macro.dispatch.html" title="macro combine::dispatch">dispatch</a></dt><dd><code>dispatch!</code> allows a parser to be constructed depending on earlier input, without forcing each
branch to have the same type of parser</dd><dt><a class="macro" href="macro.opaque.html" title="macro combine::opaque">opaque</a></dt><dd>Convenience macro over <a href="parser/combinator/fn.opaque.html"><code>opaque</code></a>.</dd><dt><a class="macro" href="macro.parser.html" title="macro combine::parser">parser</a></dt><dd>Declares a named parser which can easily be reused.</dd><dt><a class="macro" href="macro.struct_parser.html" title="macro combine::struct_parser">struct_<wbr>parser</a></dt><dd>Sequences multiple parsers and builds a struct out of them.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.ParseResult.html" title="enum combine::ParseResult">Parse<wbr>Result</a></dt><dd>A <code>Result</code> type which has the committed status flattened into the result.
Conversions to and from <code>std::result::Result</code> can be done using <code>result.into()</code> or
<code>From::from(result)</code></dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.EasyParser.html" title="trait combine::EasyParser">Easy<wbr>Parser</a></dt><dd>Provides the <code>easy_parse</code> method which provides good error messages by default</dd><dt><a class="trait" href="trait.ParseError.html" title="trait combine::ParseError">Parse<wbr>Error</a></dt><dd>Trait which defines a combine parse error.</dd><dt><a class="trait" href="trait.Parser.html" title="trait combine::Parser">Parser</a></dt><dd>By implementing the <code>Parser</code> trait a type says that it can be used to parse an input stream
into the type <code>Output</code>.</dd><dt><a class="trait" href="trait.Positioned.html" title="trait combine::Positioned">Positioned</a></dt><dd>A type which has a position.</dd><dt><a class="trait" href="trait.RangeStream.html" title="trait combine::RangeStream">Range<wbr>Stream</a></dt><dd>A <code>RangeStream</code> is an extension of <code>Stream</code> which allows for zero copy parsing.</dd><dt><a class="trait" href="trait.RangeStreamOnce.html" title="trait combine::RangeStreamOnce">Range<wbr>Stream<wbr>Once</a></dt><dd>A <code>RangeStream</code> is an extension of <code>StreamOnce</code> which allows for zero copy parsing.</dd><dt><a class="trait" href="trait.Stream.html" title="trait combine::Stream">Stream</a></dt><dd>A stream of tokens which can be duplicated</dd><dt><a class="trait" href="trait.StreamOnce.html" title="trait combine::StreamOnce">Stream<wbr>Once</a></dt><dd><code>StreamOnce</code> represents a sequence of items that can be extracted one by one.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.any.html" title="fn combine::any">any</a></dt><dd>Parses any token.</dd><dt><a class="fn" href="fn.attempt.html" title="fn combine::attempt">attempt</a></dt><dd><code>attempt(p)</code> behaves as <code>p</code> except it always acts as <code>p</code> peeked instead of committed on its
parse.</dd><dt><a class="fn" href="fn.between.html" title="fn combine::between">between</a></dt><dd>Parses <code>open</code> followed by <code>parser</code> followed by <code>close</code>.
Returns the value of <code>parser</code>.</dd><dt><a class="fn" href="fn.chainl1.html" title="fn combine::chainl1">chainl1</a></dt><dd>Parses <code>p</code> 1 or more times separated by <code>op</code>. The value returned is the one produced by the
left associative application of the function returned by the parser <code>op</code>.</dd><dt><a class="fn" href="fn.chainr1.html" title="fn combine::chainr1">chainr1</a></dt><dd>Parses <code>p</code> one or more times separated by <code>op</code>. The value returned is the one produced by the
right associative application of the function returned by <code>op</code>.</dd><dt><a class="fn" href="fn.choice.html" title="fn combine::choice">choice</a></dt><dd>Takes a tuple, a slice or an array of parsers and tries to apply them each in order.
Fails if all the parsers fails or if an applied parser consumes input before failing.</dd><dt><a class="fn" href="fn.count.html" title="fn combine::count">count</a></dt><dd>Parses <code>parser</code> from zero up to <code>count</code> times.</dd><dt><a class="fn" href="fn.count_min_max.html" title="fn combine::count_min_max">count_<wbr>min_<wbr>max</a></dt><dd>Parses <code>parser</code> from <code>min</code> to <code>max</code> times (including <code>min</code> and <code>max</code>).</dd><dt><a class="fn" href="fn.eof.html" title="fn combine::eof">eof</a></dt><dd>Succeeds only if the stream is at end of input, fails otherwise.</dd><dt><a class="fn" href="fn.from_str.html" title="fn combine::from_str">from_<wbr>str</a></dt><dd>Takes a parser that outputs a string like value (<code>&amp;str</code>, <code>String</code>, <code>&amp;[u8]</code> or <code>Vec&lt;u8&gt;</code>) and parses it
using <code>std::str::FromStr</code>. Errors if the output of <code>parser</code> is not UTF-8 or if
<code>FromStr::from_str</code> returns an error.</dd><dt><a class="fn" href="fn.look_ahead.html" title="fn combine::look_ahead">look_<wbr>ahead</a></dt><dd><code>look_ahead(p)</code> acts as <code>p</code> but doesn’t consume input on success.</dd><dt><a class="fn" href="fn.many.html" title="fn combine::many">many</a></dt><dd>Parses <code>p</code> zero or more times returning a collection with the values from <code>p</code>.</dd><dt><a class="fn" href="fn.many1.html" title="fn combine::many1">many1</a></dt><dd>Parses <code>p</code> one or more times returning a collection with the values from <code>p</code>.</dd><dt><a class="fn" href="fn.none_of.html" title="fn combine::none_of">none_of</a></dt><dd>Extract one token and succeeds if it is not part of <code>tokens</code>.</dd><dt><a class="fn" href="fn.not_followed_by.html" title="fn combine::not_followed_by">not_<wbr>followed_<wbr>by</a></dt><dd>Succeeds only if <code>parser</code> fails.
Never consumes any input.</dd><dt><a class="fn" href="fn.one_of.html" title="fn combine::one_of">one_of</a></dt><dd>Extract one token and succeeds if it is part of <code>tokens</code>.</dd><dt><a class="fn" href="fn.optional.html" title="fn combine::optional">optional</a></dt><dd>Parses <code>parser</code> and outputs <code>Some(value)</code> if it succeeds, <code>None</code> if it fails without
consuming any input. Fails if <code>parser</code> fails after having committed some input.</dd><dt><a class="fn" href="fn.parser.html" title="fn combine::parser">parser</a></dt><dd>Wraps a function, turning it into a parser.</dd><dt><a class="fn" href="fn.position.html" title="fn combine::position">position</a></dt><dd>Parser which just returns the current position in the stream.</dd><dt><a class="fn" href="fn.produce.html" title="fn combine::produce">produce</a></dt><dd>Always returns the value produced by calling <code>f</code>.</dd><dt><a class="fn" href="fn.satisfy.html" title="fn combine::satisfy">satisfy</a></dt><dd>Parses a token and succeeds depending on the result of <code>predicate</code>.</dd><dt><a class="fn" href="fn.satisfy_map.html" title="fn combine::satisfy_map">satisfy_<wbr>map</a></dt><dd>Parses a token and passes it to <code>predicate</code>. If <code>predicate</code> returns <code>Some</code> the parser succeeds
and returns the value inside the <code>Option</code>. If <code>predicate</code> returns <code>None</code> the parser fails
without consuming any input.</dd><dt><a class="fn" href="fn.sep_by.html" title="fn combine::sep_by">sep_by</a></dt><dd>Parses <code>parser</code> zero or more time separated by <code>separator</code>, returning a collection with the
values from <code>p</code>.</dd><dt><a class="fn" href="fn.sep_by1.html" title="fn combine::sep_by1">sep_by1</a></dt><dd>Parses <code>parser</code> one or more time separated by <code>separator</code>, returning a collection with the
values from <code>p</code>.</dd><dt><a class="fn" href="fn.sep_end_by.html" title="fn combine::sep_end_by">sep_<wbr>end_<wbr>by</a></dt><dd>Parses <code>parser</code> zero or more times separated and ended by <code>separator</code>, returning a collection
with the values from <code>p</code>.</dd><dt><a class="fn" href="fn.sep_end_by1.html" title="fn combine::sep_end_by1">sep_<wbr>end_<wbr>by1</a></dt><dd>Parses <code>parser</code> one or more times separated and ended by <code>separator</code>, returning a collection
with the values from <code>p</code>.</dd><dt><a class="fn" href="fn.skip_count.html" title="fn combine::skip_count">skip_<wbr>count</a></dt><dd>Parses <code>parser</code> from zero up to <code>count</code> times skipping the output of <code>parser</code>.</dd><dt><a class="fn" href="fn.skip_count_min_max.html" title="fn combine::skip_count_min_max">skip_<wbr>count_<wbr>min_<wbr>max</a></dt><dd>Parses <code>parser</code> from <code>min</code> to <code>max</code> times (including <code>min</code> and <code>max</code>)
skipping the output of <code>parser</code>.</dd><dt><a class="fn" href="fn.skip_many.html" title="fn combine::skip_many">skip_<wbr>many</a></dt><dd>Parses <code>p</code> zero or more times ignoring the result.</dd><dt><a class="fn" href="fn.skip_many1.html" title="fn combine::skip_many1">skip_<wbr>many1</a></dt><dd>Parses <code>p</code> one or more times ignoring the result.</dd><dt><a class="fn" href="fn.token.html" title="fn combine::token">token</a></dt><dd>Parses a character and succeeds if the character is equal to <code>c</code>.</dd><dt><a class="fn" href="fn.tokens.html" title="fn combine::tokens">tokens</a></dt><dd>Parses multiple tokens.</dd><dt><a class="fn" href="fn.tokens_cmp.html" title="fn combine::tokens_cmp">tokens_<wbr>cmp</a></dt><dd>Parses multiple tokens.</dd><dt><a class="fn" href="fn.unexpected.html" title="fn combine::unexpected">unexpected</a></dt><dd>Always fails with <code>message</code> as an unexpected error.
Never consumes any input.</dd><dt><a class="fn" href="fn.unexpected_any.html" title="fn combine::unexpected_any">unexpected_<wbr>any</a></dt><dd>Always fails with <code>message</code> as an unexpected error.
Never consumes any input.</dd><dt><a class="fn" href="fn.value.html" title="fn combine::value">value</a></dt><dd>Always returns the value <code>v</code> without consuming any input.</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><dl class="item-table"><dt><a class="type" href="type.StdParseResult.html" title="type combine::StdParseResult">StdParse<wbr>Result</a></dt><dd>A type alias over the specific <code>Result</code> type used by parsers to indicate whether they were
successful or not.
<code>O</code> is the type that is output on success.
<code>Input</code> is the specific stream type used in the parser.</dd></dl><script type="text/json" id="notable-traits-data">{"IntoIter<T>":"<h3>Notable traits for <code><a class=\"struct\" href=\"https://doc.rust-lang.org/1.86.0/core/result/struct.IntoIter.html\" title=\"struct core::result::IntoIter\">IntoIter</a>&lt;T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.86.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"https://doc.rust-lang.org/1.86.0/core/result/struct.IntoIter.html\" title=\"struct core::result::IntoIter\">IntoIter</a>&lt;T&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.86.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = T;</div>","Iter<'_, Input, Self, Self::PartialState, FirstMode>":"<h3>Notable traits for <code><a class=\"struct\" href=\"parser/repeat/struct.Iter.html\" title=\"struct combine::parser::repeat::Iter\">Iter</a>&lt;'a, Input, P, S, M&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, Input, P, S, M&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.86.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"parser/repeat/struct.Iter.html\" title=\"struct combine::parser::repeat::Iter\">Iter</a>&lt;'a, Input, P, S, M&gt;<div class=\"where\">where\n    Input: <a class=\"trait\" href=\"trait.Stream.html\" title=\"trait combine::Stream\">Stream</a>,\n    P: <a class=\"trait\" href=\"trait.Parser.html\" title=\"trait combine::Parser\">Parser</a>&lt;Input&gt;,\n    S: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.86.0/core/borrow/trait.BorrowMut.html\" title=\"trait core::borrow::BorrowMut\">BorrowMut</a>&lt;P::<a class=\"associatedtype\" href=\"trait.Parser.html#associatedtype.PartialState\" title=\"type combine::Parser::PartialState\">PartialState</a>&gt;,\n    M: ParseMode,</div></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.86.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = P::<a class=\"associatedtype\" href=\"trait.Parser.html#associatedtype.Output\" title=\"type combine::Parser::Output\">Output</a>;</div>","Iter<'_, T>":"<h3>Notable traits for <code><a class=\"struct\" href=\"https://doc.rust-lang.org/1.86.0/core/result/struct.Iter.html\" title=\"struct core::result::Iter\">Iter</a>&lt;'a, T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.86.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"https://doc.rust-lang.org/1.86.0/core/result/struct.Iter.html\" title=\"struct core::result::Iter\">Iter</a>&lt;'a, T&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.86.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.86.0/std/primitive.reference.html\">&amp;'a T</a>;</div>","Iter<'a, Input, Self, &'s mut Self::PartialState, M>":"<h3>Notable traits for <code><a class=\"struct\" href=\"parser/repeat/struct.Iter.html\" title=\"struct combine::parser::repeat::Iter\">Iter</a>&lt;'a, Input, P, S, M&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, Input, P, S, M&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.86.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"parser/repeat/struct.Iter.html\" title=\"struct combine::parser::repeat::Iter\">Iter</a>&lt;'a, Input, P, S, M&gt;<div class=\"where\">where\n    Input: <a class=\"trait\" href=\"trait.Stream.html\" title=\"trait combine::Stream\">Stream</a>,\n    P: <a class=\"trait\" href=\"trait.Parser.html\" title=\"trait combine::Parser\">Parser</a>&lt;Input&gt;,\n    S: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.86.0/core/borrow/trait.BorrowMut.html\" title=\"trait core::borrow::BorrowMut\">BorrowMut</a>&lt;P::<a class=\"associatedtype\" href=\"trait.Parser.html#associatedtype.PartialState\" title=\"type combine::Parser::PartialState\">PartialState</a>&gt;,\n    M: ParseMode,</div></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.86.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = P::<a class=\"associatedtype\" href=\"trait.Parser.html#associatedtype.Output\" title=\"type combine::Parser::Output\">Output</a>;</div>","IterMut<'_, T>":"<h3>Notable traits for <code><a class=\"struct\" href=\"https://doc.rust-lang.org/1.86.0/core/result/struct.IterMut.html\" title=\"struct core::result::IterMut\">IterMut</a>&lt;'a, T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.86.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"https://doc.rust-lang.org/1.86.0/core/result/struct.IterMut.html\" title=\"struct core::result::IterMut\">IterMut</a>&lt;'a, T&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.86.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.86.0/std/primitive.reference.html\">&amp;'a mut T</a>;</div>"}</script></section></div></main></body></html>
---
source: linera-views-derive/src/lib.rs
expression: "pretty(generate_view_code(input, true))"
---
impl<C, MyParam> linera_views::views::View for TestView<C, MyParam>
where
    C: linera_views::context::Context,
    MyParam: Send + Sync + 'static,
    RegisterView<C, usize>: linera_views::views::View<Context = C>,
    CollectionView<
        C,
        usize,
        RegisterView<C, usize>,
    >: linera_views::views::View<Context = C>,
{
    const NUM_INIT_KEYS: usize = <RegisterView<
        C,
        usize,
    > as linera_views::views::View>::NUM_INIT_KEYS
        + <CollectionView<
            C,
            usize,
            RegisterView<C, usize>,
        > as linera_views::views::View>::NUM_INIT_KEYS;
    type Context = C;
    fn context(&self) -> &C {
        self.register.context()
    }
    fn pre_load(context: &C) -> Result<Vec<Vec<u8>>, linera_views::ViewError> {
        use linera_views::context::Context as _;
        let mut keys = Vec::new();
        let __linera_reserved_index = 0;
        let __linera_reserved_base_key = context
            .base_key()
            .derive_tag_key(
                linera_views::views::MIN_VIEW_TAG,
                &__linera_reserved_index,
            )?;
        keys.extend(
            RegisterView::<
                C,
                usize,
            >::pre_load(&context.clone_with_base_key(__linera_reserved_base_key))?,
        );
        let __linera_reserved_index = 1;
        let __linera_reserved_base_key = context
            .base_key()
            .derive_tag_key(
                linera_views::views::MIN_VIEW_TAG,
                &__linera_reserved_index,
            )?;
        keys.extend(
            CollectionView::<
                C,
                usize,
                RegisterView<C, usize>,
            >::pre_load(&context.clone_with_base_key(__linera_reserved_base_key))?,
        );
        Ok(keys)
    }
    fn post_load(
        context: C,
        values: &[Option<Vec<u8>>],
    ) -> Result<Self, linera_views::ViewError> {
        use linera_views::context::Context as _;
        let mut __linera_reserved_pos = 0;
        let __linera_reserved_index = 0;
        let __linera_reserved_pos_next = __linera_reserved_pos
            + RegisterView::<C, usize>::NUM_INIT_KEYS;
        let __linera_reserved_base_key = context
            .base_key()
            .derive_tag_key(
                linera_views::views::MIN_VIEW_TAG,
                &__linera_reserved_index,
            )?;
        let register = RegisterView::<
            C,
            usize,
        >::post_load(
            context.clone_with_base_key(__linera_reserved_base_key),
            &values[__linera_reserved_pos..__linera_reserved_pos_next],
        )?;
        __linera_reserved_pos = __linera_reserved_pos_next;
        let __linera_reserved_index = 1;
        let __linera_reserved_pos_next = __linera_reserved_pos
            + CollectionView::<C, usize, RegisterView<C, usize>>::NUM_INIT_KEYS;
        let __linera_reserved_base_key = context
            .base_key()
            .derive_tag_key(
                linera_views::views::MIN_VIEW_TAG,
                &__linera_reserved_index,
            )?;
        let collection = CollectionView::<
            C,
            usize,
            RegisterView<C, usize>,
        >::post_load(
            context.clone_with_base_key(__linera_reserved_base_key),
            &values[__linera_reserved_pos..__linera_reserved_pos_next],
        )?;
        __linera_reserved_pos = __linera_reserved_pos_next;
        Ok(Self { register, collection })
    }
    async fn load(context: C) -> Result<Self, linera_views::ViewError> {
        use linera_views::{context::Context as _, store::ReadableKeyValueStore as _};
        if Self::NUM_INIT_KEYS == 0 {
            Self::post_load(context, &[])
        } else {
            let keys = Self::pre_load(&context)?;
            let values = context.store().read_multi_values_bytes(keys).await?;
            Self::post_load(context, &values)
        }
    }
    fn rollback(&mut self) {
        self.register.rollback();
        self.collection.rollback();
    }
    async fn has_pending_changes(&self) -> bool {
        if self.register.has_pending_changes().await {
            return true;
        }
        if self.collection.has_pending_changes().await {
            return true;
        }
        false
    }
    fn flush(
        &mut self,
        batch: &mut linera_views::batch::Batch,
    ) -> Result<bool, linera_views::ViewError> {
        let deleted0 = self.register.flush(batch)?;
        let deleted1 = self.collection.flush(batch)?;
        Ok(deleted0 && deleted1)
    }
    fn clear(&mut self) {
        self.register.clear();
        self.collection.clear();
    }
}

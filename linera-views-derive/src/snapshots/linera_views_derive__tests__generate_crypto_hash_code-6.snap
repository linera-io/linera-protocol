---
source: linera-views-derive/src/lib.rs
expression: pretty(generate_crypto_hash_code(input))
---
#[linera_views::async_trait]
impl<MyParam> linera_views::views::CryptoHashView<custom::path::to::ContextType>
for TestView<MyParam>
where
    MyParam: Send + Sync + 'static,
    RegisterView<
        custom::path::to::ContextType,
        usize,
    >: linera_views::views::HashableView<custom::path::to::ContextType>,
    CollectionView<
        custom::path::to::ContextType,
        usize,
        RegisterView<custom::path::to::ContextType, usize>,
    >: linera_views::views::HashableView<custom::path::to::ContextType>,
    Self: Send + Sync,
{
    async fn crypto_hash(
        &self,
    ) -> Result<linera_base::crypto::CryptoHash, linera_views::views::ViewError> {
        use linera_base::crypto::{BcsHashable, CryptoHash};
        use linera_views::{
            batch::Batch, generic_array::GenericArray,
            sha3::{digest::OutputSizeUser, Sha3_256},
            views::HashableView,
        };
        use serde::{Serialize, Deserialize};
        #[derive(Serialize, Deserialize)]
        struct TestViewHash(GenericArray<u8, <Sha3_256 as OutputSizeUser>::OutputSize>);
        impl<'de> BcsHashable<'de> for TestViewHash {}
        let hash = self.hash().await?;
        Ok(CryptoHash::new(&TestViewHash(hash)))
    }
    async fn crypto_hash_mut(
        &mut self,
    ) -> Result<linera_base::crypto::CryptoHash, linera_views::views::ViewError> {
        use linera_base::crypto::{BcsHashable, CryptoHash};
        use linera_views::{
            batch::Batch, generic_array::GenericArray,
            sha3::{digest::OutputSizeUser, Sha3_256},
            views::HashableView,
        };
        use serde::{Serialize, Deserialize};
        #[derive(Serialize, Deserialize)]
        struct TestViewHash(GenericArray<u8, <Sha3_256 as OutputSizeUser>::OutputSize>);
        impl<'de> BcsHashable<'de> for TestViewHash {}
        let hash = self.hash_mut().await?;
        Ok(CryptoHash::new(&TestViewHash(hash)))
    }
}
